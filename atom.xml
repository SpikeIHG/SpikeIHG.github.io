<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Winter&#39;s</title>
  
  
  <link href="https://spikeihg.github.io/atom.xml" rel="self"/>
  
  <link href="https://spikeihg.github.io/"/>
  <updated>2023-10-15T13:53:13.056Z</updated>
  <id>https://spikeihg.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Begin_Again</title>
    <link href="https://spikeihg.github.io/2023/10/15/Begin-Again/"/>
    <id>https://spikeihg.github.io/2023/10/15/Begin-Again/</id>
    <published>2023-10-15T03:21:50.000Z</published>
    <updated>2023-10-15T13:53:13.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机科学中的自然原理"><a href="#计算机科学中的自然原理" class="headerlink" title="计算机科学中的自然原理"></a>计算机科学中的自然原理</h3><ul><li><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><font color =green>感谢过去一年中给予我启发的诸多事物，无论是一本书如CSAPP，一堂课如数字电路，或者一个人如Prof.Strang，所有这些人事都是促使我更加严肃地审视计算机科学与其背后丰富而美丽的思想。所以，我希望继承那些前辈，那群充满热情与想象力的先驱的工作，在这里对CSAPP中的美妙理论进行简答而又深刻的阐释（有点自大哈哈哈哈），希望在有限的时间与文字中，探寻科学与自然的美。</font></strong></p></li><li><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;计算机科学中的自然原理&quot;&gt;&lt;a href=&quot;#计算机科学中的自然原理&quot; class=&quot;headerlink&quot; title=&quot;计算机科学中的自然原理&quot;&gt;&lt;/a&gt;计算机科学中的自然原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cl</summary>
      
    
    
    
    
    <category term="自然" scheme="https://spikeihg.github.io/tags/%E8%87%AA%E7%84%B6/"/>
    
  </entry>
  
  <entry>
    <title>Parallel-Programming</title>
    <link href="https://spikeihg.github.io/2023/10/12/Parallel-Programming/"/>
    <id>https://spikeihg.github.io/2023/10/12/Parallel-Programming/</id>
    <published>2023-10-12T09:07:24.000Z</published>
    <updated>2023-10-15T14:00:00.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HPC-Parallel-Programming"><a href="#HPC-Parallel-Programming" class="headerlink" title="HPC - Parallel-Programming"></a>HPC - Parallel-Programming</h3><ol><li><h3 id="并行程序设计入门开始"><a href="#并行程序设计入门开始" class="headerlink" title="并行程序设计入门开始"></a><font color=seablue>并行程序设计入门开始</font></h3><ol><li><strong><a class="link"   href="https://heptagonhust.github.io/HPC-roadmap/" >RoadMap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>来自七边形</strong></li><li></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HPC-Parallel-Programming&quot;&gt;&lt;a href=&quot;#HPC-Parallel-Programming&quot; class=&quot;headerlink&quot; title=&quot;HPC - Parallel-Programming&quot;&gt;&lt;/a&gt;HPC - Parall</summary>
      
    
    
    
    
    <category term="HPC" scheme="https://spikeihg.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>逻辑电路</title>
    <link href="https://spikeihg.github.io/2023/10/11/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/"/>
    <id>https://spikeihg.github.io/2023/10/11/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</id>
    <published>2023-10-11T12:15:48.000Z</published>
    <updated>2023-10-11T12:24:15.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大爱逻辑电路，简洁是美的灵魂"><a href="#大爱逻辑电路，简洁是美的灵魂" class="headerlink" title="大爱逻辑电路，简洁是美的灵魂"></a><font color=pink>大爱逻辑电路，简洁是美的灵魂</font></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;大爱逻辑电路，简洁是美的灵魂&quot;&gt;&lt;a href=&quot;#大爱逻辑电路，简洁是美的灵魂&quot; class=&quot;headerlink&quot; title=&quot;大爱逻辑电路，简洁是美的灵魂&quot;&gt;&lt;/a&gt;&lt;font color=pink&gt;大爱逻辑电路，简洁是美的灵魂&lt;/font&gt;&lt;/h3&gt;</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://spikeihg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>BombLab</title>
    <link href="https://spikeihg.github.io/2023/10/07/BombLab/"/>
    <id>https://spikeihg.github.io/2023/10/07/BombLab/</id>
    <published>2023-10-07T11:36:16.000Z</published>
    <updated>2023-10-10T08:32:38.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫"><a href="#血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫" class="headerlink" title="血淋淋的教训啊 关bash的时候一起关了 直接没保存 全部没了 😫"></a><font color=pink>血淋淋的教训啊 关bash的时候一起关了 直接没保存 全部没了 😫</font></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫&quot;&gt;&lt;a href=&quot;#血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫&quot; class=&quot;headerlink&quot; title=&quot;血淋淋的教训啊 关bash的时候一起关了 直接没</summary>
      
    
    
    
    
    <category term="LINUX" scheme="https://spikeihg.github.io/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>TLCL@3</title>
    <link href="https://spikeihg.github.io/2023/10/04/TLCL-3/"/>
    <id>https://spikeihg.github.io/2023/10/04/TLCL-3/</id>
    <published>2023-10-04T09:48:31.000Z</published>
    <updated>2023-10-15T13:58:17.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TLCL-chapter-3"><a href="#TLCL-chapter-3" class="headerlink" title="TLCL chapter 3"></a>TLCL chapter 3</h2><h3 id="GOOOOOOOOOOOOOOD-解决了上传静态文件的-问题-在markdown里面变成-download-images-file-normal-pdf"><a href="#GOOOOOOOOOOOOOOD-解决了上传静态文件的-问题-在markdown里面变成-download-images-file-normal-pdf" class="headerlink" title="GOOOOOOOOOOOOOOD 解决了上传静态文件的 问题 在markdown里面变成 [download](\..\images\file\normal.pdf)"></a><font color=pink>GOOOOOOOOOOOOOOD 解决了上传静态文件的 问题 在markdown里面变成 [download](\..\images\file\normal.pdf)</font></h3><ul><li><h3 id="发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记"><a href="#发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记" class="headerlink" title="发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记"></a><font color=aqua>发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记</font></h3></li><li><h3 id="文件操作here"><a href="#文件操作here" class="headerlink" title="文件操作here"></a>文件操作<a class="link"   href="http://billie66.github.io/TLCL/book/chap16.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul><li>设计很多底层硬件，由于wsl与虚拟机文件差别较大暂时skip read</li></ul></li><li><h3 id="网络葵花宝典下载"><a href="#网络葵花宝典下载" class="headerlink" title="网络葵花宝典下载"></a>网络<a href="/doc/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.pdf">葵花宝典下载</a></h3><ul><li>netstat 指令</li><li>ftp指令</li><li>telnet指令 都是可以直接使用相关协议</li><li>ftp lftp都可以下载文件</li><li><em><strong><font color=pink>wget指令直接下载界面 可行男泵</font></strong></em></li></ul></li><li><h3 id="SSH-secure-shell"><a href="#SSH-secure-shell" class="headerlink" title="SSH secure shell"></a>SSH secure shell</h3><ul><li><strong>这是一个协议 port number22</strong></li><li><strong><a class="link"   href="https://phoenixnap.com/kb/ssh-to-connect-to-remote-server-linux-or-windows#:~:text=Open%20the%20terminal%20on%20the,ssh%20localhost%20and%20hit%20enter." >一个sshlocalhost教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></li></ul></li><li><h3 id="locate-amp-find"><a href="#locate-amp-find" class="headerlink" title="locate &amp; find"></a>locate &amp; find</h3><ul><li><em><strong><font color=pink>我是真的有病，又一次忘记保存全部没了</font></strong></em></li><li><img                       lazyload                     src="/images/loading.svg"                     data-src="D:\github.1.0\My_blog_hexo\source\images\tests.png"                                     ></li></ul></li><li><p><img                       lazyload                     src="/images/loading.svg"                     data-src="D:\github.1.0\My_blog_hexo\source\images\lo.png"                                     ></p><ul><li><strong>注意可以进行执行自己的操作 -exec cmd ‘{}’ ‘;’ 注意 {} ； 必不可少 {} 代表的是当前路径 ； 代表命令的结束 要引用起来 因为都是特殊涵义的字符 可以用+ 这样就是全部执行 而不是每次都执行一次 同时可以用-ok 指令代替我们的-exec 这样每次都会进行一下询问 ！！！！</strong></li><li><strong><font color=green>压缩文件</font></strong><ul><li><em><strong>gzip and gunzip</strong></em></li><li><em><strong>gzip + file 注意没有中间选项 此时是原始文件 但是可以对一压缩的文件进行选项查看</strong></em></li><li><em><strong>gunzip -c file.gz 查看压缩文件的内容</strong></em></li><li><em><strong>bzip2 也是一个类似于 gzip的命令 压缩程度更高 gzip -d 就相当于解压缩了</strong></em></li></ul></li><li><strong><font color=blue>归档文件 archiving !!!!</font></strong><ul><li><strong>tar tape archive 备份归档 一组独立的文件或者几个目录 或者两者兼有 通常后缀 为.tar h或者 .tgz 表示 gzip压缩过的归档包</strong></li><li><strong>四个模式 注意先写模式 再写选项</strong></li><li><strong>cf czf 都是创建 tvf 列举查看 xf xvf 就是复原 注意路径名格式</strong></li><li><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/tar.png"                                     ></li><li><em><strong>zip unzip 与tar和gzip的结合  类似 但是更多用于 与windows交互</strong></em></li></ul></li><li><em><strong>同步<a class="link"   href="http://billie66.github.io/TLCL/book/chap19.html" >可以看看但是似乎目前用的不多 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></li><li><em><strong><font color=pink>中间暂时跳过了文本处理和正则来个比较重要的make</font></strong></em><ul><li>脚本语言不需要编译 而是直接执行 例如 shell脚本 python PHP perl ruby</li><li>tar tzvf tarfile | head — 检查指令</li><li>通过这个可以看到一些标准版本源代码的组织形式 其中有一些大写的如README INSTALL 等介绍文件 同时 还有configure文件用于 配置的 同时就是各种头文件和源文件</li><li><em><strong><font color=red>系统的源码通常维护再&#x2F;usr&#x2F;src 中 供多个用户试用的源码通常再&#x2F;usr&#x2F;local&#x2F;src 中</font></strong></em></li><li>构建通常两步 .&#x2F;configure make</li><li>.&#x2F;configure 主要配置相关的需要的环境和依赖项同时创建makefile</li><li>sudo make install 对于一些包装良好的库 可以直接执行此命令安装成功</li></ul></li><li><em><strong><font color=pink>LINUX小子第二步——Shell脚本</font></strong></em><ul><li>编写脚本三步</li><li><em><strong>写一个脚本</strong></em></li><li><em><strong>让其可执行 chomod 755 file 对所有人都可执行 700只有拥有者可以执行</strong></em></li><li><em><strong>放在一个shell能找到的位置 配置PATH 这个原理就是对于可执行文件 如果直接输入名字 shell会在环境变量的path路径中寻找 因此对于通常自己的没有位于相关路径的脚本是找不到的所以需要文件路径通常我们使用相对路径 .&#x2F;prog</strong></em></li></ul></li><li><em><strong><font color=green>安装chrome成功 还得是微软教程但是有乱码的问题同时除了搜索以为ia其他时候都很慢</font></strong></em><ul><li></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TLCL-chapter-3&quot;&gt;&lt;a href=&quot;#TLCL-chapter-3&quot; class=&quot;headerlink&quot; title=&quot;TLCL chapter 3&quot;&gt;&lt;/a&gt;TLCL chapter 3&lt;/h2&gt;&lt;h3 id=&quot;GOOOOOOOOOOOOOOD-</summary>
      
    
    
    
    
    <category term="LINUX" scheme="https://spikeihg.github.io/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>signature</title>
    <link href="https://spikeihg.github.io/2023/10/02/signature/"/>
    <id>https://spikeihg.github.io/2023/10/02/signature/</id>
    <published>2023-10-02T09:15:59.000Z</published>
    <updated>2023-10-03T03:03:01.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ps了一个签名方便以后用"><a href="#ps了一个签名方便以后用" class="headerlink" title="ps了一个签名方便以后用"></a><font color=pink>ps了一个签名方便以后用</font></h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/%E7%AD%BE%E5%90%8D.png"                      alt="我的签名"                ></p><blockquote><p>你别说有点书法的感觉 哈哈哈哈哈！</p></blockquote><h3 id="还是应该记录下方法-ps-魔棒选择-每次扣几笔然后ctrl-c-ctrlv-复制一个图层-最后合并可见图层"><a href="#还是应该记录下方法-ps-魔棒选择-每次扣几笔然后ctrl-c-ctrlv-复制一个图层-最后合并可见图层" class="headerlink" title="还是应该记录下方法 ps 魔棒选择 每次扣几笔然后ctrl c ctrlv 复制一个图层 最后合并可见图层"></a><font color=pink>还是应该记录下方法 ps 魔棒选择 每次扣几笔然后ctrl c ctrlv 复制一个图层 最后合并可见图层</font></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ps了一个签名方便以后用&quot;&gt;&lt;a href=&quot;#ps了一个签名方便以后用&quot; class=&quot;headerlink&quot; title=&quot;ps了一个签名方便以后用&quot;&gt;&lt;/a&gt;&lt;font color=pink&gt;ps了一个签名方便以后用&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;&lt;img  </summary>
      
    
    
    
    
    <category term="signature" scheme="https://spikeihg.github.io/tags/signature/"/>
    
  </entry>
  
  <entry>
    <title>TLCL@2</title>
    <link href="https://spikeihg.github.io/2023/09/30/TLCL-2/"/>
    <id>https://spikeihg.github.io/2023/09/30/TLCL-2/</id>
    <published>2023-09-30T02:56:45.000Z</published>
    <updated>2023-10-03T12:23:07.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TLCL"><a href="#TLCL" class="headerlink" title="TLCL"></a>TLCL</h2><blockquote><p>新的开始 </p></blockquote><h4 id="今天怒创了两个用户-密码都是老密码alt-t-google-translate-x2F-the-search-box-alt-left-ctrl-shift-aalt-左右键是返回上一个页面-ctrl-tab-下一个标签-ctrl-shift-tab-上一个"><a href="#今天怒创了两个用户-密码都是老密码alt-t-google-translate-x2F-the-search-box-alt-left-ctrl-shift-aalt-左右键是返回上一个页面-ctrl-tab-下一个标签-ctrl-shift-tab-上一个" class="headerlink" title="今天怒创了两个用户 密码都是老密码alt t google translate &#x2F; the search box alt left   ctrl shift aalt 左右键是返回上一个页面 ctrl tab 下一个标签 ctrl shift tab 上一个 "></a><font color=aqua>今天怒创了两个用户 密码都是老密码<br>alt t google translate &#x2F; the search box alt left   ctrl shift a<br>alt 左右键是返回上一个页面 ctrl tab 下一个标签 ctrl shift tab 上一个 </font></h4><h3 id="发现两个有用的东西-google搜索栏使用小数字键盘的上下键可以查看推荐搜索-然后就是cmd中打开md-x2F-example-md-键入就可以-原来要运行可运行文件要在前面加上一个-x2F"><a href="#发现两个有用的东西-google搜索栏使用小数字键盘的上下键可以查看推荐搜索-然后就是cmd中打开md-x2F-example-md-键入就可以-原来要运行可运行文件要在前面加上一个-x2F" class="headerlink" title="发现两个有用的东西 google搜索栏使用小数字键盘的上下键可以查看推荐搜索 然后就是cmd中打开md .&#x2F;example.md 键入就可以 原来要运行可运行文件要在前面加上一个.&#x2F;"></a><font color=pink>发现两个有用的东西 google搜索栏使用小数字键盘的上下键可以查看推荐搜索 然后就是cmd中打开md .&#x2F;example.md 键入就可以 原来要运行可运行文件要在前面加上一个.&#x2F;</font></h3><h4 id="command-syntaxsyntax2syntax3q-amp-a"><a href="#command-syntaxsyntax2syntax3q-amp-a" class="headerlink" title="command syntaxsyntax2syntax3q&amp;a"></a><font color=seagreen><a class="link"   href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key" >command syntax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="http://docopt.org/" >syntax2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_01" >syntax3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://stackoverflow.com/questions/9725675/is-there-a-standard-format-for-command-line-shell-help-text" >q&amp;a <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></h4><h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/history.png"                      title="历史的操作"                ></p><ul><li><h3 id="历史操作"><a href="#历史操作" class="headerlink" title="历史操作"></a>历史操作</h3><ul><li><em><strong>history 操作，history | less |grep tldr</strong></em></li></ul></li><li><h3 id="权限security"><a href="#权限security" class="headerlink" title="权限security"></a>权限security</h3><ul><li><em><strong>change the mode chmod cmd 改变rwx属性可以使用八进制数字来表示也可以用字符 <font color=red><a class="link"   href="http://billie66.github.io/TLCL/book/chap10.html" >chmod <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></strong></em></li><li><em><strong>su and sudo su 就是以另一个身份运行shell 而sudo是以另一个身份执行命令 最大的区别是su会重建一个设立了环境 而sudo不会</strong></em></li><li><em><strong>chown 改变用户权限 目前使用不是很多</strong></em></li><li><em><strong>passwd 命令用作更改i密码</strong></em></li><li><em><strong><font color=pink>good in wsl2 额可以touch 创建文件 同时可以code 编辑code似乎有许多有趣的指令</font></strong></em></li><li><em><strong><font color=red>想要切换用户 也就是一个全新的bash的话 用 su -l doudou .eg 退出的时候使用 exit就可以了</font></strong></em></li><li><em><strong><font color=blue>至于使用创建用户的命令就是adduser name 注意名字不能以大写字母开头 doudou</font></strong></em></li></ul></li><li><h3 id="核心概念-Process-进程link"><a href="#核心概念-Process-进程link" class="headerlink" title="核心概念 Process 进程link"></a>核心概念 Process 进程<a class="link"   href="http://billie66.github.io/TLCL/book/chap11.html" >link <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul><li><em><strong>init kernel进行run&#x2F;etc里的script所以为什么可以更改的原因</strong></em></li><li><strong>ctrl + c 强制返回的一种方法</strong></li><li><em><strong><font color=pink>&#x2F;proc    &#x2F;sys 文件系统 可以查看相关硬件划分信息</font><br>备份文件的名字无关紧要，只要选择一个容易理解的文件名。扩展名 “.bak”、”.sav”、 “.old”和 “.orig” 都是用来指示备份文件的流行方法。哦，记住 cp 命令会默默地覆盖已经存在的同名文件。  bak stand for backup file</strong></em></li></ul></li><li><h3 id="Nano与其他文本编辑器"><a href="#Nano与其他文本编辑器" class="headerlink" title="Nano与其他文本编辑器"></a>Nano与其他<a class="link"   href="http://billie66.github.io/TLCL/book/chap12.html" >文本编辑器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul><li><em><strong><font color=pink>之前学的很多bash的指令到很多编辑器里都是一样的</font></strong></em></li><li><em><strong><font color=pink>source .bashrc 生效指令</font></strong></em></li><li><em><strong><font color=pink>ctrl o in nano 保存</font></strong></em></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TLCL&quot;&gt;&lt;a href=&quot;#TLCL&quot; class=&quot;headerlink&quot; title=&quot;TLCL&quot;&gt;&lt;/a&gt;TLCL&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;新的开始 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;今天怒创了两个用户-密码都是老密码</summary>
      
    
    
    
    
    <category term="LINUX" scheme="https://spikeihg.github.io/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>TGA_CXX</title>
    <link href="https://spikeihg.github.io/2023/09/22/TGA-CXX/"/>
    <id>https://spikeihg.github.io/2023/09/22/TGA-CXX/</id>
    <published>2023-09-22T07:21:07.000Z</published>
    <updated>2023-10-02T13:01:52.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TGA关于c"><a href="#TGA关于c" class="headerlink" title="TGA关于c++"></a><font color=seablue>TGA关于c++</font></h3><ul><li><h4 id="C-操作文件-这里记录一些相关要用的知识点-便于统一看"><a href="#C-操作文件-这里记录一些相关要用的知识点-便于统一看" class="headerlink" title="C++操作文件 这里记录一些相关要用的知识点 便于统一看"></a>C++操作文件 这里记录一些相关要用的知识点 便于统一看</h4><ul><li>**流访问，有open std::ios::binary ,.good(),.get(),.read()的一些参数 **</li><li><strong>重载函数规范有点忘记。</strong></li><li><strong>copy (stored data) to a different location, especially so as to protect against loss.  <font color=gold>dump in computer mean</font></strong></li><li><strong>ESCAPE SYMBOL 溢出符号</strong></li><li><strong><font color=seagreen>Run-length encode a lossless encode method  just to replace the runS(many values occurs consecutivelt) w12b2cd13e32 .eg</font></strong></li><li><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/const.png"                      alt="const只是语法检查 所以地址转换是一个编程漏洞"                ></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;TGA关于c&quot;&gt;&lt;a href=&quot;#TGA关于c&quot; class=&quot;headerlink&quot; title=&quot;TGA关于c++&quot;&gt;&lt;/a&gt;&lt;font color=seablue&gt;TGA关于c++&lt;/font&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;C-操作文件-这里</summary>
      
    
    
    
    
    <category term="CXX" scheme="https://spikeihg.github.io/tags/CXX/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP</title>
    <link href="https://spikeihg.github.io/2023/09/16/CSAPP/"/>
    <id>https://spikeihg.github.io/2023/09/16/CSAPP/</id>
    <published>2023-09-16T07:59:01.000Z</published>
    <updated>2023-10-05T05:45:21.613Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="CSAPP"><a href="#CSAPP" class="headerlink" title="CSAPP"></a>CSAPP</h2><ul><li><h3 id="terms-colletion"><a href="#terms-colletion" class="headerlink" title="terms colletion"></a>terms colletion</h3><ul><li>snippet re-useble code part maybe name the directory</li></ul></li><li><h3 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h3><ul><li>to long didn’t read and a linux simplified manual cm</li></ul></li><li><p><a href="/doc/normal.pdf">Try</a></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;CSAPP&quot;&gt;&lt;a href=&quot;#CSAPP&quot; class=&quot;headerlink&quot; title=&quot;CSAPP&quot;&gt;&lt;/a&gt;CSAPP&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;terms-colletion&quot;&gt;&lt;a href=&quot;#terms-co</summary>
      
    
    
    
    
    <category term="组成原理" scheme="https://spikeihg.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Cmake</title>
    <link href="https://spikeihg.github.io/2023/09/12/Cmake/"/>
    <id>https://spikeihg.github.io/2023/09/12/Cmake/</id>
    <published>2023-09-12T09:11:06.000Z</published>
    <updated>2023-10-02T09:41:49.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可以开始了解CMake"><a href="#可以开始了解CMake" class="headerlink" title="可以开始了解CMake"></a>可以开始了解CMake</h2><p><em><strong>只是简单得贴一个网址</strong></em></p><p><em><strong>[CMAKE](<a class="link"   href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html" >CMake Tutorial — CMake 3.27.4 Documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</strong></em></p><p><em><strong><a class="link"   href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/" >CPPformal <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></p><p><a class="link"   href="https://github.com/nlohmann/json" >json <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>[redfiredoc](<a class="link"   href="https://redefine-docs.ohevan.com/getting-started" >快速开始 - Redefine Docs (ohevan.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;可以开始了解CMake&quot;&gt;&lt;a href=&quot;#可以开始了解CMake&quot; class=&quot;headerlink&quot; title=&quot;可以开始了解CMake&quot;&gt;&lt;/a&gt;可以开始了解CMake&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;只是简单得贴一个网址&lt;/strong&gt;&lt;/e</summary>
      
    
    
    
    
    <category term="Cmake" scheme="https://spikeihg.github.io/tags/Cmake/"/>
    
  </entry>
  
  <entry>
    <title>TLCL</title>
    <link href="https://spikeihg.github.io/2023/05/06/TLCL/"/>
    <id>https://spikeihg.github.io/2023/05/06/TLCL/</id>
    <published>2023-05-06T07:02:35.000Z</published>
    <updated>2023-09-29T08:39:42.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TLCL"><a href="#TLCL" class="headerlink" title="TLCL"></a>TLCL</h1><ul><li><h2 id="Why-Linux？"><a href="#Why-Linux？" class="headerlink" title="Why Linux？"></a><strong>Why Linux？</strong></h2><ul><li><h3 id="linux-人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！"><a href="#linux-人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！" class="headerlink" title="linux 人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！"></a>linux 人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！</h3></li><li><h3 id="shell-解释-是kernel-outermost-layer-os向用户提供的一个interface有两种类型的，一种是CLS-cmdline形式的-而对应的有相关的scriped-language-例如bash-还有就是xwindows-驱动的GUI"><a href="#shell-解释-是kernel-outermost-layer-os向用户提供的一个interface有两种类型的，一种是CLS-cmdline形式的-而对应的有相关的scriped-language-例如bash-还有就是xwindows-驱动的GUI" class="headerlink" title="shell 解释 是kernel outermost layer os向用户提供的一个interface有两种类型的，一种是CLS cmdline形式的 而对应的有相关的scriped language 例如bash 还有就是xwindows 驱动的GUI"></a>shell 解释 是kernel outermost layer os向用户提供的一个interface有两种类型的，一种是CLS cmdline形式的 而对应的有相关的scriped language 例如bash 还有就是xwindows 驱动的GUI</h3></li></ul></li><li><p>贴个网址 <a class="link"   href="http://billie66.github.io/TLCL/book/index.html" >TLCL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p><a class="link"   href="http://www.gnu.org/software/bash/manual/bashref.html" >bash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li></li><li><h2 id="alt-left-arrow-is-black-to-last-page-return-and-ctrl-1-2-3-is-switch-between-different-tabs-good-final-got-some-more-ctrl-T-new-tab-and-ctrl-n-new-windows-ctrl-shift-n-new-inrecognized-windows-AND-TYPE-THE-ALT-YOU-CAN-GO-THE-UPPERRIGHT-CORNER-AND-USE-YOUR-UP-DOWN-RIGHT-LEFT-KEY-TO-CHOOSE-右上防三个原点-点一次-alt就够了-another-smooth-command-use-the-x2F-to-goto-the-search-box"><a href="#alt-left-arrow-is-black-to-last-page-return-and-ctrl-1-2-3-is-switch-between-different-tabs-good-final-got-some-more-ctrl-T-new-tab-and-ctrl-n-new-windows-ctrl-shift-n-new-inrecognized-windows-AND-TYPE-THE-ALT-YOU-CAN-GO-THE-UPPERRIGHT-CORNER-AND-USE-YOUR-UP-DOWN-RIGHT-LEFT-KEY-TO-CHOOSE-右上防三个原点-点一次-alt就够了-another-smooth-command-use-the-x2F-to-goto-the-search-box" class="headerlink" title="alt + left arrow is black to last page return  and ctrl + 1  2  3 is switch between different tabs  good final got some more ctrl + T new tab and ctrl + n new windows ctrl +shift +n new inrecognized windows AND TYPE THE ALT YOU CAN GO THE UPPERRIGHT CORNER AND USE YOUR UP DOWN RIGHT LEFT KEY TO CHOOSE 右上防三个原点 点一次 alt就够了    another smooth command  use the &#x2F; to goto the search box!!!!!"></a><em><strong><font color = pink>alt + left arrow is black to last page return  and ctrl + 1  2  3 is switch between different tabs  good final got some more ctrl + T new tab and ctrl + n new windows ctrl +shift +n new inrecognized windows AND TYPE THE ALT YOU CAN GO THE UPPERRIGHT CORNER AND USE YOUR UP DOWN RIGHT LEFT KEY TO CHOOSE 右上防三个原点 点一次 alt就够了    another smooth command  use the &#x2F; to goto the search box!!!!!</font></strong></em></h2></li><li><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><ul><li><h4 id="shift-ctrl-6-切出wsl"><a href="#shift-ctrl-6-切出wsl" class="headerlink" title="shift+ctrl+6 切出wsl"></a>shift+ctrl+6 切出wsl</h4></li><li><h4 id="winter——主机名，SPIKE——用户名"><a href="#winter——主机名，SPIKE——用户名" class="headerlink" title="winter——主机名，SPIKE——用户名"></a>winter——主机名，SPIKE——用户名</h4></li><li><h4 id="date-时间-calendar-日历"><a href="#date-时间-calendar-日历" class="headerlink" title="date 时间 calendar 日历"></a>date 时间 calendar 日历</h4></li><li><h4 id="ls-symbolized-stand-for-the-user-directory-ls-could-specify-the-dr-you-wanna-check"><a href="#ls-symbolized-stand-for-the-user-directory-ls-could-specify-the-dr-you-wanna-check" class="headerlink" title="ls ~ ~ symbolized stand for the user directory ls could specify the dr you wanna check."></a>ls ~ ~ symbolized stand for the user directory ls could specify the dr you wanna check.</h4></li><li><h4 id="we-could-add-some-format-cmd-to-reveal-more-details-ls-l"><a href="#we-could-add-some-format-cmd-to-reveal-more-details-ls-l" class="headerlink" title="we could add some format cmd to reveal more details ls -l"></a>we could add some format cmd to reveal more details ls -l</h4></li><li><h4 id="the-meaning-of-the-long-format-indicate-the-file-type-and-then-the-next-three-letters-indicates-the-access-rights-and-then"><a href="#the-meaning-of-the-long-format-indicate-the-file-type-and-then-the-next-three-letters-indicates-the-access-rights-and-then" class="headerlink" title="the meaning of the long format - indicate the file type and  then the next three letters indicates the access rights and then"></a>the meaning of the long format - indicate the file type and  then the next three letters indicates the access rights and then</h4></li><li><h4 id="f11-keystroke-could-full-screenize-the-console"><a href="#f11-keystroke-could-full-screenize-the-console" class="headerlink" title="f11 keystroke could full-screenize the console"></a>f11 keystroke could full-screenize the console</h4></li><li><h4 id="file-check-the-brief-info-of-a-file"><a href="#file-check-the-brief-info-of-a-file" class="headerlink" title="file check the brief info of a file"></a>file check the brief info of a file</h4></li><li><h4 id="everything-is-file-and-mostly-the-text-file-only-contain-ascii-code"><a href="#everything-is-file-and-mostly-the-text-file-only-contain-ascii-code" class="headerlink" title="everything is file and mostly the text file only contain ascii code"></a>everything is file and mostly the text file only contain ascii code</h4></li><li><h4 id="configuration-file-or-the-actually-source-file-most-stored-in-text-file-format"><a href="#configuration-file-or-the-actually-source-file-most-stored-in-text-file-format" class="headerlink" title="configuration file or the actually source file most stored in text file format"></a>configuration file or the actually source file most stored in text file format</h4></li><li><h4 id="less-less-is-more-and-the-up-down-arrow-q-h-n-some-key-cmd-you-should-know"><a href="#less-less-is-more-and-the-up-down-arrow-q-h-n-some-key-cmd-you-should-know" class="headerlink" title="less less is more and the up down arrow q h n some key cmd you should know"></a>less less is more and the up down arrow q h n some key cmd you should know</h4></li><li><h4 id="there-are-some-standard-pathname-in-unix-like-system-just-feel-free-to-explore-and-dont-mind-we-could-hardly-mess-up-for-the-administrator-keep-everything-in-order"><a href="#there-are-some-standard-pathname-in-unix-like-system-just-feel-free-to-explore-and-dont-mind-we-could-hardly-mess-up-for-the-administrator-keep-everything-in-order" class="headerlink" title="there are some standard pathname in unix-like system just feel free to explore , and dont mind ,we could hardly mess up for the administrator keep everything in order"></a>there are some standard pathname in unix-like system just feel free to explore , and dont mind ,we could hardly mess up for the administrator keep everything in order</h4></li><li><h4 id="wildcard-just-the-regular-expression-also-grep"><a href="#wildcard-just-the-regular-expression-also-grep" class="headerlink" title="wildcard just the regular expression also grep"></a>wildcard just the regular expression also grep</h4><ul><li>* mean the any chars ? one single char [set] [!set] [[:key:word​]]</li></ul></li><li><h4 id="mkdir-dirc-and-…-eg-mkdir-dir1-dir2-dir3"><a href="#mkdir-dirc-and-…-eg-mkdir-dir1-dir2-dir3" class="headerlink" title="mkdir dirc and … eg mkdir dir1 dir2 dir3"></a>mkdir dirc and … eg mkdir dir1 dir2 dir3</h4></li><li><h4 id="cp-mv-rm-like-the-copy-paste-and-cut-delete-in-windows"><a href="#cp-mv-rm-like-the-copy-paste-and-cut-delete-in-windows" class="headerlink" title="cp mv rm like the copy paste and cut delete in windows"></a>cp mv rm like the copy paste and cut delete in windows</h4><ul><li>when you want to handle a directory you need to use option -r recrusive</li><li><font color=aqua>Be careful with the combo of wildcard and rm so just invoke the ls first to check if the files listed are u really wanna remove no more change to restore the files</font></li><li><font color=gold>use the . to indicate the workplace </font></li><li><em>if you wanna some warning remeber to use op -i</em></li><li><strong>mv is rename also the same time if the file2 exists then is act like move ifnot then like the rename</strong></li></ul></li><li><h4 id="the-x2F-etc-is-text-configured-file-and-the-bin-is-usually-executable-and-x2F-usr-x2F-is-the-largest-folder-in-linux"><a href="#the-x2F-etc-is-text-configured-file-and-the-bin-is-usually-executable-and-x2F-usr-x2F-is-the-largest-folder-in-linux" class="headerlink" title="the &#x2F;etc is text configured file and the bin is usually executable and &#x2F;usr&#x2F; is the largest folder in linux"></a><font color=seagreen>the &#x2F;etc is text configured file and the bin is usually executable and &#x2F;usr&#x2F; is the largest folder in linux</font></h4></li><li><p><strong>这个ln 指令 ln -s 创建符号连接 有一点像windows的快捷方式 ln创建的是硬的链接 早期 智能文件 不能目录</strong></p></li><li><p><em><strong><font color =purple>What is cmd a new set of useful cmds</font></strong></em></p><ul><li><em><strong>所以命令的本质 有 一个可执行的二进制c函数  2shell python ruby脚本程序 3 shell内置 builtins 4 shell小函数 5 别名</strong></em></li><li><em><strong>use the type cmd to check the type of one cmd type [cmd]</strong></em></li><li><em><strong>which to check which is the cmd only used for the binary cmd</strong></em></li><li><em><strong>help cmd  used for the buildins cmd –help the same</strong></em></li><li><em><strong>man ls  use the manual very simple but difficult to read</strong></em></li><li><em><strong>apropos + cmd check the tips 挺有用的 apropos vim</strong></em></li><li><em><strong>info 一个更友好的 提示 有超链接</strong></em><ul><li>n 下一个超链接结点 p 上一个 u当前结点菜单 enter进入</li></ul></li><li><em><strong>zless 可以查看 .gz文件</strong></em></li><li><em><strong>whatis 一个简单的描述</strong></em></li></ul></li><li><p><em><strong><font color = pink>可以一行多个命令 用；隔开</font></strong></em></p></li><li><p><em><strong><font color=pink>alias 在自己命名之前先使用 type查看一下是否已经是已存在的命令 unalias 取消别名</font></strong></em></p></li><li><p><em><strong><font color =yellow>Evrything is a  file</font></strong></em></p></li><li><p><em><strong>&gt; 重定向 标准输入输出 错误  &gt; 改变标准输出 注意因此 每一次使用时都会使文件重写</strong></em></p></li><li><p><strong><font color=red>&gt; 从头开始 &gt;&gt; append  file discripitor 文件描述符 0 1 2 2&gt; 表示方法</font></strong></p></li><li><p><em><strong><font color=pink>新的方法来同时重定向我们的标准输入与输出&amp;&gt;     dev&#x2F;null 一个没用的数据桶 可以用作丢弃一些不用的显示信息</font></strong></em></p></li><li><p><em><strong><font color =pink> cat 与standard input 有关 cat 单独就是echo ctrl+z强制退出运行 ctrl+d EOF</font></strong></em></p></li><li><p><em><strong><font color=blue>ctrl+d 是 EOF</font></strong></em></p></li><li><p><em><strong><font color=red>| pipeline cmd1|cmd2 将1中的标准输出作为二中的标准输入    cat No?.txt &gt; poem.txt 连续连接文件的例子</font></strong></em></p></li><li><p>***filter 过滤器 ls -l &#x2F;usr&#x2F;bin &#x2F;bin | sort |uniq [-d看见重复内容]| less ***</p></li><li><p><em><strong><font color=pink>注意上面几个指令在无参数情况下都是默认接受标准输入 所以 可以使用管道符 很方便  wc 计数</font></strong></em></p></li><li><p><font color=pink>快乐的echo cmd  is special when use the echo it will do some process called expansion   obviously  when you see the echo it just mean use the regular expression </font></p><ul><li>***~ echo ~ 显示当前的目录 echo $((expr)) 进行幂展开 ***</li><li><em><strong>花括号展开 可以展开字符串表达式</strong></em></li><li><em><strong><font color=red>Parameter expansion 参数展开 very important echo $USER 就像这样  一个查看变量的命令 printenv | less</font></strong></em></li><li><em><strong><font color=red>command substitution use $(cmd) eg ls -l $(which cp)     file $(ls &#x2F;usr&#x2F;bin&#x2F;* | grep zip) 旧标准中有一个<code>which cp</code>可以代替 $()</font></strong></em></li><li><em><strong><font color=red>“”  sleep 单引号 echo -e $转义字符</font></strong></em></li><li><em><strong><font color=red>ctrl l     ctrl d   ctrl t  alt u alt l alt t alt f alt b</font></strong></em></li><li><em><strong><font color=red>tab alt ？ alt * ctrl k ctrl y set | less TLDR</font></strong></em></li></ul></li><li><h4 id="代表的是父文件-代表当前的工作文件"><a href="#代表的是父文件-代表当前的工作文件" class="headerlink" title=".. 代表的是父文件 . 代表当前的工作文件"></a>.. 代表的是父文件 . 代表当前的工作文件</h4></li><li><h4 id="dr-磁盘空间情况-free-内存空间情况"><a href="#dr-磁盘空间情况-free-内存空间情况" class="headerlink" title="dr 磁盘空间情况 free 内存空间情况"></a>dr 磁盘空间情况 free 内存空间情况</h4></li><li><h4 id="exit-退出程序"><a href="#exit-退出程序" class="headerlink" title="exit 退出程序"></a>exit 退出程序</h4></li><li><h4 id="ls-most-used-cmd-in-shell"><a href="#ls-most-used-cmd-in-shell" class="headerlink" title="ls most used cmd in shell"></a>ls most used cmd in shell</h4></li><li><h4 id="用户-superuser-rootuser"><a href="#用户-superuser-rootuser" class="headerlink" title="$ 用户     # superuser rootuser"></a>$ 用户     # superuser rootuser</h4></li><li><h4 id="file-navigation·"><a href="#file-navigation·" class="headerlink" title="file navigation·"></a>file navigation·</h4><ul><li><h5 id="pwd-print-name-of-workplace-directory"><a href="#pwd-print-name-of-workplace-directory" class="headerlink" title="pwd print name of workplace directory"></a>pwd print name of workplace directory</h5></li><li><h5 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd  change directory"></a>cd  change directory</h5></li><li><h5 id="ls-list-contents"><a href="#ls-list-contents" class="headerlink" title="ls list contents"></a>ls list contents</h5></li><li><h5 id="我们都处于-文件中间-home-通常初始-时-文件树-只有一棵-对于普通用户只有-user里具有写权限-其余需要-root"><a href="#我们都处于-文件中间-home-通常初始-时-文件树-只有一棵-对于普通用户只有-user里具有写权限-其余需要-root" class="headerlink" title="我们都处于 文件中间 home 通常初始 时 文件树 只有一棵 对于普通用户只有 user里具有写权限 其余需要 root"></a>我们都处于 文件中间 home 通常初始 时 文件树 只有一棵 对于普通用户只有 user里具有写权限 其余需要 root</h5></li><li><h5 id="absolute-pathname-relative-pathname"><a href="#absolute-pathname-relative-pathname" class="headerlink" title="absolute pathname relative pathname"></a>absolute pathname relative pathname</h5><ul><li>&#x2F; 根目录     .. &#x2F; 父目录 .&#x2F;当前工作目录 通常默认有这</li></ul><p></p></li><li><h4 id="cd-pathname"><a href="#cd-pathname" class="headerlink" title="cd + pathname"></a>cd + pathname</h4><ul><li>cd   或者是 cd ~默认进入用户文件夹</li></ul></li><li><p>cd ~user_name 进入对应名字 的用户文件夹</p><ul><li>cd - 回到先前 的文件夹</li></ul></li><li><p>cd .. 回到父文件</p></li></ul></li><li><h4 id="开头的文件夹-通常是不显示的-隐藏的-注入configuration-类的文件"><a href="#开头的文件夹-通常是不显示的-隐藏的-注入configuration-类的文件" class="headerlink" title=". 开头的文件夹 通常是不显示的 隐藏的 注入configuration 类的文件"></a>. 开头的文件夹 通常是不显示的 隐藏的 注入configuration 类的文件</h4></li></ul></li><li><h4 id="用-代替文件名-中的空格"><a href="#用-代替文件名-中的空格" class="headerlink" title="用 . _ - 代替文件名 中的空格"></a>用 . _ - 代替文件名 中的空格</h4></li><li><h4 id="支持-鼠标中间-paste-双击-copy-或者-选择-copy"><a href="#支持-鼠标中间-paste-双击-copy-或者-选择-copy" class="headerlink" title="支持 鼠标中间 paste 双击 copy 或者 选择 copy"></a>支持 鼠标中间 paste 双击 copy 或者 选择 copy</h4><ul><li><h4 id="上下键-寻找历史命令最大500个"><a href="#上下键-寻找历史命令最大500个" class="headerlink" title="上下键 寻找历史命令最大500个"></a>上下键 寻找历史命令最大500个</h4></li><li><h4 id="ls指令再探dd"><a href="#ls指令再探dd" class="headerlink" title="ls指令再探dd"></a>ls指令再探dd</h4><ul><li><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/lin.png"                                     ></p></li><li><h5 id="short-option-l-一个字母-可以组合-lt"><a href="#short-option-l-一个字母-可以组合-lt" class="headerlink" title="short option  -l 一个字母 可以组合 -lt"></a>short option  -l 一个字母 可以组合 -lt</h5></li></ul></li><li><h5 id="long-option-–reverse-全称"><a href="#long-option-–reverse-全称" class="headerlink" title="long option –reverse  全称"></a>long option –reverse  全称</h5></li><li><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/_1.png"                                     ></p></li></ul></li><li><h3 id="其实无论怎样都可以-command-–help-查看更多"><a href="#其实无论怎样都可以-command-–help-查看更多" class="headerlink" title="其实无论怎样都可以 command –help 查看更多"></a><font color=gold>其实无论怎样都可以 command –help 查看更多</font></h3></li><li><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><ul><li>查询文件 类型 file + filename</li></ul></li><li><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><ul><li><h4 id="less-查看文本文件-everything-is-file"><a href="#less-查看文本文件-everything-is-file" class="headerlink" title="less 查看文本文件 everything is file"></a>less 查看文本文件 everything is file</h4></li><li><h4 id="ascII-as-key"><a href="#ascII-as-key" class="headerlink" title="ascII as-key"></a>ascII as-key</h4><ul><li><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/less.png"                                     ></li></ul></li></ul></li><li><h4 id="键盘高级操作"><a href="#键盘高级操作" class="headerlink" title="键盘高级操作"></a>键盘高级操作</h4><ul><li><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/cl.png"                                     ></p><ul><li><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/cl1.png"                                     ></li><li><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/cl2.png"                                     ></li></ul></li><li><h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><ul><li>tab  单击</li><li>Alt + ? 显示可能的补全列表</li><li>Alt + * 插入所有可能的补全操作</li><li><img                       lazyload                     src="/images/loading.svg"                     data-src="/../images/his.png"                                     ></li><li></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TLCL&quot;&gt;&lt;a href=&quot;#TLCL&quot; class=&quot;headerlink&quot; title=&quot;TLCL&quot;&gt;&lt;/a&gt;TLCL&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;Why-Linux？&quot;&gt;&lt;a href=&quot;#Why-Linux？&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="LINUX" scheme="https://spikeihg.github.io/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>Floyd</title>
    <link href="https://spikeihg.github.io/2023/03/27/Floyd/"/>
    <id>https://spikeihg.github.io/2023/03/27/Floyd/</id>
    <published>2023-03-27T14:35:37.000Z</published>
    <updated>2023-03-29T15:34:00.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><ul><li><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><h4 id="一次解决全图"><a href="#一次解决全图" class="headerlink" title="一次解决全图"></a>一次解决全图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> vexnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">VerTexType vertices[MVNum];</span><br><span class="line">ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="插点的循环"><a href="#插点的循环" class="headerlink" title="插点的循环"></a>插点的循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; k++)<span class="comment">// 第一个</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line"><span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (C[v][w] &gt;C[v][k] +C[k][w])</span><br><span class="line">&#123;</span><br><span class="line">C[v][w] = C[v][k] +C[k][w];</span><br><span class="line">P[v][w] = P[v][k];<span class="comment">//相当于就是在里面加点 最后一个我们读取矩阵</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   Floyd.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  3/27/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// Floyd</span></span><br><span class="line"><span class="comment">//关键思想就是不断的插入点来分析 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Path = <span class="type">int</span>[MVNum][MVNum];</span><br><span class="line"><span class="keyword">using</span> ShortPathTable = <span class="type">int</span>[MVNum][MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最精妙的思想 一次求完所有的点 所以这是一个n^3复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样使用邻接矩阵</span></span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> vexnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">VerTexType vertices[MVNum];</span><br><span class="line">ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">const</span> AMGraph&amp; G,Path P,ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> v, w, k;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123;</span><br><span class="line">C[v][w] = G.arcs[v][w];</span><br><span class="line">P[v][w] = w;<span class="comment">// 注意这个初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非常巧妙的循环也是关键</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; k++)<span class="comment">// 第一个</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line"><span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (C[v][w] &gt;C[v][k] +C[k][w])</span><br><span class="line">&#123;</span><br><span class="line">C[v][w] = C[v][k] +C[k][w];</span><br><span class="line">P[v][w] = P[v][k];<span class="comment">//相当于就是在里面加点 最后一个我们读取矩阵</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意我们的这个路径矩阵 与迪杰斯特拉一样 然后是列来读取</span></span><br><span class="line"><span class="comment">// 数值 横着读取</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispath</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, Path P, ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;各点的最短路径如下\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum<span class="number">-1</span>; v++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = v + <span class="number">1</span>; w &lt; G.vexnum; w++)<span class="comment">// 只读取一般矩阵 也很好哦</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;-v&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot; weight: &quot;</span> &lt;&lt; C[v][w];</span><br><span class="line">k = P[v][w];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Path: &quot;</span> &lt;&lt; v;</span><br><span class="line"><span class="keyword">while</span> (k != w)</span><br><span class="line">&#123;</span><br><span class="line">k = P[k][w];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; k;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>最后其实就是这种插点的思想</p></blockquote><p><img src="/../images/ly.jpg" alt="hh"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Floyd算法&quot;&gt;&lt;a href=&quot;#Floyd算法&quot; class=&quot;headerlink&quot; title=&quot;Floyd算法&quot;&gt;&lt;/a&gt;Floyd算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://spikeihg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra</title>
    <link href="https://spikeihg.github.io/2023/03/27/Dijkstra/"/>
    <id>https://spikeihg.github.io/2023/03/27/Dijkstra/</id>
    <published>2023-03-27T13:36:16.000Z</published>
    <updated>2023-03-27T13:53:55.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><ul><li><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在一个图中，怎样找到一个点，到其余任何一个点的权值最小的路径，这个就是最短路径问题。</p></li><li><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><h4 id="从点入手"><a href="#从点入手" class="headerlink" title="从点入手"></a>从点入手</h4><p>我们从点的角度考虑，每次选择最短的路径，然后将新的端点家啊如考虑的集合。</p></li><li><h4 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h4><p>我们会遇到一个问题就是，如果新的点构成一条更短的路径，所以每加入一个点，就进行一个检查</p></li><li><h4 id="INF"><a href="#INF" class="headerlink" title="INF"></a>INF</h4><p>INF来建立，已判断是否相连</p></li></ul></li><li><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><ul><li><h4 id="final数组"><a href="#final数组" class="headerlink" title="final数组"></a>final数组</h4><p>final数组来判断是否已经有最短路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>[i] = <span class="number">0</span>;<span class="comment">// 0代表没有找到</span></span><br></pre></td></tr></table></figure></li><li><h4 id="Path数组"><a href="#Path数组" class="headerlink" title="Path数组"></a>Path数组</h4><p>Path来记录到达每一个对应的顶点的上一个前驱结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MVNum];<span class="comment">//存储最短路径的下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MVNum];<span class="comment">//存储各点的最小路径的权值和</span></span><br></pre></td></tr></table></figure></li><li><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>记住更新判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.vexnum; v++)</span><br><span class="line">&#123;</span><br><span class="line">min = INF;</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; C[w] &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">min = C[w];<span class="comment">//不用考略的原因在于final</span></span><br><span class="line">k = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span>[w] = <span class="number">1</span>;<span class="comment">//找到了就先标记一个然后开始更新检查</span></span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; min + G.arcs[k][w] &lt; C[w])</span><br><span class="line">&#123;</span><br><span class="line">P[w] = k;<span class="comment">// 保证了找到到每一个点的最短路径</span></span><br><span class="line">C[w] = min + G.arcs[k][w];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEDGE50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE100</span></span><br><span class="line"><span class="comment">// 迪杰斯特拉算法本质是一种贪心算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AMGraph</span></span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> vexnum;</span><br><span class="line"><span class="type">int</span> arcnum;</span><br><span class="line">VerTexType vertices[MVNum];</span><br><span class="line">ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MVNum];<span class="comment">//存储最短路径的下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MVNum];<span class="comment">//存储各点的最小路径的权值和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v0,Patharc P, ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> v, w, k, min;<span class="comment">//以前的一种习惯</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">final</span>[MVNum];<span class="comment">// 这个数组用来判断 一个点是否已经找到了最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">final</span>[i] = <span class="number">0</span>;<span class="comment">// 0代表没有找到</span></span><br><span class="line">P[i] = v0;<span class="comment">//假设每个都设为v0</span></span><br><span class="line">C[i] = G.arcs[v0][i];<span class="comment">//同理为到v0 的距离 第一次一定满足</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span>[v0] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//P[v0] = v0;  目前似乎可以不用</span></span><br><span class="line">C[v0] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.vexnum; v++)</span><br><span class="line">&#123;</span><br><span class="line">min = INF;</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; C[w] &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">min = C[w];<span class="comment">//不用考略的原因在于final</span></span><br><span class="line">k = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span>[w] = <span class="number">1</span>;<span class="comment">//找到了就先标记一个然后开始更新检查</span></span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; min + G.arcs[k][w] &lt; C[w])</span><br><span class="line">&#123;</span><br><span class="line">P[w] = k;<span class="comment">// 保证了找到到每一个点的最短路径</span></span><br><span class="line">C[w] = min + G.arcs[k][w];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>贪心思想，每次选择最优解，妙处在这个记录路径的数据结构，以及判断的选择，标记的思想。</p></blockquote><p><img src="/../images/to.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dijkstra算法&quot;&gt;&lt;a href=&quot;#Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra算法&quot;&gt;&lt;/a&gt;Dijkstra算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://spikeihg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal</title>
    <link href="https://spikeihg.github.io/2023/03/27/Kruskal/"/>
    <id>https://spikeihg.github.io/2023/03/27/Kruskal/</id>
    <published>2023-03-27T09:25:13.000Z</published>
    <updated>2023-03-27T13:09:35.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kruskal算法与并查集"><a href="#Kruskal算法与并查集" class="headerlink" title="Kruskal算法与并查集"></a>Kruskal算法与并查集</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ul><li><h4 id="以边入手"><a href="#以边入手" class="headerlink" title="以边入手"></a>以边入手</h4></li></ul><p>从边入手，将边按照权递增排序，所以我们需要使用边集数组。</p><ul><li><h4 id="并查集判断"><a href="#并查集判断" class="headerlink" title="并查集判断"></a>并查集判断</h4>由于使用了边，但是我们要判断是否会形成回路。所以使用查集。</li></ul><h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><ul><li><h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> begin, end;</span><br><span class="line">ArcType weight;<span class="comment">// ? the begin mean the point of the arcs</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且我们也要用到并查集的知识 感觉非常巧妙</span></span><br><span class="line"><span class="comment">//算法的是现实思想 这个就是使用的边集数组 对应的特有的数据结构</span></span><br></pre></td></tr></table></figure></li><li><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/先理解我们并查集的思想吧</span><br><span class="line"><span class="comment">// 实现所需要具有的数据结构 一个整数数组 两个函数 find and join</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N&#123; <span class="number">1000</span> &#125;;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">int</span> Rank[N];<span class="comment">// find 函数优化时所需要使用的一个标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pre[i] = i;<span class="comment">// 起始的时候全部为自己代表自己全部时分开的</span></span><br><span class="line">Rank[i] = <span class="number">1</span>;<span class="comment">// 深度全是10 也可以</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 查找 x 的根结点 还是一个树形结构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == pre[x])</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pro</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 查找的时候顺便完成一个路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x == pre[x])</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> pre[x] = <span class="built_in">find_pro</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 因为是一个尾递归所以可以写成以一个循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x != pre[x])</span><br><span class="line">x = pre[x];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;<span class="comment">// 我们使用的 </span></span><br><span class="line"><span class="comment">// 并查集 还有一个方法就是 并join()</span></span><br><span class="line"><span class="comment">// pro的非递归写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pro_</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="type">int</span> r = x;</span><br><span class="line"><span class="keyword">while</span> (pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (x != r)</span><br><span class="line">&#123;</span><br><span class="line">temp = pre[x];</span><br><span class="line">pre[x] = r;</span><br><span class="line">x = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issame</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);<span class="comment">// 优雅</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span> (x == y)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Rank[x] &lt; Rank[y])</span><br><span class="line">pre[x] = y;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Rank[x] == Rank[y])</span><br><span class="line">Rank[x]++;</span><br><span class="line">pre[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OKay so far 我们写我们要使用的函数 Find</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span>* parent, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (parent[f]&gt;<span class="number">0</span>)</span><br><span class="line">f = parent[f];</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序的时候可以用 qsort 也可以自己写</span></span><br></pre></td></tr></table></figure></li></ul><p>思路整理 ，首先运用一个整数数组来存每个元素的前驱，然后设定一个代表元，通过不断向上访问得到代表元。所以并查集本质任然是一个树形结构，研究连通的关系。</p><ul><li><h4 id="将邻接矩阵转换为一个边集数组"><a href="#将邻接矩阵转换为一个边集数组" class="headerlink" title="将邻接矩阵转换为一个边集数组"></a>将邻接矩阵转换为一个边集数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">edgecpy</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, Edge* e)</span><span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vertexnum<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;G.vertexnum;j++)</span><br><span class="line"><span class="keyword">if</span> (G.arcs[i][j] &lt; INF)</span><br><span class="line">&#123;</span><br><span class="line">e[k].begin = i;</span><br><span class="line">e[k].end = j;</span><br><span class="line">e[k].weight = G.arcs[i][j];</span><br><span class="line">++k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>然后我们基本就得到了全部了</p><p>附上完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status  <span class="title">cmp_</span><span class="params">(<span class="type">void</span> <span class="type">const</span>* e1, <span class="type">void</span> <span class="type">const</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (((Edge*)e1)-&gt;weight &gt; ((Edge*)e2)-&gt;weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MST_Kruskal</span><span class="params">(<span class="type">const</span> AMGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Edge* edges = <span class="keyword">new</span> Edge[MVNum];<span class="comment">//创建一个边集数组</span></span><br><span class="line"><span class="type">int</span>* parent = <span class="keyword">new</span> <span class="type">int</span>[G.vertexnum];</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> min_casts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(parent, <span class="number">0</span>, <span class="built_in">sizeof</span>(parent));</span><br><span class="line"><span class="built_in">edgecpy</span>(G, edges);</span><br><span class="line"><span class="built_in">qsort</span>(edges,G.arcnum, <span class="built_in">sizeof</span>(Edge), cmp_);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.arcnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">m = <span class="built_in">Find</span>(parent, edges[i].begin);</span><br><span class="line">n = <span class="built_in">Find</span>(parent, edges[i].end);</span><br><span class="line"><span class="keyword">if</span> (m != n)</span><br><span class="line">&#123;</span><br><span class="line">parent[m] = n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; edges[i].begin &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; edges[i].end &lt;&lt; <span class="string">&quot; )\n&quot;</span>;</span><br><span class="line">min_casts += edges[i].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>从边出发，并查集的思想很重要</p></blockquote><p><img src="/../images/tian.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kruskal算法与并查集&quot;&gt;&lt;a href=&quot;#Kruskal算法与并查集&quot; class=&quot;headerlink&quot; title=&quot;Kruskal算法与并查集&quot;&gt;&lt;/a&gt;Kruskal算法与并查集&lt;/h2&gt;&lt;h3 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot;</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://spikeihg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建指南</title>
    <link href="https://spikeihg.github.io/2023/03/25/hexo%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <id>https://spikeihg.github.io/2023/03/25/hexo%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</id>
    <published>2023-03-25T13:50:19.000Z</published>
    <updated>2023-03-25T15:10:39.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零基础搭建静态网页（基于hexo与github-page"><a href="#零基础搭建静态网页（基于hexo与github-page" class="headerlink" title="零基础搭建静态网页（基于hexo与github page)"></a>零基础搭建静态网页（基于hexo与github page)</h2><h3 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h3><p>在网络发达的时代，如果吗想要拥有你自己的空间，同时又烦恼于腾讯qq空间的多种限制，何不自己动手，搭建属于自己的网页，这里，我将简单提供几个博客，和网站就hexo搭建网页（静态网页）作一个介绍</p><h3 id="你所要会的"><a href="#你所要会的" class="headerlink" title="你所要会的"></a>你所要会的</h3><p><font color=red>几乎是零基础，唯一需要的就是一个代理，如果你没有，实在找不到，我可以分享给你，虽然需要十元钱，但是它有个bug</font></p><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p>我这里就先后顺序给出网址，并作简要说明；</p><blockquote><p>可以同时看一下我下面的问题解决，如果你在操作中出现问题的话，如果实在无法解决，可以评论。</p></blockquote><ul><li><h4 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a><a href="https://zhuanlan.zhihu.com/p/370635512"><font color= seablue>总体流程</font></a></h4></li></ul><p>其实这一个基本就可以完成搭建了，不过这里补充几个可能用到 的</p><ul><li><h4 id="模板来源"><a href="#模板来源" class="headerlink" title="模板来源"></a><a href="https://hexo.io/"><font color=seablue>模板来源</font></a></h4></li><li><h4 id="博客中的TAG使用"><a href="#博客中的TAG使用" class="headerlink" title="博客中的TAG使用"></a><a href="https://zhuanlan.zhihu.com/p/348131730"><font color= seablue>博客中的TAG使用</font></a></h4></li></ul><p>对于有tag和categories的网页的用法介绍</p><ul><li><h4 id="在线音乐获取"><a href="#在线音乐获取" class="headerlink" title="在线音乐获取"></a>在线音乐获取</h4><p>——<strong>暂时等待</strong> <font color=gold>我正打算写一个可以直接下载英语的web，由于要用django，可能比较久，如果不成功，我尽量提供一个源代码，到时候，大家只要可以运行应该就可以输入获取。</font></p></li><li><h4 id="一个找高清图片的网站"><a href="#一个找高清图片的网站" class="headerlink" title="一个找高清图片的网站"></a><a href="https://wallhaven.cc/"><font color= seablue>一个找高清图片的网站</font></a></h4></li><li><h4 id="CSS资源网站"><a href="#CSS资源网站" class="headerlink" title="CSS资源网站"></a><a href="https://www.w3cschool.cn/css3/css3-animation.html"><font color= seablue>CSS资源网站</font></a></h4><p>这个网站属于大家如果有自己改写代码的需要，可以参考，当然我自己不甚了解CSS和js</p></li><li><h4 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a><font color= seablue>markdown</font></h4><p>至于mark逗我呢使用方法可以参考我列举的一些关于markdown的用法。更完整的就是<a href="https://www.markdownguide.org/"><font color=seablue>Markdown官方文档</font></a></p></li></ul><p>推荐几个颜色 <font color=aqua>Aqua</font>  <font color=seablue>seablue</font>  <font color=chocolate>Chocolate</font>  <font color=azure>Azure</font></p><ul><li><h4 id="如果真的很感兴趣可以考虑学习JS"><a href="#如果真的很感兴趣可以考虑学习JS" class="headerlink" title="如果真的很感兴趣可以考虑学习JS"></a>如果真的很感兴趣可以考虑学习JS</h4></li></ul><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>列举一些我在操作中遇到的问题</p><ul><li><h4 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h4><p>注意命名时，必须是自己的用户名.io 这是github的要求</p></li><li><h4 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h4><p>尽量直接hexo new “标题”</p></li><li><h4 id="具体搭建指南"><a href="#具体搭建指南" class="headerlink" title="具体搭建指南"></a>具体搭建指南</h4><p>基本每一个框架都有说明，一般在对应的github仓库的README.md文件中</p></li><li><h4 id="获取网络图片"><a href="#获取网络图片" class="headerlink" title="获取网络图片"></a>获取网络图片</h4><p>先记录一下一个找图片地址的好地方 进入NASA官网直接copy image address 也可以在google里面使用 但是可能无法成功</p></li></ul><h2 id="Continuing"><a href="#Continuing" class="headerlink" title="Continuing"></a>Continuing</h2><p>暂时就写到这吧，欢迎交流，多请批评指教！</p><p><img src="/../images/lic.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;零基础搭建静态网页（基于hexo与github-page&quot;&gt;&lt;a href=&quot;#零基础搭建静态网页（基于hexo与github-page&quot; class=&quot;headerlink&quot; title=&quot;零基础搭建静态网页（基于hexo与github page)&quot;&gt;&lt;/a&gt;零</summary>
      
    
    
    
    
    <category term="Elements" scheme="https://spikeihg.github.io/tags/Elements/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://spikeihg.github.io/2023/03/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://spikeihg.github.io/2023/03/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2023-03-25T12:37:20.000Z</published>
    <updated>2023-10-05T16:04:54.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li><p><font color =chocolate>从前我们学习了KMP算法文本匹配，但是现在我们的这个正则表达式，提供一种单独的语法解决，但是KMP算法仍有很多局限且消耗算力，为了解决网络中的大量匹配问题，引入伟大的正则表达式，用于匹配与替换。</font></p></li><li><p><font color=blue violet>编程语言中我们使用的转义字符等有一定出处，正则表达式最初来自我们的unix机器</font> </p></li><li><h3 id="简单的语法"><a href="#简单的语法" class="headerlink" title="简单的语法"></a>简单的语法</h3><ul><li><h4 id="纯文本匹配"><a href="#纯文本匹配" class="headerlink" title="纯文本匹配"></a>纯文本匹配</h4><p>直接匹配文本，区分大小写，通常只返回第一个，可以编程语言中选择返回所有的数组。 </p></li><li><h4 id="号-匹配"><a href="#号-匹配" class="headerlink" title="**.号**匹配"></a>**<font color=red>.号</font>**匹配</h4><p>. 可以指代包括.在内的所有符号  匹配本身时引入了伟大的<em><strong>转义符号 \</strong></em>  </p></li><li><h4 id="匹配想要中的字符"><a href="#匹配想要中的字符" class="headerlink" title="匹配想要中的字符"></a>匹配想要中的字符</h4><p><font color = coral>使用[]，[]中的只要满足一个就算是匹配</font> 常常用在不区分大小写的表示  [Cc][Aa][Tt].eg事实上我们的markdown都有转义字符</p><ul><li><h5 id="集合表示"><a href="#集合表示" class="headerlink" title="集合表示"></a>集合表示</h5><blockquote><p>一个自然的过渡，如果，集合中元素很多时，且连续，使用[A-Z] 遵循阿斯克码</p></blockquote></li><li><p><font color=seagreen>\ 与-都是元字符 -不需转义</font></p></li><li><h5 id="多个集合匹配"><a href="#多个集合匹配" class="headerlink" title="多个集合匹配"></a>多个集合匹配</h5><blockquote><p>举个例子[A-Za-z0-9]就是有三个集合 网页的十六进制颜色表示就是一种应用 [0-9A-Fa-f]</p></blockquote></li></ul></li><li><h4 id="取非匹配"><a href="#取非匹配" class="headerlink" title="取非匹配"></a>取非匹配</h4><ul><li>使用元字符^ 且作用于集合 注意是在集合的内部 求非 代表一个[^]因为具有多义性</li></ul></li><li><h4 id="元字符匹配"><a href="#元字符匹配" class="headerlink" title="元字符匹配"></a>元字符匹配</h4><ul><li><p>使用转义字符匹配 </p></li><li><p>[] - ^ \ . +</p></li><li><h6 id="特殊的元字符"><a href="#特殊的元字符" class="headerlink" title="特殊的元字符"></a>特殊的元字符</h6><ul><li>\f 换页符 \n换行符 \r回车符 \t制表符 \v垂直制表符 [\b]backspace</li><li>举个例子 处理 CSV文件 , 变成空格</li><li>windows 中 \r\n 表示换行 linux  \r可选 \n 必选</li></ul></li><li><h6 id="对集合的简化"><a href="#对集合的简化" class="headerlink" title="对集合的简化"></a>对集合的简化</h6><ul><li>\d 所有的数字&#x3D;[0-9] \D&#x3D;[^0-9]</li><li>\w 所有字母大小写与数字 \W 所有的非</li><li>\s 任何一个空字符 \f\n\r\v\t  \S </li><li>十六进制与八进制 \0x \0  \c 控制字符</li><li>POSIX字符的支持 格式[: 英文描述:]</li></ul></li><li><h6 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h6><ul><li>元字符 [0-9]+ 0-9中的数字的一个以上 不能0个</li><li>举个例子 关于邮箱地址的匹配 <ul><li>\w@\w\.\w 升级</li><li>\w+@\w+\.\w+</li><li>升级\[\w.]+@\[\w\.]+\.[\w.]+ 注意这个例子可以看出我们的在[]里所有的元字符都可以看作是普通字符 但是转义了也没有错误</li></ul></li></ul></li></ul></li><li><h4 id="元字符"><a href="#元字符" class="headerlink" title="*元字符"></a>*元字符</h4><ul><li>可以匹配0次与任意次 相当于 + 的升级版</li><li>\w+[\w.]*@[\w.]+\.\w+  可以把* 看作可选项  实质理解</li></ul></li><li><h4 id="？元字符"><a href="#？元字符" class="headerlink" title="？元字符"></a>？元字符</h4><ul><li>匹配一次或零次 http:&#x2F;&#x2F; 与 https:&#x2F;&#x2F; 不能用s*  httpsss 所以使用？</li><li>[\r]? 与我们的\r? 本质是一样的 但是为了清晰直观 我们通常直接[\r]</li></ul></li><li><h4 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h4><ul><li>{}也是元字符 举个例子就是之前的RGB #[0-9A-Fa-f]写六遍可以使用{6}</li><li>也可以设置一个区间{2.4}</li><li>[]中间是的元字符都是为普通字符，最好写一个\</li><li>匹配至少多少次 {3,}类似python</li></ul></li><li><h4 id="防止过度匹配"><a href="#防止过度匹配" class="headerlink" title="防止过度匹配"></a>防止过度匹配</h4><ul><li><p>使用懒惰版本，进行匹配，前面的匹配都是一个贪婪匹配，例如 * + {n，}   对应的懒惰版本就是加上一个? 例如 * 与 *？ 还有 + +? {n,} {n,}?</p><p>这里的懒惰可以理解成就是 尽量的再匹配到第一个的时候就停下来 ，而贪婪就是匹配到最后一个再停下来</p></li></ul></li><li><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><ul><li>指定匹配发生的位置</li><li>\b  一个标记，用来标记一个单词的开头或者是结尾  理解\b 的实质，实质就是匹配一个可以\w 与一个非字母或者是数字的位置\W 之间的一个位置  b代表boundary 注意我们的这个 \b 只是匹配一个位置 ，而不是匹配一个字符  所以 \bcat\b 得到的字符 还是 3个字符 而非5个</li><li>同理 的 \B 来匹配一个你想要的边界 就是 eg night-color  \B-\B 可以匹配 但是我们的 color - color 就是无法匹配</li><li>^ 这里来再次出现 用作 标记字符串的开始位置 $ 用于标记字符串的结尾</li><li>举个例子 匹配一个 XML 文件  因为必须要求 这个声明位于一个文档的最开始 所以我们需要进行 字符串的一个声明 例如 这个 ^\s*&lt;?xml.*?&gt;</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;font color =chocolate&gt;从前我们学习了KMP算法文本匹配，但是现在我们的这个正则表达式，提供一种单独</summary>
      
    
    
    
    
    <category term="SCRAPE" scheme="https://spikeihg.github.io/tags/SCRAPE/"/>
    
  </entry>
  
  <entry>
    <title>Prim</title>
    <link href="https://spikeihg.github.io/2023/03/24/Prim/"/>
    <id>https://spikeihg.github.io/2023/03/24/Prim/</id>
    <published>2023-03-24T11:47:09.000Z</published>
    <updated>2023-03-25T12:04:40.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><font color=Aqua>加入你遇到这样一个问题，在一个表示了很多村庄的交通图中，其中有每两个村庄之间的交通开销。我们怎么才能够将所有的村庄都相连，并且没有回路，即离散数学里的极小连通图。我们的Prim算法给出了一种经典的解决方法。</font></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="数学抽象"><a href="#数学抽象" class="headerlink" title="数学抽象"></a>数学抽象</h3><p>我们运用离散数学中的图来简化模型，将村庄视作点，边视作连线，然后赋予对应的一个权值。</p><h3 id="关键思路分析"><a href="#关键思路分析" class="headerlink" title="关键思路分析"></a>关键思路分析</h3><ul><li><h4 id="以点为中心"><a href="#以点为中心" class="headerlink" title="以点为中心"></a>以点为中心</h4><p>因为最终生成的路径一定要包含所有的顶点，所以我们可以从点的角度考虑。任取一个点，找到与其邻接的所有顶点，然后找到最小的权值对应的顶点，把该点放入我们的点集合里，然后然后重复上面的步骤就可以了。</p></li><li><h4 id="更新权值"><a href="#更新权值" class="headerlink" title="更新权值"></a>更新权值</h4><p>一个比较关键的地方就是要不断检查权值，然后对应进行更新。</p><blockquote><p>其实思路总体还是比较清晰，简单，不过在代码里面有很多巧妙的地方</p></blockquote></li></ul><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><ul><li><h4 id="如何存储点的信息"><a href="#如何存储点的信息" class="headerlink" title="如何存储点的信息"></a>如何存储点的信息</h4><p>我们定义一个Prim特有的数据结构来进行存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个就是Prim算法的特殊数据结构，就是你使用这个算法就必须要想起的一个结构</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// ADT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">closeedge</span> &#123;</span><br><span class="line"><span class="type">int</span> adjvex;</span><br><span class="line"><span class="type">int</span> lowcast;<span class="comment">//?  low cast </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路很妙，lowcast记录该点的最小开销，而adjvex对应最小开销的对应的边。不过我们还有一个问题，那就是我们会发现，怎么检查一个点是否已经在我们的已经考虑过的集合里，然后又怎么决定两条边是否相连，我们分别对下面 的问题进行解决。   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum100</span></span><br><span class="line"><span class="comment">// ? love favorite </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">VerTexType vertices[MVNum];</span><br><span class="line">ArcType arcs[MVNum][MVNum];</span><br><span class="line"><span class="type">int</span> vertexnum&#123;MVNum&#125;;</span><br><span class="line"><span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;<span class="comment">//? Low cost</span></span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure><p>我们使用边集数组的数据结构来表示，（这就是数据结构的魅力），然后我们在初始化的时候将对角线初始化为0，以lowcast&#x3D;0来代表不能建路径，以INF一个极大值来检查是否连通。这就是算法中的关键思路</p></li><li><h4 id="判断条件（如上）"><a href="#判断条件（如上）" class="headerlink" title="判断条件（如上）"></a>判断条件（如上）</h4></li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   MTS.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  3/24/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// Now we come to the MTS</span></span><br><span class="line"><span class="comment">//? Most Cost Spannig Tree </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum100</span></span><br><span class="line"><span class="comment">// ? love favorite </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">VerTexType vertices[MVNum];</span><br><span class="line">ArcType arcs[MVNum][MVNum];</span><br><span class="line"><span class="type">int</span> vertexnum&#123;MVNum&#125;;</span><br><span class="line"><span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;<span class="comment">//? Low cost</span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">locate</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (v == G.vertices[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(G.arcs, INF, <span class="built_in">sizeof</span>(G.arcs));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">G.arcs[i][i] = <span class="number">0</span>;<span class="comment">// It must been done !</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first please input the arcnum and vernum of the graph&quot;</span>;</span><br><span class="line">cin &gt;&gt; G.vertexnum &gt;&gt; G.arcnum;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now please enter the vertices first&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">cin &gt;&gt; G.vertices[i];</span><br><span class="line">VerTexType v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">ArcType weight&#123; <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">int</span> i&#123; <span class="number">0</span> &#125;, j&#123; <span class="number">0</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now please enter all the arcs and weight&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.arcnum; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;</span><br><span class="line">i = <span class="built_in">locate</span>(G, v1);</span><br><span class="line">j = <span class="built_in">locate</span>(G, v2);</span><br><span class="line">G.arcs[i][j] = weight;<span class="comment">// UDN</span></span><br><span class="line">G.arcs[j][i] = weight;<span class="comment">// UDN</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是Prim算法的特殊数据结构，就是你使用这个算法就必须要想起的一个结构</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// ADT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">closeedge</span> &#123;</span><br><span class="line"><span class="type">int</span> adjvex;</span><br><span class="line"><span class="type">int</span> lowcast;<span class="comment">//?  low cast </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键思路的分析 ，就是把点作为一个集合，从所有与这个集合相连的点中挑选</span></span><br><span class="line"><span class="comment">// 运用一个数组存储对应的顶点的最小开销，与此同时，再使用一个数组来记录对应的边的</span></span><br><span class="line"><span class="comment">// 另一个顶点 然后 为了判定一个点是否已经在集合内，我们将其cast 设置为0</span></span><br><span class="line"><span class="comment">// 并且最开始的时候我们的矩阵里使用的是一个INF 数据设计很巧妙</span></span><br><span class="line"><span class="comment">// The prim from a blogger </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(AMGraph&amp; G, <span class="type">int</span> v)</span><span class="comment">//? We choose a start point v0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// First we use the closeedge</span></span><br><span class="line">closeedge C[MVNum];<span class="comment">// Special data struct</span></span><br><span class="line"><span class="comment">// Init it with the v point</span></span><br><span class="line"><span class="type">int</span> min_casts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">C[i].adjvex = v;</span><br><span class="line">C[i].lowcast = G.arcs[v][i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对应的边是&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G.vertexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> min_cast = INF;<span class="comment">// Just the case</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vertexnum; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (C[j].lowcast != <span class="number">0</span> &amp;&amp; C[j].lowcast &lt; min_cast)</span><br><span class="line">&#123;</span><br><span class="line">temp = j;</span><br><span class="line">min_cast = C[j].lowcast;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; ( &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; C[temp].adjvex &lt;&lt; <span class="string">&quot; )&quot;</span>;</span><br><span class="line">min_casts += min_cast;</span><br><span class="line">C[temp].lowcast = <span class="number">0</span>;<span class="comment">// You&#x27;ve seen what the use just to see if used!!!</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.vertexnum; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (C[k].lowcast != <span class="number">0</span> &amp;&amp; G.arcs[temp][k] &lt; C[k].lowcast)</span><br><span class="line">&#123;</span><br><span class="line">C[k].lowcast = G.arcs[temp][k];</span><br><span class="line">C[k].adjvex = k;<span class="comment">// Now you see what the adjvex mean</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;All casts are &quot;</span> &lt;&lt; min_casts &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we could see the o(n^2)</span></span><br><span class="line"><span class="comment">// We could also use the KrustalAL other method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//? Krustal 算法的实现</span></span><br><span class="line"><span class="comment">// 对应的我们KRUSTAL 算法也有对应的特有的数据结构 就是我们的边集数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> begin, end;</span><br><span class="line">ArcType weight;<span class="comment">// ? the begin mean the point of the arcs</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且我们也要用到并查集的知识 感觉非常巧妙</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><font color=coral>之前很少细想算法设计的思路，自己的思维没有得到锻炼，其中的数学简化思想与代码设计很巧妙与优美，完</font></p><p><img src="/../images/Rei.jpg" alt="hh" title="绫波"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;&lt;font color=Aqua&gt;加入你遇到这样一个问题，在一个表示了很多村庄的交通图中，其中有每两个村庄之间的交通开销。我</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://spikeihg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础汇编指令</title>
    <link href="https://spikeihg.github.io/2023/03/23/%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    <id>https://spikeihg.github.io/2023/03/23/%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</id>
    <published>2023-03-23T15:18:23.000Z</published>
    <updated>2023-03-25T12:27:41.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h3><ul><li><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>一个标准的c语言程序在编译过程中，首先是经过翻译，成汇编语言，也就是Linux命令行中的-s选项，然后转为二进制的机器代码，然后通过连接器，与库相连，并且附上一些地址与起始终止信息。</p></li><li><h4 id="汇编语言与机器代码"><a href="#汇编语言与机器代码" class="headerlink" title="汇编语言与机器代码"></a>汇编语言与机器代码</h4><p>机器是二进制字节，电脑可读的指令，汇编语言就是助记符。可以编写</p></li><li><h4 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h4><p>不同机器，处理器的指令集架构不一样，但是高级抽象语言却能够通用，只要选用适合机器的编译器即可。</p></li><li><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4><p>因为英特尔前期处理器都是某某86所以简称x86，x86-64即64位拓展</p></li><li><h4 id="O优化"><a href="#O优化" class="headerlink" title="O优化"></a>O优化</h4><p>其实就是命令行的一个选型，高度优化可能使代码的汇编代码逻辑改变较大。</p></li><li><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li><h5 id="程序寄存器"><a href="#程序寄存器" class="headerlink" title="程序寄存器"></a>程序寄存器</h5><p>用于专门存储指令的地址 %rip</p></li><li><h5 id="一组十六个整数寄存器"><a href="#一组十六个整数寄存器" class="headerlink" title="一组十六个整数寄存器"></a>一组十六个整数寄存器</h5><p>用于系列操作</p></li><li><h5 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h5><p>存储维护条件码实现逻辑控制</p></li><li><h5 id="向量寄存器"><a href="#向量寄存器" class="headerlink" title="向量寄存器"></a>向量寄存器</h5><p>实现浮点数操作</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;概念补充&quot;&gt;&lt;a href=&quot;#概念补充&quot; class=&quot;headerlink&quot; title=&quot;概念补充&quot;&gt;&lt;/a&gt;概念补充&lt;/h</summary>
      
    
    
    
    
    <category term="“CSAPP”" scheme="https://spikeihg.github.io/tags/%E2%80%9CCSAPP%E2%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>DNS</title>
    <link href="https://spikeihg.github.io/2023/03/23/DNS/"/>
    <id>https://spikeihg.github.io/2023/03/23/DNS/</id>
    <published>2023-03-23T12:24:54.000Z</published>
    <updated>2023-03-23T13:25:01.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul><li><h3 id="DNS-Domain-name-system"><a href="#DNS-Domain-name-system" class="headerlink" title="DNS(Domain name system)"></a>DNS(Domain name system)</h3><ul><li><p>是DNS服务器实现的一个分布式数据库，同时也算是一个应用层协议运行在unix机器之上，端口号为53</p></li><li><p>http、smtp、ftp都是用了DNS将主机名转化为IP地址</p></li><li><p>原理如下</p><p>1） 同一台用户主机上运行着DNS应用的客户端。</p><p>2） 浏览器从上述URL中抽取岀主机名<a href="http://www.baidu.com,并将这台主机名传给dns应用的客户端./">www.baidu.com,并将这台主机名传给DNS应用的客户端。</a></p><p>3） DNS客户向DNS服务器发送一个包含主机名的请求。</p><p>4） DNS客户最终会收到一份回答报文，其中含有对应于该主机名的IP地址。</p><p>5） 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。</p></li><li><p>规范主机名与主机别名，邮件系统别名联想自己的学校邮箱</p></li></ul></li><li><h3 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h3><ul><li><p>主机例如web应用需要将主机名转换为IP地址时，调用DNS客户端，指明主机名，底层的unix实现是调用一个函数gethostbtname（）</p></li><li><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><h5 id="分布式，层次"><a href="#分布式，层次" class="headerlink" title="分布式，层次"></a>分布式，层次</h5><p>根，顶级域(TLD，top-level domain),权威，三层。举个例子</p><p><img src="/../images/DNS%E5%B1%82%E6%AC%A1.png" alt="DNS层次"></p><p>国家，fr,jp,ca,也是自己国家维护的顶级域 权威顶级域就是因特网上能够被公共访问的服务器主机需要提供的一个可公共访问的DNS记录，例如大学，自己维护的DNS服务器</p></li><li><h5 id="本地DNS服务器与缓存"><a href="#本地DNS服务器与缓存" class="headerlink" title="本地DNS服务器与缓存"></a>本地DNS服务器与缓存</h5><p>通过本地公用来减少流量，缓存可以减少路径，尽量绕过根DNS</p></li></ul></li><li><h4 id="DNS记录与报文"><a href="#DNS记录与报文" class="headerlink" title="DNS记录与报文"></a>DNS记录与报文</h4><ul><li><h5 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h5></li></ul><p>DNS服务器中提供了资源记录，包含四元组(Name, Value，Type，TTL) </p><p>如果Type &#x3D; A,则Name是主机名，Value是该主机名对应的IP地址。因此，一条类型为A的资源记录提供了标准的主机名到IP地址的映射。例如(Tayl.bar. foo. com, 145. 37.93. 126, A)就是一条类型 A 记录。</p><p>如果Type &#x3D; NS,则Name是个域(如foo. com),而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。例如(fgcom, cins.foo.com, NS)就是一条类型为NS的记录。</p><p>如果Type&#x3D;CNAME，则 Value是别名为Name的主机对应的规范主机名。该记录能够向査询的主机提供一个主机名对应的规范主机名，例如(foo.com, relay1.bar. foo. com, CNAME)就是一条 CNAME 类型的记录。</p><p>如果Type &#x3D; MX,则Value是个别名为Name的邮件服务器的规范主机名。举例来说，(foo.com, mail. bar. fo&lt;). com, MX)就是一条MX记录。MX记录允许邮件服务器主机名具有简单的别名。值得注意的是，通过使用MX记录，一个公司的邮件服务器和其他服务器(如它的Web服务器)可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录</p><ul><li><h5 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h5><img src="/../images/DNS%E6%8A%A5%E6%96%87.png" alt="DNS报文" title="DNS报文"></li></ul><p>控制台键入nslookup 即可看权威DNS服务器与地址 dns.hust.edu.cn</p></li></ul></li></ul><h2 id="P2P与BitTorrent"><a href="#P2P与BitTorrent" class="headerlink" title="P2P与BitTorrent"></a>P2P与BitTorrent</h2><p>​之前都是采用客户-服务器体系结构，依赖于服务器，P2P则是最小或是没有依赖。成对间歇连接的主机直接相连，对等方。最广泛的是BitTorrent协议</p><ul><li><h3 id="P2P体系结构的拓展性"><a href="#P2P体系结构的拓展性" class="headerlink" title="P2P体系结构的拓展性"></a>P2P体系结构的拓展性</h3><p>在用户接受到后能够使用自己的能力进行一个上传。</p></li><li><h3 id="BitTorrent-协议"><a href="#BitTorrent-协议" class="headerlink" title="BitTorrent 协议"></a>BitTorrent 协议</h3><p>洪流，主机集合，可以一起向其他主机传输，用追踪器实现。传送时，遵循一定的最有算法。</p></li></ul><h2 id="视频流"><a href="#视频流" class="headerlink" title="视频流"></a>视频流</h2><ul><li><h3 id="http流与DASH"><a href="#http流与DASH" class="headerlink" title="http流与DASH"></a>http流与DASH</h3><p>http流中的视频就是一个普通的http下的文件具有一个url。初期，由于具有统一格式，提供单一视频的性质，现在，为经HTTP的动态适应性流(Dynamic AdaptiveStreaming over HTTP, DASH) ，编码不同版本，不同画质。</p><ul><li><h4 id="内容发布网"><a href="#内容发布网" class="headerlink" title="内容发布网"></a>内容发布网</h4>CDN，在传统的DNS访问中，最后得到的是一个CDN内容服务器IP地址，然后再CDN中处理</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;DNS-Domain-name-system&quot;&gt;&lt;a href=&quot;#DNS-Domain-name-sy</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://spikeihg.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>BFS&amp;DFS</title>
    <link href="https://spikeihg.github.io/2023/03/23/BFS-DFS/"/>
    <id>https://spikeihg.github.io/2023/03/23/BFS-DFS/</id>
    <published>2023-03-23T08:01:45.000Z</published>
    <updated>2023-03-23T08:53:24.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单总结一下BFS与DFS在图中的实现"><a href="#简单总结一下BFS与DFS在图中的实现" class="headerlink" title="简单总结一下BFS与DFS在图中的实现"></a>简单总结一下BFS与DFS在图中的实现</h2><ul><li><h3 id="BFS-amp-DFS-in-C"><a href="#BFS-amp-DFS-in-C" class="headerlink" title="BFS&amp;DFS in C++"></a><strong>BFS&amp;DFS in C++</strong></h3>  <font color=aqua><em><strong>由于对class不熟，没有写成类，但是单独写了头文件，作为一个标准例子吧</strong></em></font><h4 id="这是头文件"><a href="#这是头文件" class="headerlink" title="这是头文件"></a>这是头文件</h4>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   BFS.hpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter </span></span><br><span class="line"><span class="comment"> *  To demonstrate the BFS and DFS in graph </span></span><br><span class="line"><span class="comment"> * as well as wellas review the queue and graph</span></span><br><span class="line"><span class="comment"> * \author Winter</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once<span class="comment">/* Two lines just in case */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BFS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum50<span class="comment">// Maximum number of vertices</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE100</span></span><br><span class="line"><span class="comment">//ADT</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> Len = <span class="type">int</span>;<span class="comment">//C++ version</span></span><br><span class="line"><span class="comment">// ALGraph</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> OtherInfo;<span class="comment">//Maybe the weight</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">anode</span> &#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//the index of this node</span></span><br><span class="line">OtherInfo info;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">anode</span>* next;</span><br><span class="line">&#125;Arcnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span> &#123;</span><br><span class="line">VertexType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arcnode</span>* firstarc;</span><br><span class="line"><span class="comment">// struct Arcnode*antifirst;the out degree</span></span><br><span class="line">&#125;Vnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vnode AdjList[MVNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">AdjList vertices;</span><br><span class="line"><span class="type">int</span> vernum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AMGraph</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">VertexType vertices[MVNum];</span><br><span class="line">ArcType arcs[MVNum][MVNum];</span><br><span class="line"><span class="type">int</span> vernum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue the Squeue and list queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">ElemType* data;</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line">&#125;SQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">qnode</span> &#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qnode</span>* next;</span><br><span class="line">&#125;Qnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">Qnode* front;</span><br><span class="line">Qnode* rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the external value we will use in the main.cpp</span></span><br><span class="line">Arcnode* static_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">bool</span> visited[MVNum];<span class="comment">//BFS</span></span><br><span class="line"><span class="type">bool</span> Visited[MAXSIZE];<span class="comment">//DFS</span></span><br><span class="line"><span class="comment">//static funcion </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span><span class="title">FirstAdjVex</span><span class="params">(<span class="type">const</span> ALGraph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!static_)</span><br><span class="line">static_ = G.vertices[v].firstarc;</span><br><span class="line"><span class="keyword">return</span> G.vertices[v].firstarc-&gt;adjvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">NextAdjVex</span><span class="params">(<span class="type">const</span> ALGraph G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!static_)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">static_ = static_-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (static_)</span><br><span class="line"><span class="keyword">return</span> static_-&gt;adjvex;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Func</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_S</span><span class="params">(SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty_S</span><span class="params">(<span class="type">const</span> SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue_S</span><span class="params">(SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue_S</span><span class="params">(SQueue&amp; Q, ElemType add)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue_S</span><span class="params">(SQueue&amp; Q, ElemType&amp; del)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty</span><span class="params">(<span class="type">const</span> Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElemType add)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElemType&amp;del)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> ALGraph&amp; G, <span class="type">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="这是cpp文件"><a href="#这是cpp文件" class="headerlink" title="这是cpp文件"></a>这是cpp文件</h4>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   BFS.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  21/3/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// ?Here we come the BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BFS.hpp&quot;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_S</span><span class="params">(SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * MVNum);</span><br><span class="line"><span class="keyword">if</span> (!Q.data)</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue_S</span><span class="params">(SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(Q.data);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty_S</span><span class="params">(<span class="type">const</span> SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue_S</span><span class="params">(SQueue&amp;Q,ElemType add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MVNum == Q.front)</span><br><span class="line"><span class="keyword">return</span> BAD;</span><br><span class="line">Q.data[Q.rear] = add;</span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MVNum;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue_S</span><span class="params">(SQueue&amp; Q, <span class="type">int</span>&amp; del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> BAD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Qnode*pnew = (Qnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Qnode));</span><br><span class="line"><span class="keyword">if</span> (!pnew)</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">Q.front = Q.rear = pnew;</span><br><span class="line">Q.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty</span><span class="params">(<span class="type">const</span> Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.rear = Q.front;</span><br><span class="line"><span class="keyword">while</span> (Q.front)</span><br><span class="line">&#123;</span><br><span class="line">Q.rear = Q.front-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(Q.front);</span><br><span class="line">Q.front = Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElemType add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Qnode* pnew = (Qnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Qnode));</span><br><span class="line">pnew-&gt;data = add;</span><br><span class="line">pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">Q.rear-&gt;next = pnew;</span><br><span class="line">Q.rear = pnew;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElemType&amp; del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> BAD;</span><br><span class="line">Qnode* psave = Q.front-&gt;next;</span><br><span class="line">del = psave-&gt;data;</span><br><span class="line">Q.front-&gt;next = psave-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == psave)</span><br><span class="line">Q.rear = Q.front;</span><br><span class="line"><span class="built_in">free</span>(psave);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> ALGraph&amp; G, <span class="type">int</span> v)</span><span class="comment">//? v the start of the BFS</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue vessel;</span><br><span class="line"><span class="built_in">InitQueue</span>(vessel);</span><br><span class="line">cout &lt;&lt; G.vertices[v].data;</span><br><span class="line">visited[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">EnQueue</span>(vessel, v);</span><br><span class="line"><span class="type">int</span> u&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">QueueIsEmpty</span>(vessel))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DeQueue</span>(vessel, u);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstAdjVex</span>(G, u); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextAdjVex</span>(G, u, w))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line">&#123;</span><br><span class="line">visited[w] = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; G.vertices[w].data;</span><br><span class="line"><span class="built_in">EnQueue</span>(vessel, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= G.vernum)</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">cout &lt;&lt; G.vertices[v];</span><br><span class="line">Visited[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vernum; ++w)</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][w] &amp;&amp; !Visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inline int FirstAdjvex(const ALGraph&amp; G, int v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (!static_)</span></span><br><span class="line"><span class="comment">//static_ = G.vertices[v].firstarc;</span></span><br><span class="line"><span class="comment">//return G.vertices[v].firstarc-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//inline int NextAdjvex(const ALGraph&amp; G, int v, int u)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ArcNode* scan;</span></span><br><span class="line"><span class="comment">//for (scan = G.vertices[v].firstarc; scan-&gt;adjvex != u &amp;&amp; !scan-&gt;next; scan = scan-&gt;next)</span></span><br><span class="line"><span class="comment">//continue;</span></span><br><span class="line"><span class="comment">//if (u == scan-&gt;adjvex &amp;&amp; !scan-&gt;next)</span></span><br><span class="line"><span class="comment">//return scan-&gt;next-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//return -1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//// ?May I create the new writing</span></span><br><span class="line"><span class="comment">//inline int NextNeighbor(const ALGraph&amp; G,int v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (!static_||!static_-&gt;next)</span></span><br><span class="line"><span class="comment">//return -1;</span></span><br><span class="line"><span class="comment">//static_=static_-&gt;next;</span></span><br><span class="line"><span class="comment">//return static_-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Macro</span></span><br><span class="line"><span class="comment">//#define MVNum50</span></span><br><span class="line"><span class="comment">//#define OK1</span></span><br><span class="line"><span class="comment">//#define BAD0</span></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="comment">//using Status = int;</span></span><br><span class="line"><span class="comment">//using VertexType = char;</span></span><br><span class="line"><span class="comment">//using ArcType = int;</span></span><br><span class="line"><span class="comment">//using Len = int;</span></span><br><span class="line"><span class="comment">//// the adjency list</span></span><br><span class="line"><span class="comment">//typedef struct anode&#123;</span></span><br><span class="line"><span class="comment">//int adjvex;</span></span><br><span class="line"><span class="comment">//ArcType info;</span></span><br><span class="line"><span class="comment">//struct anode* next;</span></span><br><span class="line"><span class="comment">//&#125;ArcNode;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//typedef struct vnode &#123;</span></span><br><span class="line"><span class="comment">//VertexType data&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//ArcNode* firstarc;//?there we don&#x27;t care the out degree</span></span><br><span class="line"><span class="comment">//&#125;Vnode;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//typedef Vnode AdjList[MVNum];// ? Very special !!!</span></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//AdjList vertices;</span></span><br><span class="line"><span class="comment">//int vertexnum&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//int arcnum&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//&#125;ALGraph;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////? we just can handle the adjlist like list and insert </span></span><br><span class="line"><span class="comment">//// ? from the head of the list!!!</span></span><br><span class="line"><span class="comment">////we will use the queue</span></span><br><span class="line"><span class="comment">//typedef int ElemType;// just to store the index of the vex</span></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//ElemType* data;</span></span><br><span class="line"><span class="comment">//int front&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//int rear&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//&#125;SQueue;</span></span><br><span class="line"><span class="comment">//// the loop queue</span></span><br></pre></td></tr></table></figure></li><li><h3 id="BFS-in-Python"><a href="#BFS-in-Python" class="headerlink" title="BFS in Python"></a>BFS in Python</h3></li></ul><p><br> 然后写了一个在python中BFS实现 主要用python可以省略一些细节而着重于思想理解</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#BFS in python</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment"># double queue</span></span><br><span class="line">graph=&#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;you&quot;</span>] = [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;claire&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;bob&quot;</span>] = [<span class="string">&quot;anuj&quot;</span>, <span class="string">&quot;peggy&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;alice&quot;</span>] = [<span class="string">&quot;peggy&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;claire&quot;</span>] = [<span class="string">&quot;thom&quot;</span>, <span class="string">&quot;jonny&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;anuj&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;peggy&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;thom&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;jonny&quot;</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_is_seller</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name[-<span class="number">1</span>]==<span class="string">&#x27;m&#x27;</span>        <span class="comment">#just give an example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">graph,name</span>):       <span class="comment">#we start from this guy</span></span><br><span class="line">    search_queue=deque()</span><br><span class="line">    search_queue+=graph[name]</span><br><span class="line">    searched=[]</span><br><span class="line">    <span class="keyword">while</span> search_queue:     <span class="comment">#not null</span></span><br><span class="line">        person=search_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">                <span class="built_in">print</span>(person+<span class="string">&#x27; is a wolfman&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                search_queue+=graph[person]</span><br><span class="line">                search.append(person)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li><h2 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h2></li></ul><p><strong><font color=seagreen>BFS主要应用了队列的思想 DFS主要运用了递归的思想 最终图的表示使用了离散数学的邻接矩阵于邻接表  Done!</font></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单总结一下BFS与DFS在图中的实现&quot;&gt;&lt;a href=&quot;#简单总结一下BFS与DFS在图中的实现&quot; class=&quot;headerlink&quot; title=&quot;简单总结一下BFS与DFS在图中的实现&quot;&gt;&lt;/a&gt;简单总结一下BFS与DFS在图中的实现&lt;/h2&gt;&lt;ul&gt;
</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://spikeihg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
