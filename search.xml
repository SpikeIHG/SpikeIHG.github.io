<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kruskal</title>
    <url>/2023/03/27/Kruskal/</url>
    <content><![CDATA[<h2 id="Kruskal算法与并查集"><a href="#Kruskal算法与并查集" class="headerlink" title="Kruskal算法与并查集"></a>Kruskal算法与并查集</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ul>
<li><h4 id="以边入手"><a href="#以边入手" class="headerlink" title="以边入手"></a>以边入手</h4></li>
</ul>
<p>从边入手，将边按照权递增排序，所以我们需要使用边集数组。</p>
<ul>
<li><h4 id="并查集判断"><a href="#并查集判断" class="headerlink" title="并查集判断"></a>并查集判断</h4>由于使用了边，但是我们要判断是否会形成回路。所以使用查集。</li>
</ul>
<h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><ul>
<li><h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> begin, end;</span><br><span class="line">	ArcType weight;		<span class="comment">// ? the begin mean the point of the arcs</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且我们也要用到并查集的知识 感觉非常巧妙</span></span><br><span class="line"><span class="comment">//算法的是现实思想 这个就是使用的边集数组 对应的特有的数据结构</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/先理解我们并查集的思想吧</span><br><span class="line"><span class="comment">// 实现所需要具有的数据结构 一个整数数组 两个函数 find and join</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N&#123; <span class="number">1000</span> &#125;;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">int</span> Rank[N];		<span class="comment">// find 函数优化时所需要使用的一个标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pre[i] = i;		<span class="comment">// 起始的时候全部为自己代表自己全部时分开的</span></span><br><span class="line">		Rank[i] = <span class="number">1</span>;	<span class="comment">// 深度全是1	0 也可以</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>		<span class="comment">// 查找 x 的根结点 还是一个树形结构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == pre[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pro</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">// 查找的时候顺便完成一个路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x == pre[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> pre[x] = <span class="built_in">find_pro</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">// 因为是一个尾递归所以可以写成以一个循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x != pre[x])</span><br><span class="line">		x = pre[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;	<span class="comment">// 我们使用的 </span></span><br><span class="line"><span class="comment">// 并查集 还有一个方法就是 并join()</span></span><br><span class="line"><span class="comment">// pro的非递归写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pro_</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="type">int</span> r = x;</span><br><span class="line">	<span class="keyword">while</span> (pre[r] != r)</span><br><span class="line">	&#123;</span><br><span class="line">		r = pre[r];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (x != r)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = pre[x];</span><br><span class="line">		pre[x] = r;</span><br><span class="line">		x = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issame</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);		<span class="comment">// 优雅</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (Rank[x] &lt; Rank[y])</span><br><span class="line">		pre[x] = y;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Rank[x] == Rank[y])</span><br><span class="line">			Rank[x]++;</span><br><span class="line">		pre[y] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OKay so far 我们写我们要使用的函数 Find</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span>* parent, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (parent[f]&gt;<span class="number">0</span>)</span><br><span class="line">		f = parent[f];</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序的时候可以用 qsort 也可以自己写</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>思路整理 ，首先运用一个整数数组来存每个元素的前驱，然后设定一个代表元，通过不断向上访问得到代表元。所以并查集本质任然是一个树形结构，研究连通的关系。</p>
<ul>
<li><h4 id="将邻接矩阵转换为一个边集数组"><a href="#将邻接矩阵转换为一个边集数组" class="headerlink" title="将邻接矩阵转换为一个边集数组"></a>将邻接矩阵转换为一个边集数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">edgecpy</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, Edge* e)</span>	<span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vertexnum<span class="number">-1</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;G.vertexnum;j++)</span><br><span class="line">			<span class="keyword">if</span> (G.arcs[i][j] &lt; INF)</span><br><span class="line">			&#123;</span><br><span class="line">				e[k].begin = i;</span><br><span class="line">				e[k].end = j;</span><br><span class="line">				e[k].weight = G.arcs[i][j];</span><br><span class="line">				++k;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后我们基本就得到了全部了</p>
<p>附上完整代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status  <span class="title">cmp_</span><span class="params">(<span class="type">void</span> <span class="type">const</span>* e1, <span class="type">void</span> <span class="type">const</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (((Edge*)e1)-&gt;weight &gt; ((Edge*)e2)-&gt;weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MST_Kruskal</span><span class="params">(<span class="type">const</span> AMGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Edge* edges = <span class="keyword">new</span> Edge[MVNum];	<span class="comment">//	创建一个边集数组</span></span><br><span class="line">	<span class="type">int</span>* parent = <span class="keyword">new</span> <span class="type">int</span>[G.vertexnum];</span><br><span class="line">	<span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> min_casts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(parent, <span class="number">0</span>, <span class="built_in">sizeof</span>(parent));</span><br><span class="line">	<span class="built_in">edgecpy</span>(G, edges);</span><br><span class="line">	<span class="built_in">qsort</span>(edges,G.arcnum, <span class="built_in">sizeof</span>(Edge), cmp_);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.arcnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m = <span class="built_in">Find</span>(parent, edges[i].begin);</span><br><span class="line">		n = <span class="built_in">Find</span>(parent, edges[i].end);</span><br><span class="line">		<span class="keyword">if</span> (m != n)</span><br><span class="line">		&#123;</span><br><span class="line">			parent[m] = n;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; edges[i].begin &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; edges[i].end &lt;&lt; <span class="string">&quot; )\n&quot;</span>;</span><br><span class="line">			min_casts += edges[i].weight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>从边出发，并查集的思想很重要</p>
</blockquote>
<p><img src="/../images/tian.jpg"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra</title>
    <url>/2023/03/27/Dijkstra/</url>
    <content><![CDATA[<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><ul>
<li><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在一个图中，怎样找到一个点，到其余任何一个点的权值最小的路径，这个就是最短路径问题。</p>
</li>
<li><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><h4 id="从点入手"><a href="#从点入手" class="headerlink" title="从点入手"></a>从点入手</h4><p>我们从点的角度考虑，每次选择最短的路径，然后将新的端点家啊如考虑的集合。</p>
</li>
<li><h4 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h4><p>我们会遇到一个问题就是，如果新的点构成一条更短的路径，所以每加入一个点，就进行一个检查</p>
</li>
<li><h4 id="INF"><a href="#INF" class="headerlink" title="INF"></a>INF</h4><p>INF来建立，已判断是否相连</p>
</li>
</ul>
</li>
<li><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><ul>
<li><h4 id="final数组"><a href="#final数组" class="headerlink" title="final数组"></a>final数组</h4><p>final数组来判断是否已经有最短路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span>[i] = <span class="number">0</span>;	<span class="comment">// 0代表没有找到</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Path数组"><a href="#Path数组" class="headerlink" title="Path数组"></a>Path数组</h4><p>Path来记录到达每一个对应的顶点的上一个前驱结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MVNum];		<span class="comment">//存储最短路径的下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MVNum];	<span class="comment">//存储各点的最小路径的权值和</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>记住更新判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.vexnum; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INF;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; C[w] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = C[w];	<span class="comment">//不用考略的原因在于final</span></span><br><span class="line">				k = w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span>[w] = <span class="number">1</span>;	<span class="comment">//找到了就先标记一个然后开始更新检查</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; min + G.arcs[k][w] &lt; C[w])</span><br><span class="line">			&#123;</span><br><span class="line">				P[w] = k;		<span class="comment">// 保证了找到到每一个点的最短路径</span></span><br><span class="line">				C[w] = min + G.arcs[k][w];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEDGE	50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF	0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE	100</span></span><br><span class="line"><span class="comment">// 迪杰斯特拉算法本质是一种贪心算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AMGraph</span></span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> vexnum;</span><br><span class="line">	<span class="type">int</span> arcnum;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MVNum];		<span class="comment">//存储最短路径的下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MVNum];	<span class="comment">//存储各点的最小路径的权值和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v0,Patharc P, ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> v, w, k, min;	<span class="comment">//以前的一种习惯</span></span><br><span class="line">	<span class="type">int</span> <span class="keyword">final</span>[MVNum];	<span class="comment">// 这个数组用来判断 一个点是否已经找到了最短路径</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span>[i] = <span class="number">0</span>;	<span class="comment">// 0代表没有找到</span></span><br><span class="line">		P[i] = v0;<span class="comment">//假设每个都设为v0</span></span><br><span class="line">		C[i] = G.arcs[v0][i];	<span class="comment">//	同理为到v0 的距离 第一次一定满足</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span>[v0] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//P[v0] = v0;  目前似乎可以不用</span></span><br><span class="line">	C[v0] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.vexnum; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INF;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; C[w] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = C[w];	<span class="comment">//不用考略的原因在于final</span></span><br><span class="line">				k = w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span>[w] = <span class="number">1</span>;	<span class="comment">//找到了就先标记一个然后开始更新检查</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; min + G.arcs[k][w] &lt; C[w])</span><br><span class="line">			&#123;</span><br><span class="line">				P[w] = k;		<span class="comment">// 保证了找到到每一个点的最短路径</span></span><br><span class="line">				C[w] = min + G.arcs[k][w];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>贪心思想，每次选择最优解，妙处在这个记录路径的数据结构，以及判断的选择，标记的思想。</p>
</blockquote>
<p><img src="/../images/to.jpg"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MARKDOWN</title>
    <url>/2023/03/22/MARKDOWN-0/</url>
    <content><![CDATA[<h2 id="本文总结一些学习到的Markdown语法以及相关工具"><a href="#本文总结一些学习到的Markdown语法以及相关工具" class="headerlink" title="本文总结一些学习到的Markdown语法以及相关工具"></a>本文总结一些学习到的Markdown语法以及相关工具</h2><ol>
<li><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li><h4 id="标题设置"><a href="#标题设置" class="headerlink" title="标题设置"></a>标题设置</h4><ul>
<li><em>等级标题</em><br> # ## ### 类似的一共有六级 数量不同代表不同的大小</li>
</ul>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></li>
<li><h4 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a><em>斜体（Italic）</em></h4><p> 应该有很多种 ，不过较为普适的是*单词* 例子</p>
<h2 id="这是一个例子"><a href="#这是一个例子" class="headerlink" title="这是一个例子"></a><em>这是一个例子</em></h2></li>
<li><h4 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a><strong>粗体</strong></h4><p> 普适的**单词**</p>
<h2 id="这是一个例子-但是实际上每个标题都默认了"><a href="#这是一个例子-但是实际上每个标题都默认了" class="headerlink" title="这是一个例子  但是实际上每个标题都默认了"></a><strong>这是一个例子</strong>  但是实际上每个标题都默认了</h2></li>
<li><h4 id="又粗又斜"><a href="#又粗又斜" class="headerlink" title="又粗又斜"></a><em><strong>又粗又斜</strong></em></h4><p> ***单词*** 注意上面的都是紧紧挨着单词的 </p>
</li>
<li><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p> \ 类似其他的语言 直接 一个反斜杠</p>
</li>
<li><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><ol>
<li>可以先敲两个空格之后 然后换行</li>
<li>可以用 &lt;br&gt;</li>
<li>我在Vscode 和 typora 似乎可以直接换行啊</li>
</ol>
</li>
</ol>
<ol start="7">
<li><h4 id="其他几种格式"><a href="#其他几种格式" class="headerlink" title="其他几种格式"></a>其他几种格式</h4><ol>
<li>分割线 *** ___ — 至少三个<br> 举个例子</li>
</ol>
<hr>
<hr>
<hr>
<h3 id="三个效果好像一样"><a href="#三个效果好像一样" class="headerlink" title="三个效果好像一样"></a>三个效果好像一样</h3><ol>
<li>删除线<br> 两个~~单词~~<br> <del>Winter</del></li>
<li>下划线<br> 用的html语法 就是&lt;u&gt;&lt;&#x2F;u&gt;  <em><strong>注意是一个斜杠</strong></em><br> 举个例子 <u>For Ms.Winter</u></li>
</ol>
</li>
</ol>
<ol start="8">
<li><h3 id="——引用与序表"><a href="#——引用与序表" class="headerlink" title="——引用与序表"></a>——引用与序表</h3><pre><code> 引用（为什么已经引用了？？？）
</code></pre>
<ol>
<li>引用<br> （不明所以啊）看一看啊&gt; &gt;&gt; 类似的 举个例子    <blockquote>
<p>你好啊 你们逗号吗</p>
<blockquote>
<p>我很好</p>
<blockquote>
<p>真的吗   </p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>有序列表<br> 就是我现在写的这些数字标号 注意要隔开<br> 举个例子    <ol>
<li>好<ol>
<li>好<ol>
<li>好 似乎最多只有三级  每次tab一下就可以自动升级或者降级</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>无序列表<br>   - 使用这个符号<br>   举个例子 <ul>
<li>好 好 好 好<ul>
<li>好</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="重新实验"><a href="#重新实验" class="headerlink" title="重新实验"></a>重新实验</h3><pre><code> 你好 哦 我懂了 如果在有序表之后再两个tab 就可以有这样一个块
</code></pre>
</li>
</ol>
</li>
<li><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><pre><code>你啥感觉卡斯柯估计是客观的就卡死了干净ask房间昆仑山感觉

阿贾克斯打个卡速度过快发生你的开发代码 ***似乎没什么用***
</code></pre>
<ol start="11">
<li><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span>:</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>就是使用```cpp &#96;&#96;&#96;哇好厉害啊</p>
</li>
<li><h4 id="空格表示"><a href="#空格表示" class="headerlink" title="空格表示"></a>空格表示</h4><p>这个有点有趣 $~~~~$ 可以指定任意个数的</p>
</li>
<li><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ol>
<li><em>超链接</em><br>使用&lt;&gt; 直接写一个地址就可以     同样可以使用邮箱地址<br><a class="link"   href="https://www.w3school.com.cn/" >https://www.w3school.com.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><em>引用式超链接</em><ol>
<li>  <a class="link"   href="https://www.w3school.com.cn/" >link1djfj <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
</li>
<li><em>设定文字的超链接</em></li>
</ol>
<pre><code> 1.  使用[显示名字](url)
</code></pre>
</li>
</ol>
<p>   <a class="link"   href="https://www.w3school.com.cn/" >这里是一个链接地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 也可以是一个文件路<br>          2.  <em>带有一个titile</em><br>  所谓的title就是悬停再链接上会显示的文字 举个例子 放在()里 url用空格相连 这是一个链接<a class="link"   href="https://www.w3school.com.cn/"  title="Look at you">Look at me <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>    &#x2F;&#x2F;感觉还是挺方便的<br>        3. <em>带有格式化的链接</em><br>  <strong><a class="link"   href="https://www.w3school.com.cn/" >hello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong><br>  <em><a class="link"   href="https://www.w3school.com.cn/" >hello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em><br>  <em><strong><a class="link"   href="https://www.w3school.com.cn/" >hello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em><br>   <a href="https://www.w3school.com.cn/" title="Hello,World"><code>hello</code></a><br>  注意最后一个 是[`word`](url &quot;title&quot;) 的写法<br>        4. <em>引用式链接</em><br>   大概就是 创建一个链接创建一个标签 然后可以多次使用了 举个例子<br>   首先创建 [link]: <a class="link"   href="https://www.w3school.com.cn/" >https://www.w3school.com.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  注意有： 且有一个空格</p>
</li>
</ol>
<p>   <a class="link"   href="https://www.w3school.com.cn/" >我将进行第一次引用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>   用法格式 [显示文字][标签名]</p>
<ol>
<li><h4 id="图片的使用"><a href="#图片的使用" class="headerlink" title="图片的使用"></a>图片的使用</h4><ol>
<li><p>格式 ！[这是图片](本地地址 “图片标题”)</p>
</li>
<li><p>带有链接的图片 ！[[这是一个图片](本地地址)](链接) 地址可以是url 注意两个[[]]</p>
</li>
<li><p>举个例子 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/jiaj.jpg"
                      alt="My photo"
                >     </p>
</li>
<li><p><a href="https://www.w3school.com.cn/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://th.bing.com/th/id/OIP.avb9nDfw3kq7NOoP0grM4wHaEK?w=282&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7"
                      alt="My photo"
                ></a></p>
<ol>
<li><h4 id="文字与背景颜色"><a href="#文字与背景颜色" class="headerlink" title="文字与背景颜色"></a>文字与背景颜色</h4></li>
</ol>
</li>
<li><p>文字颜色 支持十六进制颜色表示</p>
</li>
</ol>
</li>
<li><p>举个例子  &lt;font color &#x3D; Blue&gt;Text&lt;&#x2F;font&gt;<br> <font color = gree>hiiii</font><br> <font color = #f0f000>hiii</font><br> &#x2F;十六进制颜色是#开头 然后六位十六进制的数字 然后 顺序是RGB 255 是最多<br> <font color = #f0005>让我们看看这个颜色</font><br> 但是其实内置了很多 颜色 举个例子 seagreen seablue<br> <font color= seagreen>let me check it </font><br>     <font color= seablue>let me check it </font>  </p>
<ol start="3">
<li><em>背景颜色</em></li>
</ol>
<p>&lt;font style&#x3D;background:颜色&gt; </font>       </p>
<p> 举个例子<br>     <font style =background:seagreen>hello world  你好 世界</font></p>
</li>
</ol>
<p>​<br>​<br>2. ## 工具推荐与使用<br>    1. ### Vscode &amp; 相关 的插件<br>        很方便的一点就是可以瞬时查看自己的样式 并且标准与github一致<br>    2. ### Typora<br>        确实就很好了 可以通过选项 而不用在意源码 了 相当于提供了一个GUI</p>
<ol start="3">
<li><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2></li>
</ol>
<blockquote>
<p>目前所需的Markdown语法大概如此至于与Latex和HTML相关的由于使用较少，暂未提及，以后遇到再作更新学习</p>
</blockquote>
]]></content>
      <tags>
        <tag>MARKDOWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd</title>
    <url>/2023/03/27/Floyd/</url>
    <content><![CDATA[<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><ul>
<li><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><h4 id="一次解决全图"><a href="#一次解决全图" class="headerlink" title="一次解决全图"></a>一次解决全图</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> vexnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="插点的循环"><a href="#插点的循环" class="headerlink" title="插点的循环"></a>插点的循环</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; k++)	<span class="comment">// 第一个</span></span><br><span class="line">		<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">			<span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (C[v][w] &gt;C[v][k] +C[k][w])</span><br><span class="line">				&#123;</span><br><span class="line">					C[v][w] = C[v][k] +C[k][w];</span><br><span class="line">					P[v][w] = P[v][k];		<span class="comment">//相当于就是在里面加点 最后一个我们读取矩阵</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   Floyd.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  3/27/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// Floyd</span></span><br><span class="line"><span class="comment">//关键思想就是不断的插入点来分析 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Path = <span class="type">int</span>[MVNum][MVNum];		</span><br><span class="line"><span class="keyword">using</span> ShortPathTable = <span class="type">int</span>[MVNum][MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最精妙的思想 一次求完所有的点 所以这是一个n^3复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样使用邻接矩阵</span></span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> vexnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">const</span> AMGraph&amp; G,Path P,ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> v, w, k;</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			C[v][w] = G.arcs[v][w];</span><br><span class="line">			P[v][w] = w;	<span class="comment">// 注意这个初始化</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 非常巧妙的循环也是关键</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; k++)	<span class="comment">// 第一个</span></span><br><span class="line">		<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">			<span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (C[v][w] &gt;C[v][k] +C[k][w])</span><br><span class="line">				&#123;</span><br><span class="line">					C[v][w] = C[v][k] +C[k][w];</span><br><span class="line">					P[v][w] = P[v][k];		<span class="comment">//相当于就是在里面加点 最后一个我们读取矩阵</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意我们的这个路径矩阵 与迪杰斯特拉一样 然后是列来读取</span></span><br><span class="line"><span class="comment">// 数值 横着读取</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispath</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, Path P, ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;各点的最短路径如下\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum<span class="number">-1</span>; v++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = v + <span class="number">1</span>; w &lt; G.vexnum; w++)		<span class="comment">// 只读取一般矩阵 也很好哦</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;v&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;-v&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot; weight: &quot;</span> &lt;&lt; C[v][w];</span><br><span class="line">			k = P[v][w];</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; Path: &quot;</span> &lt;&lt; v;</span><br><span class="line">			<span class="keyword">while</span> (k != w)</span><br><span class="line">			&#123;</span><br><span class="line">				k = P[k][w];</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; k;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>最后其实就是这种插点的思想</p>
</blockquote>
<p><img src="/../images/ly.jpg" alt="hh"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/03/23/DNS/</url>
    <content><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul>
<li><h3 id="DNS-Domain-name-system"><a href="#DNS-Domain-name-system" class="headerlink" title="DNS(Domain name system)"></a>DNS(Domain name system)</h3><ul>
<li><p>是DNS服务器实现的一个分布式数据库，同时也算是一个应用层协议运行在unix机器之上，端口号为53</p>
</li>
<li><p>http、smtp、ftp都是用了DNS将主机名转化为IP地址</p>
</li>
<li><p>原理如下</p>
<p>1） 同一台用户主机上运行着DNS应用的客户端。</p>
<p>2） 浏览器从上述URL中抽取岀主机名<a class="link"   href="http://www.baidu.com,并将这台主机名传给dns应用的客户端./" >www.baidu.com,并将这台主机名传给DNS应用的客户端。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>3） DNS客户向DNS服务器发送一个包含主机名的请求。</p>
<p>4） DNS客户最终会收到一份回答报文，其中含有对应于该主机名的IP地址。</p>
<p>5） 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。		</p>
</li>
<li><p>规范主机名与主机别名，邮件系统别名联想自己的学校邮箱</p>
</li>
</ul>
</li>
<li><h3 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h3><ul>
<li><p>主机例如web应用需要将主机名转换为IP地址时，调用DNS客户端，指明主机名，底层的unix实现是调用一个函数gethostbtname（）</p>
</li>
<li><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li><h5 id="分布式，层次"><a href="#分布式，层次" class="headerlink" title="分布式，层次"></a>分布式，层次</h5><p>根，顶级域(TLD，top-level domain),权威，三层。举个例子</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/DNS%E5%B1%82%E6%AC%A1.png"
                      alt="DNS层次"
                ></p>
<p>国家，fr,jp,ca,也是自己国家维护的顶级域 权威顶级域就是因特网上能够被公共访问的服务器主机需要提供的一个可公共访问的DNS记录，例如大学，自己维护的DNS服务器</p>
</li>
<li><h5 id="本地DNS服务器与缓存"><a href="#本地DNS服务器与缓存" class="headerlink" title="本地DNS服务器与缓存"></a>本地DNS服务器与缓存</h5><p>通过本地公用来减少流量，缓存可以减少路径，尽量绕过根DNS</p>
</li>
</ul>
</li>
<li><h4 id="DNS记录与报文"><a href="#DNS记录与报文" class="headerlink" title="DNS记录与报文"></a>DNS记录与报文</h4><ul>
<li><h5 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h5></li>
</ul>
<p>DNS服务器中提供了资源记录，包含四元组(Name, Value，Type，TTL) </p>
<p>如果Type &#x3D; A,则Name是主机名，Value是该主机名对应的IP地址。因此，一条类型为A的资源记录提供了标准的主机名到IP地址的映射。例如(Tayl.bar. foo. com, 145. 37.93. 126, A)就是一条类型 A 记录。</p>
<p>如果Type &#x3D; NS,则Name是个域(如foo. com),而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。例如(fgcom, cins.foo.com, NS)就是一条类型为NS的记录。</p>
<p>如果Type&#x3D;CNAME，则 Value是别名为Name的主机对应的规范主机名。该记录能够向査询的主机提供一个主机名对应的规范主机名，例如(foo.com, relay1.bar. foo. com, CNAME)就是一条 CNAME 类型的记录。</p>
<p>如果Type &#x3D; MX,则Value是个别名为Name的邮件服务器的规范主机名。举例来说，(foo.com, mail. bar. fo&lt;). com, MX)就是一条MX记录。MX记录允许邮件服务器主机名具有简单的别名。值得注意的是，通过使用MX记录，一个公司的邮件服务器和其他服务器(如它的Web服务器)可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录</p>
<ul>
<li><h5 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/DNS%E6%8A%A5%E6%96%87.png"
                      alt="DNS报文" title="DNS报文"
                ></li>
</ul>
<p>控制台键入nslookup 即可看权威DNS服务器与地址 dns.hust.edu.cn</p>
</li>
</ul>
</li>
</ul>
<h2 id="P2P与BitTorrent"><a href="#P2P与BitTorrent" class="headerlink" title="P2P与BitTorrent"></a>P2P与BitTorrent</h2><p>​	之前都是采用客户-服务器体系结构，依赖于服务器，P2P则是最小或是没有依赖。成对间歇连接的主机直接相连，对等方。最广泛的是BitTorrent协议</p>
<ul>
<li><h3 id="P2P体系结构的拓展性"><a href="#P2P体系结构的拓展性" class="headerlink" title="P2P体系结构的拓展性"></a>P2P体系结构的拓展性</h3><p>在用户接受到后能够使用自己的能力进行一个上传。</p>
</li>
<li><h3 id="BitTorrent-协议"><a href="#BitTorrent-协议" class="headerlink" title="BitTorrent 协议"></a>BitTorrent 协议</h3><p>洪流，主机集合，可以一起向其他主机传输，用追踪器实现。传送时，遵循一定的最有算法。</p>
</li>
</ul>
<h2 id="视频流"><a href="#视频流" class="headerlink" title="视频流"></a>视频流</h2><ul>
<li><h3 id="http流与DASH"><a href="#http流与DASH" class="headerlink" title="http流与DASH"></a>http流与DASH</h3><p>http流中的视频就是一个普通的http下的文件具有一个url。初期，由于具有统一格式，提供单一视频的性质，现在，为经HTTP的动态适应性流(Dynamic AdaptiveStreaming over HTTP, DASH) ，编码不同版本，不同画质。</p>
<ul>
<li><h4 id="内容发布网"><a href="#内容发布网" class="headerlink" title="内容发布网"></a>内容发布网</h4>CDN，在传统的DNS访问中，最后得到的是一个CDN内容服务器IP地址，然后再CDN中处理</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Prim</title>
    <url>/2023/03/24/Prim/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><font color=Aqua>加入你遇到这样一个问题，在一个表示了很多村庄的交通图中，其中有每两个村庄之间的交通开销。我们怎么才能够将所有的村庄都相连，并且没有回路，即离散数学里的极小连通图。我们的Prim算法给出了一种经典的解决方法。</font></p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="数学抽象"><a href="#数学抽象" class="headerlink" title="数学抽象"></a>数学抽象</h3><p>我们运用离散数学中的图来简化模型，将村庄视作点，边视作连线，然后赋予对应的一个权值。</p>
<h3 id="关键思路分析"><a href="#关键思路分析" class="headerlink" title="关键思路分析"></a>关键思路分析</h3><ul>
<li><h4 id="以点为中心"><a href="#以点为中心" class="headerlink" title="以点为中心"></a>以点为中心</h4><p>因为最终生成的路径一定要包含所有的顶点，所以我们可以从点的角度考虑。任取一个点，找到与其邻接的所有顶点，然后找到最小的权值对应的顶点，把该点放入我们的点集合里，然后然后重复上面的步骤就可以了。</p>
</li>
<li><h4 id="更新权值"><a href="#更新权值" class="headerlink" title="更新权值"></a>更新权值</h4><p>一个比较关键的地方就是要不断检查权值，然后对应进行更新。</p>
<blockquote>
<p>其实思路总体还是比较清晰，简单，不过在代码里面有很多巧妙的地方</p>
</blockquote>
</li>
</ul>
<h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><ul>
<li><h4 id="如何存储点的信息"><a href="#如何存储点的信息" class="headerlink" title="如何存储点的信息"></a>如何存储点的信息</h4><p>我们定义一个Prim特有的数据结构来进行存储</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个就是Prim算法的特殊数据结构，就是你使用这个算法就必须要想起的一个结构</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// ADT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">closeedge</span> &#123;</span><br><span class="line">	<span class="type">int</span> adjvex;</span><br><span class="line">	<span class="type">int</span> lowcast;	<span class="comment">//?  low cast </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路很妙，lowcast记录该点的最小开销，而adjvex对应最小开销的对应的边。不过我们还有一个问题，那就是我们会发现，怎么检查一个点是否已经在我们的已经考虑过的集合里，然后又怎么决定两条边是否相连，我们分别对下面 的问题进行解决。   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	100</span></span><br><span class="line"><span class="comment">// ? love favorite </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">	<span class="type">int</span> vertexnum&#123;MVNum&#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;		<span class="comment">//? Low cost</span></span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure>

<p>我们使用边集数组的数据结构来表示，（这就是数据结构的魅力），然后我们在初始化的时候将对角线初始化为0，以lowcast&#x3D;0来代表不能建路径，以INF一个极大值来检查是否连通。这就是算法中的关键思路</p>
</li>
<li><h4 id="判断条件（如上）"><a href="#判断条件（如上）" class="headerlink" title="判断条件（如上）"></a>判断条件（如上）</h4></li>
</ul>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   MTS.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  3/24/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// Now we come to the MTS</span></span><br><span class="line"><span class="comment">//? Most Cost Spannig Tree </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	100</span></span><br><span class="line"><span class="comment">// ? love favorite </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">	<span class="type">int</span> vertexnum&#123;MVNum&#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;		<span class="comment">//? Low cost</span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">locate</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">		<span class="keyword">if</span> (v == G.vertices[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(G.arcs, INF, <span class="built_in">sizeof</span>(G.arcs));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">		G.arcs[i][i] = <span class="number">0</span>;		<span class="comment">// It must been done !</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;first please input the arcnum and vernum of the graph&quot;</span>;</span><br><span class="line">	cin &gt;&gt; G.vertexnum &gt;&gt; G.arcnum;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now please enter the vertices first&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">		cin &gt;&gt; G.vertices[i];</span><br><span class="line">	VerTexType v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">	ArcType weight&#123; <span class="number">-1</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i&#123; <span class="number">0</span> &#125;, j&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now please enter all the arcs and weight&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.arcnum; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;</span><br><span class="line">		i = <span class="built_in">locate</span>(G, v1);</span><br><span class="line">		j = <span class="built_in">locate</span>(G, v2);</span><br><span class="line">		G.arcs[i][j] = weight;			<span class="comment">// UDN</span></span><br><span class="line">		G.arcs[j][i] = weight;			<span class="comment">// UDN</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是Prim算法的特殊数据结构，就是你使用这个算法就必须要想起的一个结构</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// ADT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">closeedge</span> &#123;</span><br><span class="line">	<span class="type">int</span> adjvex;</span><br><span class="line">	<span class="type">int</span> lowcast;	<span class="comment">//?  low cast </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键思路的分析 ，就是把点作为一个集合，从所有与这个集合相连的点中挑选</span></span><br><span class="line"><span class="comment">// 运用一个数组存储对应的顶点的最小开销，与此同时，再使用一个数组来记录对应的边的</span></span><br><span class="line"><span class="comment">// 另一个顶点 然后 为了判定一个点是否已经在集合内，我们将其cast 设置为0</span></span><br><span class="line"><span class="comment">// 并且最开始的时候我们的矩阵里使用的是一个INF 数据设计很巧妙</span></span><br><span class="line"><span class="comment">// The prim from a blogger </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(AMGraph&amp; G, <span class="type">int</span> v)</span>	<span class="comment">//? We choose a start point v0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// First we use the closeedge</span></span><br><span class="line">	closeedge C[MVNum];		<span class="comment">// Special data struct</span></span><br><span class="line">	<span class="comment">// Init it with the v point</span></span><br><span class="line">	<span class="type">int</span> min_casts = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		C[i].adjvex = v;</span><br><span class="line">		C[i].lowcast = G.arcs[v][i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;对应的边是&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G.vertexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> min_cast = INF;	<span class="comment">// Just the case</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vertexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (C[j].lowcast != <span class="number">0</span> &amp;&amp; C[j].lowcast &lt; min_cast)</span><br><span class="line">			&#123;</span><br><span class="line">				temp = j;</span><br><span class="line">				min_cast = C[j].lowcast;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; ( &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; C[temp].adjvex &lt;&lt; <span class="string">&quot; )&quot;</span>;</span><br><span class="line">		min_casts += min_cast;</span><br><span class="line">		C[temp].lowcast = <span class="number">0</span>;	<span class="comment">// You&#x27;ve seen what the use just to see if used!!!</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.vertexnum; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (C[k].lowcast != <span class="number">0</span> &amp;&amp; G.arcs[temp][k] &lt; C[k].lowcast)</span><br><span class="line">			&#123;</span><br><span class="line">				C[k].lowcast = G.arcs[temp][k];</span><br><span class="line">				C[k].adjvex = k;		<span class="comment">// Now you see what the adjvex mean</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;All casts are &quot;</span> &lt;&lt; min_casts &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we could see the o(n^2)</span></span><br><span class="line"><span class="comment">// We could also use the KrustalAL other method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//? Krustal 算法的实现</span></span><br><span class="line"><span class="comment">// 对应的我们KRUSTAL 算法也有对应的特有的数据结构 就是我们的边集数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> begin, end;</span><br><span class="line">	ArcType weight;		<span class="comment">// ? the begin mean the point of the arcs</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且我们也要用到并查集的知识 感觉非常巧妙</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><font color=coral>之前很少细想算法设计的思路，自己的思维没有得到锻炼，其中的数学简化思想与代码设计很巧妙与优美，完</font></p>
<p><img src="/../images/Rei.jpg" alt="hh" title="绫波"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS&amp;DFS</title>
    <url>/2023/03/23/BFS-DFS/</url>
    <content><![CDATA[<h2 id="简单总结一下BFS与DFS在图中的实现"><a href="#简单总结一下BFS与DFS在图中的实现" class="headerlink" title="简单总结一下BFS与DFS在图中的实现"></a>简单总结一下BFS与DFS在图中的实现</h2><ul>
<li><h3 id="BFS-amp-DFS-in-C"><a href="#BFS-amp-DFS-in-C" class="headerlink" title="BFS&amp;DFS in C++"></a><strong>BFS&amp;DFS in C++</strong></h3>  <font color=aqua><em><strong>由于对class不熟，没有写成类，但是单独写了头文件，作为一个标准例子吧</strong></em></font><h4 id="这是头文件"><a href="#这是头文件" class="headerlink" title="这是头文件"></a>这是头文件</h4>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   BFS.hpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter </span></span><br><span class="line"><span class="comment"> *  To demonstrate the BFS and DFS in graph </span></span><br><span class="line"><span class="comment"> * as well as wellas review the queue and graph</span></span><br><span class="line"><span class="comment"> * \author Winter</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once		<span class="comment">/* Two lines just in case */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BFS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW	-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE	-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	50	<span class="comment">// Maximum number of vertices</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE	100</span></span><br><span class="line"><span class="comment">//ADT</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> Len = <span class="type">int</span>;		<span class="comment">//C++ version</span></span><br><span class="line"><span class="comment">// ALGraph</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> OtherInfo;	<span class="comment">//Maybe the weight</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">anode</span> &#123;</span><br><span class="line">	<span class="type">int</span> adjvex;		<span class="comment">//the index of this node</span></span><br><span class="line">	OtherInfo info;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">anode</span>* next;</span><br><span class="line">&#125;Arcnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span> &#123;</span><br><span class="line">	VertexType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Arcnode</span>* firstarc;</span><br><span class="line">	<span class="comment">// struct Arcnode*antifirst;	the out degree</span></span><br><span class="line">&#125;Vnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vnode AdjList[MVNum];	</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="type">int</span> vernum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AMGraph</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VertexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">	<span class="type">int</span> vernum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue the Squeue and list queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType* data;</span><br><span class="line">	<span class="type">int</span> front;</span><br><span class="line">	<span class="type">int</span> rear;</span><br><span class="line">&#125;SQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">qnode</span> &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">qnode</span>* next;</span><br><span class="line">&#125;Qnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	Qnode* front;</span><br><span class="line">	Qnode* rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the external value we will use in the main.cpp</span></span><br><span class="line">Arcnode* static_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">bool</span> visited[MVNum];		<span class="comment">//BFS</span></span><br><span class="line"><span class="type">bool</span> Visited[MAXSIZE];		<span class="comment">//DFS</span></span><br><span class="line"><span class="comment">//static funcion </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span>	<span class="title">FirstAdjVex</span><span class="params">(<span class="type">const</span> ALGraph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_)</span><br><span class="line">		static_ = G.vertices[v].firstarc;</span><br><span class="line">	<span class="keyword">return</span> G.vertices[v].firstarc-&gt;adjvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">NextAdjVex</span><span class="params">(<span class="type">const</span> ALGraph G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	static_ = static_-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (static_)</span><br><span class="line">		<span class="keyword">return</span> static_-&gt;adjvex;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Func</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_S</span><span class="params">(SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty_S</span><span class="params">(<span class="type">const</span> SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue_S</span><span class="params">(SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue_S</span><span class="params">(SQueue&amp; Q, ElemType add)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue_S</span><span class="params">(SQueue&amp; Q, ElemType&amp; del)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty</span><span class="params">(<span class="type">const</span> Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElemType add)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElemType&amp;del)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> ALGraph&amp; G, <span class="type">int</span> v)</span></span>;	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="这是cpp文件"><a href="#这是cpp文件" class="headerlink" title="这是cpp文件"></a>这是cpp文件</h4>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   BFS.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  21/3/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// ?Here we come the BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BFS.hpp&quot;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_S</span><span class="params">(SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * MVNum);</span><br><span class="line">	<span class="keyword">if</span> (!Q.data)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue_S</span><span class="params">(SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(Q.data);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty_S</span><span class="params">(<span class="type">const</span> SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue_S</span><span class="params">(SQueue&amp;Q,ElemType add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MVNum == Q.front)</span><br><span class="line">		<span class="keyword">return</span> BAD;</span><br><span class="line">	Q.data[Q.rear] = add;</span><br><span class="line">	Q.rear = (Q.rear + <span class="number">1</span>) % MVNum;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue_S</span><span class="params">(SQueue&amp; Q, <span class="type">int</span>&amp; del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> BAD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Qnode*pnew = (Qnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Qnode));</span><br><span class="line">	<span class="keyword">if</span> (!pnew)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	Q.front = Q.rear = pnew;</span><br><span class="line">	Q.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty</span><span class="params">(<span class="type">const</span> Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.rear = Q.front;</span><br><span class="line">	<span class="keyword">while</span> (Q.front)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.rear = Q.front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(Q.front);</span><br><span class="line">		Q.front = Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElemType add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Qnode* pnew = (Qnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Qnode));</span><br><span class="line">	pnew-&gt;data = add;</span><br><span class="line">	pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	Q.rear-&gt;next = pnew;</span><br><span class="line">	Q.rear = pnew;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElemType&amp; del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> BAD;</span><br><span class="line">	Qnode* psave = Q.front-&gt;next;</span><br><span class="line">	del = psave-&gt;data;</span><br><span class="line">	Q.front-&gt;next = psave-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == psave)</span><br><span class="line">		Q.rear = Q.front;</span><br><span class="line">	<span class="built_in">free</span>(psave);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> ALGraph&amp; G, <span class="type">int</span> v)</span>	<span class="comment">//? v the start of the BFS</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue vessel;</span><br><span class="line">	<span class="built_in">InitQueue</span>(vessel);</span><br><span class="line">	cout &lt;&lt; G.vertices[v].data;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">EnQueue</span>(vessel, v);</span><br><span class="line">	<span class="type">int</span> u&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">QueueIsEmpty</span>(vessel))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeQueue</span>(vessel, u);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstAdjVex</span>(G, u); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextAdjVex</span>(G, u, w))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[w])</span><br><span class="line">			&#123;</span><br><span class="line">				visited[w] = <span class="literal">true</span>;</span><br><span class="line">				cout &lt;&lt; G.vertices[w].data;</span><br><span class="line">				<span class="built_in">EnQueue</span>(vessel, w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= G.vernum)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	cout &lt;&lt; G.vertices[v];</span><br><span class="line">	Visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vernum; ++w)</span><br><span class="line">		<span class="keyword">if</span> (G.arcs[v][w] &amp;&amp; !Visited[w])</span><br><span class="line">			<span class="built_in">DFS</span>(G, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inline int FirstAdjvex(const ALGraph&amp; G, int v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	if (!static_)</span></span><br><span class="line"><span class="comment">//		static_ = G.vertices[v].firstarc;</span></span><br><span class="line"><span class="comment">//	return G.vertices[v].firstarc-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//inline int NextAdjvex(const ALGraph&amp; G, int v, int u)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	ArcNode* scan;</span></span><br><span class="line"><span class="comment">//	for (scan = G.vertices[v].firstarc; scan-&gt;adjvex != u &amp;&amp; !scan-&gt;next; scan = scan-&gt;next)</span></span><br><span class="line"><span class="comment">//		continue;</span></span><br><span class="line"><span class="comment">//	if (u == scan-&gt;adjvex &amp;&amp; !scan-&gt;next)</span></span><br><span class="line"><span class="comment">//		return scan-&gt;next-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//	return -1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//// ?May I create the new writing</span></span><br><span class="line"><span class="comment">//inline int NextNeighbor(const ALGraph&amp; G,int v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	if (!static_||!static_-&gt;next)</span></span><br><span class="line"><span class="comment">//		return -1;</span></span><br><span class="line"><span class="comment">//	static_=static_-&gt;next;</span></span><br><span class="line"><span class="comment">//	return static_-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Macro</span></span><br><span class="line"><span class="comment">//#define MVNum	50</span></span><br><span class="line"><span class="comment">//#define OK	1</span></span><br><span class="line"><span class="comment">//#define BAD	0</span></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="comment">//using Status = int;</span></span><br><span class="line"><span class="comment">//using VertexType = char;</span></span><br><span class="line"><span class="comment">//using ArcType = int;</span></span><br><span class="line"><span class="comment">//using Len = int;</span></span><br><span class="line"><span class="comment">//// the adjency list</span></span><br><span class="line"><span class="comment">//typedef struct anode&#123;</span></span><br><span class="line"><span class="comment">//	int adjvex;</span></span><br><span class="line"><span class="comment">//	ArcType info;</span></span><br><span class="line"><span class="comment">//	struct anode* next;</span></span><br><span class="line"><span class="comment">//&#125;ArcNode;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//typedef struct vnode &#123;</span></span><br><span class="line"><span class="comment">//	VertexType data&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//	ArcNode* firstarc;	//?there we don&#x27;t care the out degree</span></span><br><span class="line"><span class="comment">//&#125;Vnode;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//typedef Vnode AdjList[MVNum];	// ? Very special !!!</span></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//	AdjList vertices;</span></span><br><span class="line"><span class="comment">//	int vertexnum&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//	int arcnum&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//&#125;ALGraph;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////? we just can handle the adjlist like list and insert </span></span><br><span class="line"><span class="comment">//// ? from the head of the list!!!</span></span><br><span class="line"><span class="comment">////we will use the queue</span></span><br><span class="line"><span class="comment">//typedef int ElemType;		// just to store the index of the vex</span></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//	ElemType* data;</span></span><br><span class="line"><span class="comment">//	int front&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//	int rear&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//&#125;SQueue;</span></span><br><span class="line"><span class="comment">//// the loop queue</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="BFS-in-Python"><a href="#BFS-in-Python" class="headerlink" title="BFS in Python"></a>BFS in Python</h3></li>
</ul>
<p>		<br> 然后写了一个在python中BFS实现 主要用python可以省略一些细节而着重于思想理解</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#BFS in python</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment"># double queue</span></span><br><span class="line">graph=&#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;you&quot;</span>] = [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;claire&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;bob&quot;</span>] = [<span class="string">&quot;anuj&quot;</span>, <span class="string">&quot;peggy&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;alice&quot;</span>] = [<span class="string">&quot;peggy&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;claire&quot;</span>] = [<span class="string">&quot;thom&quot;</span>, <span class="string">&quot;jonny&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;anuj&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;peggy&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;thom&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;jonny&quot;</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_is_seller</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name[-<span class="number">1</span>]==<span class="string">&#x27;m&#x27;</span>        <span class="comment">#just give an example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">graph,name</span>):       <span class="comment">#we start from this guy</span></span><br><span class="line">    search_queue=deque()</span><br><span class="line">    search_queue+=graph[name]</span><br><span class="line">    searched=[]</span><br><span class="line">    <span class="keyword">while</span> search_queue:     <span class="comment">#not null</span></span><br><span class="line">        person=search_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">                <span class="built_in">print</span>(person+<span class="string">&#x27; is a wolfman&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                search_queue+=graph[person]</span><br><span class="line">                search.append(person)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h2></li>
</ul>
<p><strong><font color=seagreen>BFS主要应用了队列的思想 DFS主要运用了递归的思想 最终图的表示使用了离散数学的邻接矩阵于邻接表  Done!</font></strong></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Winter&#39;s blog</title>
    <url>/2023/03/16/Winter-s-blog/</url>
    <content><![CDATA[<h2 id="For-Ms-Winter"><a href="#For-Ms-Winter" class="headerlink" title="For Ms.Winter"></a>For Ms.Winter</h2><h3 id="先记录一下一个找图片地址的好地方-进入NASA官网直接copy-image-address-也可以在google里面使用-但是可能无法成功"><a href="#先记录一下一个找图片地址的好地方-进入NASA官网直接copy-image-address-也可以在google里面使用-但是可能无法成功" class="headerlink" title="先记录一下一个找图片地址的好地方 进入NASA官网直接copy image address 也可以在google里面使用 但是可能无法成功"></a>先记录一下一个找图片地址的好地方 进入NASA官网直接copy image address 也可以在google里面使用 但是可能无法成功</h3><ul>
<li><strong><font color=pink>emoji kitchen use ps to scale down and save in png and then port to QQ</font></strong></li>
<li><strong><font color=pink>QQ music .first download music from the magic website and then open in the directory with QQ player. Note: when you download by qq you could easily get adapted in the app ! Good!</font></strong></li>
</ul>
]]></content>
      <tags>
        <tag>Elements</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建指南</title>
    <url>/2023/03/25/hexo%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="零基础搭建静态网页（基于hexo与github-page"><a href="#零基础搭建静态网页（基于hexo与github-page" class="headerlink" title="零基础搭建静态网页（基于hexo与github page)"></a>零基础搭建静态网页（基于hexo与github page)</h2><h3 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h3><p>在网络发达的时代，如果吗想要拥有你自己的空间，同时又烦恼于腾讯qq空间的多种限制，何不自己动手，搭建属于自己的网页，这里，我将简单提供几个博客，和网站就hexo搭建网页（静态网页）作一个介绍</p>
<h3 id="你所要会的"><a href="#你所要会的" class="headerlink" title="你所要会的"></a>你所要会的</h3><p><font color=red>几乎是零基础，唯一需要的就是一个代理，如果你没有，实在找不到，我可以分享给你，虽然需要十元钱，但是它有个bug</font></p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p>我这里就先后顺序给出网址，并作简要说明；</p>
<blockquote>
<p>可以同时看一下我下面的问题解决，如果你在操作中出现问题的话，如果实在无法解决，可以评论。</p>
</blockquote>
<ul>
<li><h4 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a><a href="https://zhuanlan.zhihu.com/p/370635512"><font color= seablue>总体流程</font></a></h4></li>
</ul>
<p>其实这一个基本就可以完成搭建了，不过这里补充几个可能用到 的</p>
<ul>
<li><h4 id="模板来源"><a href="#模板来源" class="headerlink" title="模板来源"></a><a href="https://hexo.io/"><font color=seablue>模板来源</font></a></h4></li>
<li><h4 id="博客中的TAG使用"><a href="#博客中的TAG使用" class="headerlink" title="博客中的TAG使用"></a><a href="https://zhuanlan.zhihu.com/p/348131730"><font color= seablue>博客中的TAG使用</font></a></h4></li>
</ul>
<p>对于有tag和categories的网页的用法介绍</p>
<ul>
<li><h4 id="在线音乐获取"><a href="#在线音乐获取" class="headerlink" title="在线音乐获取"></a>在线音乐获取</h4><p>——<strong>暂时等待</strong> <font color=gold>我正打算写一个可以直接下载英语的web，由于要用django，可能比较久，如果不成功，我尽量提供一个源代码，到时候，大家只要可以运行应该就可以输入获取。</font></p>
</li>
<li><h4 id="一个找高清图片的网站"><a href="#一个找高清图片的网站" class="headerlink" title="一个找高清图片的网站"></a><a href="https://wallhaven.cc/"><font color= seablue>一个找高清图片的网站</font></a></h4></li>
<li><h4 id="CSS资源网站"><a href="#CSS资源网站" class="headerlink" title="CSS资源网站"></a><a href="https://www.w3cschool.cn/css3/css3-animation.html"><font color= seablue>CSS资源网站</font></a></h4><p>这个网站属于大家如果有自己改写代码的需要，可以参考，当然我自己不甚了解CSS和js</p>
</li>
<li><h4 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a><font color= seablue>markdown</font></h4><p>至于mark逗我呢使用方法可以参考我列举的一些关于markdown的用法。更完整的就是<a href="https://www.markdownguide.org/"><font color=seablue>Markdown官方文档</font></a></p>
</li>
</ul>
<p>推荐几个颜色 <font color=aqua>Aqua</font>  <font color=seablue>seablue</font>  <font color=chocolate>Chocolate</font>  <font color=azure>Azure</font></p>
<ul>
<li><h4 id="如果真的很感兴趣可以考虑学习JS"><a href="#如果真的很感兴趣可以考虑学习JS" class="headerlink" title="如果真的很感兴趣可以考虑学习JS"></a>如果真的很感兴趣可以考虑学习JS</h4></li>
</ul>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>列举一些我在操作中遇到的问题</p>
<ul>
<li><h4 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h4><p>注意命名时，必须是自己的用户名.io 这是github的要求</p>
</li>
<li><h4 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h4><p>尽量直接hexo new “标题”</p>
</li>
<li><h4 id="具体搭建指南"><a href="#具体搭建指南" class="headerlink" title="具体搭建指南"></a>具体搭建指南</h4><p>基本每一个框架都有说明，一般在对应的github仓库的README.md文件中</p>
</li>
<li><h4 id="获取网络图片"><a href="#获取网络图片" class="headerlink" title="获取网络图片"></a>获取网络图片</h4><p>先记录一下一个找图片地址的好地方 进入NASA官网直接copy image address 也可以在google里面使用 但是可能无法成功</p>
</li>
</ul>
<h2 id="Continuing"><a href="#Continuing" class="headerlink" title="Continuing"></a>Continuing</h2><p>暂时就写到这吧，欢迎交流，多请批评指教！</p>
<p><img src="/../images/lic.jpg"></p>
]]></content>
      <tags>
        <tag>Elements</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2023/03/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li><p><font color =chocolate>从前我们学习了KMP算法文本匹配，但是现在我们的这个正则表达式，提供一种单独的语法解决，但是KMP算法仍有很多局限且消耗算力，为了解决网络中的大量匹配问题，引入伟大的正则表达式，用于匹配与替换。</font></p>
</li>
<li><p><font color=blue violet>编程语言中我们使用的转义字符等有一定出处，正则表达式最初来自我们的unix机器</font> </p>
</li>
<li><h3 id="简单的语法"><a href="#简单的语法" class="headerlink" title="简单的语法"></a>简单的语法</h3><ul>
<li><h4 id="纯文本匹配"><a href="#纯文本匹配" class="headerlink" title="纯文本匹配"></a>纯文本匹配</h4><p>直接匹配文本，区分大小写，通常只返回第一个，可以编程语言中选择返回所有的数组。 </p>
</li>
<li><h4 id="号-匹配"><a href="#号-匹配" class="headerlink" title="**.号**匹配"></a>**<font color=red>.号</font>**匹配</h4><p>. 可以指代包括.在内的所有符号  匹配本身时引入了伟大的<em><strong>转义符号 \</strong></em>  </p>
</li>
<li><h4 id="匹配想要中的字符"><a href="#匹配想要中的字符" class="headerlink" title="匹配想要中的字符"></a>匹配想要中的字符</h4><p><font color = coral>使用[]，[]中的只要满足一个就算是匹配</font> 常常用在不区分大小写的表示  [Cc][Aa][Tt].eg	事实上我们的markdown都有转义字符</p>
<ul>
<li><h5 id="集合表示"><a href="#集合表示" class="headerlink" title="集合表示"></a>集合表示</h5><blockquote>
<p>一个自然的过渡，如果，集合中元素很多时，且连续，使用[A-Z] 遵循阿斯克码</p>
</blockquote>
</li>
<li><p><font color=seagreen>\ 与-都是元字符 -不需转义</font></p>
</li>
<li><h5 id="多个集合匹配"><a href="#多个集合匹配" class="headerlink" title="多个集合匹配"></a>多个集合匹配</h5><blockquote>
<p>举个例子[A-Za-z0-9]就是有三个集合 网页的十六进制颜色表示就是一种应用 [0-9A-Fa-f]</p>
</blockquote>
</li>
</ul>
</li>
<li><h4 id="取非匹配"><a href="#取非匹配" class="headerlink" title="取非匹配"></a>取非匹配</h4><ul>
<li>使用元字符^ 且作用于集合 注意是在集合的内部 求非 代表一个[^]因为具有多义性</li>
</ul>
</li>
<li><h4 id="元字符匹配"><a href="#元字符匹配" class="headerlink" title="元字符匹配"></a>元字符匹配</h4><ul>
<li><p>使用转义字符匹配 </p>
</li>
<li><p>[] - ^ \ . +</p>
</li>
<li><h6 id="特殊的元字符"><a href="#特殊的元字符" class="headerlink" title="特殊的元字符"></a>特殊的元字符</h6><ul>
<li>\f 换页符 \n换行符 \r回车符 \t制表符 \v垂直制表符 [\b]backspace</li>
<li>举个例子 处理 CSV文件 , 变成空格</li>
<li>windows 中 \r\n 表示换行 linux  \r可选 \n 必选</li>
</ul>
</li>
<li><h6 id="对集合的简化"><a href="#对集合的简化" class="headerlink" title="对集合的简化"></a>对集合的简化</h6><ul>
<li>\d 所有的数字&#x3D;[0-9] \D&#x3D;[^0-9]</li>
<li>\w 所有字母大小写与数字 \W 所有的非</li>
<li>\s 任何一个空字符 \f\n\r\v\t  \S </li>
<li>十六进制与八进制 \0x \0  \c 控制字符</li>
<li>POSIX字符的支持 格式[: 英文描述:]</li>
</ul>
</li>
<li><h6 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h6><ul>
<li>元字符 [0-9]+ 0-9中的数字的一个以上 不能0个</li>
<li>举个例子 关于邮箱地址的匹配 <ul>
<li>\w@\w\.\w 升级</li>
<li>\w+@\w+\.\w+</li>
<li>升级\[\w.]+@\[\w\.]+\.[\w.]+ 注意这个例子可以看出我们的在[]里所有的元字符都可以看作是普通字符 但是转义了也没有错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="元字符"><a href="#元字符" class="headerlink" title="*元字符"></a>*元字符</h4><ul>
<li>可以匹配0次与任意次 相当于 + 的升级版</li>
<li>\w+[\w.]*@[\w.]+\.\w+  可以把* 看作可选项  实质理解</li>
</ul>
</li>
<li><h4 id="？元字符"><a href="#？元字符" class="headerlink" title="？元字符"></a>？元字符</h4><ul>
<li>匹配一次或零次 http:&#x2F;&#x2F; 与 https:&#x2F;&#x2F; 不能用s*  httpsss 所以使用？</li>
<li>[\r]? 与我们的\r? 本质是一样的 但是为了清晰直观 我们通常直接[\r]</li>
</ul>
</li>
<li><h4 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h4><ul>
<li>{}也是元字符 举个例子就是之前的RGB #[0-9A-Fa-f]写六遍可以使用{6}</li>
<li>也可以设置一个区间{2.4}</li>
<li>[]中间是的元字符都是为普通字符，最好写一个\</li>
<li>匹配至少多少次 {3,}类似python</li>
</ul>
</li>
<li><h4 id="防止过度匹配"><a href="#防止过度匹配" class="headerlink" title="防止过度匹配"></a>防止过度匹配</h4><ul>
<li><p>使用懒惰版本，进行匹配，前面的匹配都是一个贪婪匹配，例如 * + {n，}   对应的懒惰版本就是加上一个? 例如 * 与 *？ 还有 + +? {n,} {n,}?</p>
<p>这里的懒惰可以理解成就是 尽量的再匹配到第一个的时候就停下来 ，而贪婪就是匹配到最后一个再停下来</p>
</li>
</ul>
</li>
<li><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><ul>
<li>指定匹配发生的位置</li>
<li>\b  一个标记，用来标记一个单词的开头或者是结尾  理解\b 的实质，实质就是匹配一个可以\w 与一个非字母或者是数字的位置\W 之间的一个位置  b代表boundary 注意我们的这个 \b 只是匹配一个位置 ，而不是匹配一个字符  所以 \bcat\b 得到的字符 还是 3个字符 而非5个</li>
<li>同理 的 \B 来匹配一个你想要的边界 就是 eg night-color  \B-\B 可以匹配 但是我们的 color - color 就是无法匹配</li>
<li>^ 这里来再次出现 用作 标记字符串的开始位置 $ 用于标记字符串的结尾</li>
<li>举个例子 匹配一个 XML 文件  因为必须要求 这个声明位于一个文档的最开始 所以我们需要进行 字符串的一个声明 例如 这个 ^\s*&lt;?xml.*?&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>SCRAPE</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2023/03/16/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h2 id="关于单调栈的一些东西"><a href="#关于单调栈的一些东西" class="headerlink" title="关于单调栈的一些东西"></a>关于单调栈的一些东西</h2><h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;a[s.<span class="built_in">top</span>()]&lt;=a[i])</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        f[i]=s.<span class="built_in">empty</span>()?<span class="number">0</span>:s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrape</title>
    <url>/2023/03/22/Scrape/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>本文使用的颜色较多，开启夜间模式阅读效果更好</p>
</blockquote>
<hr>
<h2 id="本系列主要是对阅读了python网络编程相关的总结与回顾"><a href="#本系列主要是对阅读了python网络编程相关的总结与回顾" class="headerlink" title="本系列主要是对阅读了python网络编程相关的总结与回顾"></a>本系列主要是对阅读了python网络编程相关的总结与回顾</h2><ol>
<li><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol>
<li><h4 id="http简介"><a href="#http简介" class="headerlink" title="http简介"></a><strong>http简介</strong></h4><p>  <em><strong>url</strong></em> : 统一资源定位符  格式如下 []代表可省略<br> <font color=seablue>protocol :&#x2F;&#x2F;[username:password@] hostname[:port] &#x2F; path &#x2F; [;parameters][?query]#fragment  </font><br> <font color=yellow>protocol</font>  : 协议 主要有 http,https,ftp,sms,<br> <font color =red>username,password</font> : 主要ftp<br> <font color =green>hostname</font> ： 主机名也就是域名 也可以用DNS映射得到IP地址，有一级二级域名之分<br> <font color =brown>port</font> : 端口号 http默认是80 类似还有https 443 属于套接口<br> <font color='cayon'>path</font> : 路径 就是位于主机中的地址<br> <font color='purple'>parameters</font> : 附加信息 现在用的少了<br> <font color=gold>query</font>  : 查询，多个查询就用&amp;分开，GET请求参数里也有<br> <font color=#a34929>fragment</font> : 片段 资源的补充 似乎很少使用<br> <font style =background:seagreen>http基本转向https 基于SSL socket相关也是爬取的主要内容</font>  </p>
</li>
<li><h4 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a><strong>http请求过程</strong></h4><p> <u>使用F12 Network 监听 Ctrl+R </u><br> <font color=seaf>Status</font>    : 状态码就是404 403 200 类似的<br> <font color=gold>Initiator</font> : 请求源 标记请求是由哪个进程或对象发起的<br> <font color=chocolate>Request</font>请求方法 请求头 请求体<br> <font color = aqua>Request Method</font> ： 请求方法GET POST居多 还有PUT DELETE 很多<br> <font color=azure></font><br> <font color=darkblue></font><br> <font color=coroflowerblue></font><br> <font color=blueviolet></font><br> <font color=coral></font><br> <font color=darkBlue></font>       </p>
<pre><code>3. **&lt;font color=azure&gt;Scrapy&lt;/font&gt;**
              1. Xpath syntax 用在我们的xml 文件里面 便于快速提取所需要的性质 /  // [] (predicates)
              2. Xml treated like tree of nodes 
              3.  [一个教程网站](https://docs.scrapy.org/en/latest/intro/tutorial.html)
              4. scrpay 的使用 基本教程都有  注意就是 有自己的内建命令 自己的脚本 不要出错了
              5. getall()  get()第一个元素 [0].get() title::text 仅仅要文本时候 re() 用正则表达式寻找
              6.  除此之外还有  xpath的方法 response.xpath(&quot;//title&quot;)
              7. [scrapy](https://docs.scrapy.org/en/latest/intro/tutorial.html)
              8. 在我们 的 html 文件里面一个这个&lt;&gt;&lt;&gt; 叫做一个 quote
                            1.  -O 会覆盖当前文件 -o 就是append模式
                            2.  用 jsonl 文件格式  可以不断添加 stream-like
</code></pre>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>SCRAPE</tag>
      </tags>
  </entry>
  <entry>
    <title>基础汇编指令</title>
    <url>/2023/03/23/%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h3><ul>
<li><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>一个标准的c语言程序在编译过程中，首先是经过翻译，成汇编语言，也就是Linux命令行中的-s选项，然后转为二进制的机器代码，然后通过连接器，与库相连，并且附上一些地址与起始终止信息。</p>
</li>
<li><h4 id="汇编语言与机器代码"><a href="#汇编语言与机器代码" class="headerlink" title="汇编语言与机器代码"></a>汇编语言与机器代码</h4><p>机器是二进制字节，电脑可读的指令，汇编语言就是助记符。可以编写</p>
</li>
<li><h4 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h4><p>不同机器，处理器的指令集架构不一样，但是高级抽象语言却能够通用，只要选用适合机器的编译器即可。</p>
</li>
<li><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4><p>因为英特尔前期处理器都是某某86所以简称x86，x86-64即64位拓展</p>
</li>
<li><h4 id="O优化"><a href="#O优化" class="headerlink" title="O优化"></a>O优化</h4><p>其实就是命令行的一个选型，高度优化可能使代码的汇编代码逻辑改变较大。</p>
</li>
<li><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul>
<li><h5 id="程序寄存器"><a href="#程序寄存器" class="headerlink" title="程序寄存器"></a>程序寄存器</h5><p>用于专门存储指令的地址 %rip</p>
</li>
<li><h5 id="一组十六个整数寄存器"><a href="#一组十六个整数寄存器" class="headerlink" title="一组十六个整数寄存器"></a>一组十六个整数寄存器</h5><p>用于系列操作</p>
</li>
<li><h5 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h5><p>存储维护条件码实现逻辑控制</p>
</li>
<li><h5 id="向量寄存器"><a href="#向量寄存器" class="headerlink" title="向量寄存器"></a>向量寄存器</h5><p>实现浮点数操作</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>“CSAPP”</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<blockquote>
<p>本来想要有条理一点，但是实在太多，所以就列举名词，作为条理了</p>
</blockquote>
<hr>
<h2 id="计算机网络常识"><a href="#计算机网络常识" class="headerlink" title="计算机网络常识"></a>计算机网络常识</h2><ul>
<li>名字解释  <ul>
<li>通信链路：指的就是些通信的物理媒介 同轴电缆 铜线 无线电频谱 光纤</li>
<li>分组交换机 packet switch 就是路由器 与链路层交换机</li>
<li>ISP 因特网服务提供商</li>
<li>TCP&#x2F;IP 主要协议</li>
<li>RFC 请求评论</li>
<li>网络边缘 高速宽带 数字用户线 电缆基础上使用的</li>
<li>上行下行速度</li>
<li>光纤到户</li>
<li>LAN局域网 无线局域网 基于IEEE 802. 11技术的无<br>线LAN接入,更通俗地称为WiFi</li>
<li>蜂窝移动网络</li>
<li>报文message</li>
</ul>
</li>
</ul>
<h4 id="再次温习-这次遵从前后学习的逻辑进行名词整理"><a href="#再次温习-这次遵从前后学习的逻辑进行名词整理" class="headerlink" title="再次温习 这次遵从前后学习的逻辑进行名词整理"></a><font color=pink>再次温习 这次遵从前后学习的逻辑进行名词整理</font></h4><ul>
<li><p><strong>Q引入</strong></p>
<ul>
<li>网络的物理结构是什么样的——物理定义互联网</li>
<li>两个电脑怎么传送信息——实现原理定义互联网</li>
</ul>
</li>
<li><p>端系统——即主机(host)，新兴事物（物联网），在网络末梢所以加端</p>
</li>
<li><p>主机——一个是客户(client)如PC（linux mac）另一个是服务器(server)存储web 文件 可以理解为更强大专一的</p>
</li>
<li><p>网络有点 ——主机，还有分租交换机主要有两个——路由器 与链路层交换机</p>
</li>
<li><p>网络有线——通信链路 具体有不同物理实现的媒介有不同bps速度</p>
</li>
<li><p>传送的信息叫分组(packet)——名字暗示着打包一样 </p>
</li>
<li><p>为了统一信息传递的各种流程我们需要遵循一定协议(protocol)</p>
</li>
<li><p>ISP 网络提供商 本质就是写交换机组成的网络</p>
</li>
<li><p>链路层交换机主要在接入网 而路由器主要在核心</p>
</li>
<li><p>接入网——将端系统物理连接到边缘路由器的网络</p>
</li>
<li><h3 id="各种物理媒介本质上是模电-数字信号的问题-设计的都是些调解器问题-上行下行-共享-共有的一些特征就是仍然是网络-各种各样的网络"><a href="#各种物理媒介本质上是模电-数字信号的问题-设计的都是些调解器问题-上行下行-共享-共有的一些特征就是仍然是网络-各种各样的网络" class="headerlink" title="各种物理媒介本质上是模电 数字信号的问题 设计的都是些调解器问题 上行下行 共享 共有的一些特征就是仍然是网络 各种各样的网络"></a>各种物理媒介本质上是模电 数字信号的问题 设计的都是些调解器问题 上行下行 共享 共有的一些特征就是仍然是网络 各种各样的网络</h3><ul>
<li>目前家庭多是宽带（电话线复用或者是电缆实现媒介是双绞铜线）光纤是新兴的还有两者混合的使用 企业多是LAN 和 WLAN  其中以太网是最流行的局域网技术 而wifi是无线接入技术</li>
<li>现在再底层一点看看物理原因双绞铜线的制作材料费用很低</li>
</ul>
</li>
<li><p><font color=pink>上次又没有保存 全部都没有了┭┮﹏┭┮</font></p>
</li>
<li><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>套接字是一种协议软 ，</li>
<li>主机ip地址以及端口号 port number</li>
<li>SSL安全套接字层 加密属性</li>
</ul>
</li>
<li><h3 id="Web-与-HTTP-协议"><a href="#Web-与-HTTP-协议" class="headerlink" title="Web 与 HTTP 协议"></a>Web 与 HTTP 协议</h3><ul>
<li><p>web的应用层协议就是http协议web是应用</p>
</li>
<li><p>通信严格上讲是进程间的通信</p>
</li>
<li><p>web browser就是客户端 服务器就是服务器端 存放web对象即web页面，通过url引用。url主要两个部分主机名和文件存储路径</p>
</li>
<li><p>http使用tcp运算协议</p>
</li>
<li><p>http无状态协议 不会保存客户端的状态，同时服务器总是打开的 ，固有的ip地址</p>
</li>
<li><p>RRT round-trip time 往返时间</p>
</li>
<li><p>请求报文格式</p>
<ul>
<li>GET POST HEAD PUT DELETE方法 GET最常见</li>
<li>格式  请求行 方法名+url+版本收不行就是主机 连接种类 代理 接受语言等视情况 一些额外的字段信息可能存在与 url中间</li>
</ul>
</li>
<li><p>what we can do with telnet </p>
<ul>
<li><em><strong><font color=pink>telnet 是一个协议 我们可以用telnet命令来模拟请求报文</font></strong></em></li>
</ul>
</li>
<li><p><em><strong>cookie</strong></em></p>
<ul>
<li>基本原理就是四个组件的协调 首先请求报文中有一个cookie首部行 然后相应报文也有 然后服务求后端数据库管理cookie条目 然后浏览器维护一组cookie文件</li>
<li>服务求端set cookie并将其唯一关联用户之后的行为与信息 每次交互时都附加一个cookie首部行</li>
</ul>
</li>
<li><h3 id="web-cache-也就是代理服务器"><a href="#web-cache-也就是代理服务器" class="headerlink" title="web cache 也就是代理服务器"></a>web cache 也就是代理服务器</h3><ul>
<li>作为缓存 既面向用户浏览器作为服务端 也向原始服务器请求作为客户端</li>
<li>大大减低相应时间 的一种方案</li>
<li>not modified 报文段 解决更新问题</li>
</ul>
</li>
<li><h3 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS 域名解析系统"></a><font color=pink>DNS 域名解析系统</font></h3><ul>
<li>应用层协议 也是一个分布式数据库 53 端口号</li>
<li>大致工作情景就是当我使用浏览器请求文件时 浏览器从请求报文中url抽取主机名传送给我们的主机上运行的dns客户端 最后经过服务端传来一个回答报文</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong><font color=pink>之前困扰我的一个问题 为什么有时候有www 有时候域名又没有www <a class="link"   href="https://www.nexcess.net/blog/is-there-any-reason-to-use-www-in-your-domain/" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></strong></em></p>
</li>
<li><p><em><strong>还有就是域名和主机名是不一样的</strong></em></p>
<ul>
<li>一般来说域名就是一个裸的</li>
<li>而主机名会在域名加一些前缀 能够唯一标识一台对应功能的机器</li>
</ul>
</li>
</ul>
<blockquote>
<p>目前所需差不多就是这样 现在暂时结束 10.10</p>
</blockquote>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TLCL</title>
    <url>/2023/05/06/TLCL/</url>
    <content><![CDATA[<h1 id="TLCL"><a href="#TLCL" class="headerlink" title="TLCL"></a>TLCL</h1><ul>
<li><h2 id="Why-Linux？"><a href="#Why-Linux？" class="headerlink" title="Why Linux？"></a><strong>Why Linux？</strong></h2><ul>
<li><h3 id="linux-人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！"><a href="#linux-人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！" class="headerlink" title="linux 人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！"></a>linux 人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！</h3></li>
<li><h3 id="shell-解释-是kernel-outermost-layer-os向用户提供的一个interface有两种类型的，一种是CLS-cmdline形式的-而对应的有相关的scriped-language-例如bash-还有就是xwindows-驱动的GUI"><a href="#shell-解释-是kernel-outermost-layer-os向用户提供的一个interface有两种类型的，一种是CLS-cmdline形式的-而对应的有相关的scriped-language-例如bash-还有就是xwindows-驱动的GUI" class="headerlink" title="shell 解释 是kernel outermost layer os向用户提供的一个interface有两种类型的，一种是CLS cmdline形式的 而对应的有相关的scriped language 例如bash 还有就是xwindows 驱动的GUI"></a>shell 解释 是kernel outermost layer os向用户提供的一个interface有两种类型的，一种是CLS cmdline形式的 而对应的有相关的scriped language 例如bash 还有就是xwindows 驱动的GUI</h3></li>
</ul>
</li>
<li><p>贴个网址 <a class="link"   href="http://billie66.github.io/TLCL/book/index.html" >TLCL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><a class="link"   href="http://www.gnu.org/software/bash/manual/bashref.html" >bash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li></li>
<li><h2 id="alt-left-arrow-is-black-to-last-page-return-and-ctrl-1-2-3-is-switch-between-different-tabs-good-final-got-some-more-ctrl-T-new-tab-and-ctrl-n-new-windows-ctrl-shift-n-new-inrecognized-windows-AND-TYPE-THE-ALT-YOU-CAN-GO-THE-UPPERRIGHT-CORNER-AND-USE-YOUR-UP-DOWN-RIGHT-LEFT-KEY-TO-CHOOSE-右上防三个原点-点一次-alt就够了-another-smooth-command-use-the-x2F-to-goto-the-search-box"><a href="#alt-left-arrow-is-black-to-last-page-return-and-ctrl-1-2-3-is-switch-between-different-tabs-good-final-got-some-more-ctrl-T-new-tab-and-ctrl-n-new-windows-ctrl-shift-n-new-inrecognized-windows-AND-TYPE-THE-ALT-YOU-CAN-GO-THE-UPPERRIGHT-CORNER-AND-USE-YOUR-UP-DOWN-RIGHT-LEFT-KEY-TO-CHOOSE-右上防三个原点-点一次-alt就够了-another-smooth-command-use-the-x2F-to-goto-the-search-box" class="headerlink" title="alt + left arrow is black to last page return  and ctrl + 1  2  3 is switch between different tabs  good final got some more ctrl + T new tab and ctrl + n new windows ctrl +shift +n new inrecognized windows AND TYPE THE ALT YOU CAN GO THE UPPERRIGHT CORNER AND USE YOUR UP DOWN RIGHT LEFT KEY TO CHOOSE 右上防三个原点 点一次 alt就够了    another smooth command  use the &#x2F; to goto the search box!!!!!"></a><em><strong><font color = pink>alt + left arrow is black to last page return  and ctrl + 1  2  3 is switch between different tabs  good final got some more ctrl + T new tab and ctrl + n new windows ctrl +shift +n new inrecognized windows AND TYPE THE ALT YOU CAN GO THE UPPERRIGHT CORNER AND USE YOUR UP DOWN RIGHT LEFT KEY TO CHOOSE 右上防三个原点 点一次 alt就够了    another smooth command  use the &#x2F; to goto the search box!!!!!</font></strong></em></h2></li>
<li><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><ul>
<li><h4 id="shift-ctrl-6-切出wsl"><a href="#shift-ctrl-6-切出wsl" class="headerlink" title="shift+ctrl+6 切出wsl"></a>shift+ctrl+6 切出wsl</h4></li>
<li><h4 id="winter——主机名，SPIKE——用户名"><a href="#winter——主机名，SPIKE——用户名" class="headerlink" title="winter——主机名，SPIKE——用户名"></a>winter——主机名，SPIKE——用户名</h4></li>
<li><h4 id="date-时间-calendar-日历"><a href="#date-时间-calendar-日历" class="headerlink" title="date 时间 calendar 日历"></a>date 时间 calendar 日历</h4></li>
<li><h4 id="ls-symbolized-stand-for-the-user-directory-ls-could-specify-the-dr-you-wanna-check"><a href="#ls-symbolized-stand-for-the-user-directory-ls-could-specify-the-dr-you-wanna-check" class="headerlink" title="ls ~ ~ symbolized stand for the user directory ls could specify the dr you wanna check."></a>ls ~ ~ symbolized stand for the user directory ls could specify the dr you wanna check.</h4></li>
<li><h4 id="we-could-add-some-format-cmd-to-reveal-more-details-ls-l"><a href="#we-could-add-some-format-cmd-to-reveal-more-details-ls-l" class="headerlink" title="we could add some format cmd to reveal more details ls -l"></a>we could add some format cmd to reveal more details ls -l</h4></li>
<li><h4 id="the-meaning-of-the-long-format-indicate-the-file-type-and-then-the-next-three-letters-indicates-the-access-rights-and-then"><a href="#the-meaning-of-the-long-format-indicate-the-file-type-and-then-the-next-three-letters-indicates-the-access-rights-and-then" class="headerlink" title="the meaning of the long format - indicate the file type and  then the next three letters indicates the access rights and then"></a>the meaning of the long format - indicate the file type and  then the next three letters indicates the access rights and then</h4></li>
<li><h4 id="f11-keystroke-could-full-screenize-the-console"><a href="#f11-keystroke-could-full-screenize-the-console" class="headerlink" title="f11 keystroke could full-screenize the console"></a>f11 keystroke could full-screenize the console</h4></li>
<li><h4 id="file-check-the-brief-info-of-a-file"><a href="#file-check-the-brief-info-of-a-file" class="headerlink" title="file check the brief info of a file"></a>file check the brief info of a file</h4></li>
<li><h4 id="everything-is-file-and-mostly-the-text-file-only-contain-ascii-code"><a href="#everything-is-file-and-mostly-the-text-file-only-contain-ascii-code" class="headerlink" title="everything is file and mostly the text file only contain ascii code"></a>everything is file and mostly the text file only contain ascii code</h4></li>
<li><h4 id="configuration-file-or-the-actually-source-file-most-stored-in-text-file-format"><a href="#configuration-file-or-the-actually-source-file-most-stored-in-text-file-format" class="headerlink" title="configuration file or the actually source file most stored in text file format"></a>configuration file or the actually source file most stored in text file format</h4></li>
<li><h4 id="less-less-is-more-and-the-up-down-arrow-q-h-n-some-key-cmd-you-should-know"><a href="#less-less-is-more-and-the-up-down-arrow-q-h-n-some-key-cmd-you-should-know" class="headerlink" title="less less is more and the up down arrow q h n some key cmd you should know"></a>less less is more and the up down arrow q h n some key cmd you should know</h4></li>
<li><h4 id="there-are-some-standard-pathname-in-unix-like-system-just-feel-free-to-explore-and-dont-mind-we-could-hardly-mess-up-for-the-administrator-keep-everything-in-order"><a href="#there-are-some-standard-pathname-in-unix-like-system-just-feel-free-to-explore-and-dont-mind-we-could-hardly-mess-up-for-the-administrator-keep-everything-in-order" class="headerlink" title="there are some standard pathname in unix-like system just feel free to explore , and dont mind ,we could hardly mess up for the administrator keep everything in order"></a>there are some standard pathname in unix-like system just feel free to explore , and dont mind ,we could hardly mess up for the administrator keep everything in order</h4></li>
<li><h4 id="wildcard-just-the-regular-expression-also-grep"><a href="#wildcard-just-the-regular-expression-also-grep" class="headerlink" title="wildcard just the regular expression also grep"></a>wildcard just the regular expression also grep</h4><ul>
<li>* mean the any chars ? one single char [set] [!set] [[:key:word​]]</li>
</ul>
</li>
<li><h4 id="mkdir-dirc-and-…-eg-mkdir-dir1-dir2-dir3"><a href="#mkdir-dirc-and-…-eg-mkdir-dir1-dir2-dir3" class="headerlink" title="mkdir dirc and … eg mkdir dir1 dir2 dir3"></a>mkdir dirc and … eg mkdir dir1 dir2 dir3</h4></li>
<li><h4 id="cp-mv-rm-like-the-copy-paste-and-cut-delete-in-windows"><a href="#cp-mv-rm-like-the-copy-paste-and-cut-delete-in-windows" class="headerlink" title="cp mv rm like the copy paste and cut delete in windows"></a>cp mv rm like the copy paste and cut delete in windows</h4><ul>
<li>when you want to handle a directory you need to use option -r recrusive</li>
<li><font color=aqua>Be careful with the combo of wildcard and rm so just invoke the ls first to check if the files listed are u really wanna remove no more change to restore the files</font></li>
<li><font color=gold>use the . to indicate the workplace </font></li>
<li><em>if you wanna some warning remeber to use op -i</em></li>
<li><strong>mv is rename also the same time if the file2 exists then is act like move ifnot then like the rename</strong></li>
</ul>
</li>
<li><h4 id="the-x2F-etc-is-text-configured-file-and-the-bin-is-usually-executable-and-x2F-usr-x2F-is-the-largest-folder-in-linux"><a href="#the-x2F-etc-is-text-configured-file-and-the-bin-is-usually-executable-and-x2F-usr-x2F-is-the-largest-folder-in-linux" class="headerlink" title="the &#x2F;etc is text configured file and the bin is usually executable and &#x2F;usr&#x2F; is the largest folder in linux"></a><font color=seagreen>the &#x2F;etc is text configured file and the bin is usually executable and &#x2F;usr&#x2F; is the largest folder in linux</font></h4></li>
<li><p><strong>这个ln 指令 ln -s 创建符号连接 有一点像windows的快捷方式 ln创建的是硬的链接 早期 智能文件 不能目录</strong></p>
</li>
<li><p><em><strong><font color =purple>What is cmd a new set of useful cmds</font></strong></em></p>
<ul>
<li><em><strong>所以命令的本质 有 一个可执行的二进制c函数  2shell python ruby脚本程序 3 shell内置 builtins 4 shell小函数 5 别名</strong></em></li>
<li><em><strong>use the type cmd to check the type of one cmd type [cmd]</strong></em></li>
<li><em><strong>which to check which is the cmd only used for the binary cmd</strong></em></li>
<li><em><strong>help cmd  used for the buildins cmd –help the same</strong></em></li>
<li><em><strong>man ls  use the manual very simple but difficult to read</strong></em></li>
<li><em><strong>apropos + cmd check the tips 挺有用的 apropos vim</strong></em></li>
<li><em><strong>info 一个更友好的 提示 有超链接</strong></em><ul>
<li>n 下一个超链接结点 p 上一个 u当前结点菜单 enter进入</li>
</ul>
</li>
<li><em><strong>zless 可以查看 .gz文件</strong></em></li>
<li><em><strong>whatis 一个简单的描述</strong></em></li>
</ul>
</li>
<li><p><em><strong><font color = pink>可以一行多个命令 用；隔开</font></strong></em></p>
</li>
<li><p><em><strong><font color=pink>alias 在自己命名之前先使用 type查看一下是否已经是已存在的命令 unalias 取消别名</font></strong></em></p>
</li>
<li><p><em><strong><font color =yellow>Evrything is a  file</font></strong></em></p>
</li>
<li><p><em><strong>&gt; 重定向 标准输入输出 错误  &gt; 改变标准输出 注意因此 每一次使用时都会使文件重写</strong></em></p>
</li>
<li><p><strong><font color=red>&gt; 从头开始 &gt;&gt; append  file discripitor 文件描述符 0 1 2 2&gt; 表示方法</font></strong></p>
</li>
<li><p><em><strong><font color=pink>新的方法来同时重定向我们的标准输入与输出&amp;&gt;     dev&#x2F;null 一个没用的数据桶 可以用作丢弃一些不用的显示信息</font></strong></em></p>
</li>
<li><p><em><strong><font color =pink> cat 与standard input 有关 cat 单独就是echo ctrl+z强制退出运行 ctrl+d EOF</font></strong></em></p>
</li>
<li><p><em><strong><font color=blue>ctrl+d 是 EOF</font></strong></em></p>
</li>
<li><p><em><strong><font color=red>| pipeline cmd1|cmd2 将1中的标准输出作为二中的标准输入    cat No?.txt &gt; poem.txt 连续连接文件的例子</font></strong></em></p>
</li>
<li><p>***filter 过滤器 ls -l &#x2F;usr&#x2F;bin &#x2F;bin | sort |uniq [-d看见重复内容]| less ***</p>
</li>
<li><p><em><strong><font color=pink>注意上面几个指令在无参数情况下都是默认接受标准输入 所以 可以使用管道符 很方便  wc 计数</font></strong></em></p>
</li>
<li><p><font color=pink>快乐的echo cmd  is special when use the echo it will do some process called expansion   obviously  when you see the echo it just mean use the regular expression </font></p>
<ul>
<li>***~ echo ~ 显示当前的目录 echo $((expr)) 进行幂展开 ***</li>
<li><em><strong>花括号展开 可以展开字符串表达式</strong></em></li>
<li><em><strong><font color=red>Parameter expansion 参数展开 very important echo $USER 就像这样  一个查看变量的命令 printenv | less</font></strong></em></li>
<li><em><strong><font color=red>command substitution use $(cmd) eg ls -l $(which cp)     file $(ls &#x2F;usr&#x2F;bin&#x2F;* | grep zip) 旧标准中有一个<code>which cp</code>可以代替 $()</font></strong></em></li>
<li><em><strong><font color=red>“”  sleep 单引号 echo -e $转义字符</font></strong></em></li>
<li><em><strong><font color=red>ctrl l     ctrl d   ctrl t  alt u alt l alt t alt f alt b</font></strong></em></li>
<li><em><strong><font color=red>tab alt ？ alt * ctrl k ctrl y set | less TLDR</font></strong></em></li>
</ul>
</li>
<li><h4 id="代表的是父文件-代表当前的工作文件"><a href="#代表的是父文件-代表当前的工作文件" class="headerlink" title=".. 代表的是父文件 . 代表当前的工作文件"></a>.. 代表的是父文件 . 代表当前的工作文件</h4></li>
<li><h4 id="dr-磁盘空间情况-free-内存空间情况"><a href="#dr-磁盘空间情况-free-内存空间情况" class="headerlink" title="dr 磁盘空间情况 free 内存空间情况"></a>dr 磁盘空间情况 free 内存空间情况</h4></li>
<li><h4 id="exit-退出程序"><a href="#exit-退出程序" class="headerlink" title="exit 退出程序"></a>exit 退出程序</h4></li>
<li><h4 id="ls-most-used-cmd-in-shell"><a href="#ls-most-used-cmd-in-shell" class="headerlink" title="ls most used cmd in shell"></a>ls most used cmd in shell</h4></li>
<li><h4 id="用户-superuser-rootuser"><a href="#用户-superuser-rootuser" class="headerlink" title="$ 用户     # superuser rootuser"></a>$ 用户     # superuser rootuser</h4></li>
<li><h4 id="file-navigation·"><a href="#file-navigation·" class="headerlink" title="file navigation·"></a>file navigation·</h4><ul>
<li><h5 id="pwd-print-name-of-workplace-directory"><a href="#pwd-print-name-of-workplace-directory" class="headerlink" title="pwd print name of workplace directory"></a>pwd print name of workplace directory</h5></li>
<li><h5 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd  change directory"></a>cd  change directory</h5></li>
<li><h5 id="ls-list-contents"><a href="#ls-list-contents" class="headerlink" title="ls list contents"></a>ls list contents</h5></li>
<li><h5 id="我们都处于-文件中间-home-通常初始-时-文件树-只有一棵-对于普通用户只有-user里具有写权限-其余需要-root"><a href="#我们都处于-文件中间-home-通常初始-时-文件树-只有一棵-对于普通用户只有-user里具有写权限-其余需要-root" class="headerlink" title="我们都处于 文件中间 home 通常初始 时 文件树 只有一棵 对于普通用户只有 user里具有写权限 其余需要 root"></a>我们都处于 文件中间 home 通常初始 时 文件树 只有一棵 对于普通用户只有 user里具有写权限 其余需要 root</h5></li>
<li><h5 id="absolute-pathname-relative-pathname"><a href="#absolute-pathname-relative-pathname" class="headerlink" title="absolute pathname relative pathname"></a>absolute pathname relative pathname</h5><ul>
<li>&#x2F; 根目录     .. &#x2F; 父目录 	.&#x2F;	当前工作目录 通常默认有这</li>
</ul>
<p>	</p>
</li>
<li><h4 id="cd-pathname"><a href="#cd-pathname" class="headerlink" title="cd + pathname"></a>cd + pathname</h4><ul>
<li>cd   或者是 cd ~默认进入用户文件夹</li>
</ul>
</li>
<li><p>cd ~user_name 进入对应名字 的用户文件夹</p>
<ul>
<li>cd - 回到先前 的文件夹</li>
</ul>
</li>
<li><p>cd .. 回到父文件</p>
</li>
</ul>
</li>
<li><h4 id="开头的文件夹-通常是不显示的-隐藏的-注入configuration-类的文件"><a href="#开头的文件夹-通常是不显示的-隐藏的-注入configuration-类的文件" class="headerlink" title=". 开头的文件夹 通常是不显示的 隐藏的 注入configuration 类的文件"></a>. 开头的文件夹 通常是不显示的 隐藏的 注入configuration 类的文件</h4></li>
</ul>
</li>
<li><h4 id="用-代替文件名-中的空格"><a href="#用-代替文件名-中的空格" class="headerlink" title="用 . _ - 代替文件名 中的空格"></a>用 . _ - 代替文件名 中的空格</h4></li>
<li><h4 id="支持-鼠标中间-paste-双击-copy-或者-选择-copy"><a href="#支持-鼠标中间-paste-双击-copy-或者-选择-copy" class="headerlink" title="支持 鼠标中间 paste 双击 copy 或者 选择 copy"></a>支持 鼠标中间 paste 双击 copy 或者 选择 copy</h4><ul>
<li><h4 id="上下键-寻找历史命令最大500个"><a href="#上下键-寻找历史命令最大500个" class="headerlink" title="上下键 寻找历史命令最大500个"></a>上下键 寻找历史命令最大500个</h4></li>
<li><h4 id="ls指令再探dd"><a href="#ls指令再探dd" class="headerlink" title="ls指令再探dd"></a>ls指令再探dd</h4><ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/lin.png"
                     
                ></p>
</li>
<li><h5 id="short-option-l-一个字母-可以组合-lt"><a href="#short-option-l-一个字母-可以组合-lt" class="headerlink" title="short option  -l 一个字母 可以组合 -lt"></a>short option  -l 一个字母 可以组合 -lt</h5></li>
</ul>
</li>
<li><h5 id="long-option-–reverse-全称"><a href="#long-option-–reverse-全称" class="headerlink" title="long option –reverse  全称"></a>long option –reverse  全称</h5></li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/_1.png"
                     
                ></p>
</li>
</ul>
</li>
<li><h3 id="其实无论怎样都可以-command-–help-查看更多"><a href="#其实无论怎样都可以-command-–help-查看更多" class="headerlink" title="其实无论怎样都可以 command –help 查看更多"></a><font color=gold>其实无论怎样都可以 command –help 查看更多</font></h3></li>
<li><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><ul>
<li>查询文件 类型 file + filename</li>
</ul>
</li>
<li><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><ul>
<li><h4 id="less-查看文本文件-everything-is-file"><a href="#less-查看文本文件-everything-is-file" class="headerlink" title="less 查看文本文件 everything is file"></a>less 查看文本文件 everything is file</h4></li>
<li><h4 id="ascII-as-key"><a href="#ascII-as-key" class="headerlink" title="ascII as-key"></a>ascII as-key</h4><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/less.png"
                     
                ></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="键盘高级操作"><a href="#键盘高级操作" class="headerlink" title="键盘高级操作"></a>键盘高级操作</h4><ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cl.png"
                     
                ></p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cl1.png"
                     
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cl2.png"
                     
                ></li>
</ul>
</li>
<li><h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><ul>
<li>tab  单击</li>
<li>Alt + ? 显示可能的补全列表</li>
<li>Alt + * 插入所有可能的补全操作</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/his.png"
                     
                ></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake</title>
    <url>/2023/09/12/Cmake/</url>
    <content><![CDATA[<h2 id="可以开始了解CMake"><a href="#可以开始了解CMake" class="headerlink" title="可以开始了解CMake"></a>可以开始了解CMake</h2><p><em><strong>只是简单得贴一个网址</strong></em></p>
<p><em><strong>[CMAKE](<a class="link"   href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html" >CMake Tutorial — CMake 3.27.4 Documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</strong></em></p>
<p><em><strong><a class="link"   href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/" >CPPformal <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></p>
<p><a class="link"   href="https://github.com/nlohmann/json" >json <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>[redfiredoc](<a class="link"   href="https://redefine-docs.ohevan.com/getting-started" >快速开始 - Redefine Docs (ohevan.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>
<p>Cmake</p>
<ul>
<li><font color=salmon>需要设置最小要求版本</font></li>
<li><font color=salmon>一个术语  source of truth 就是可以用来指一个权威数据来源 大概就是一些重要常量或者是预定义宏 </font></li>
<li><font color=salmon></font></li>
<li><font color=salmon></font></li>
<li><font color=salmon></font></li>
<li><font color=salmon></font></li>
<li><font color=salmon></font></li>
</ul>
<h2 id="C-review-with-the-tinyrender"><a href="#C-review-with-the-tinyrender" class="headerlink" title="C++ review with the tinyrender"></a><font color=teal>C++ review with the tinyrender</font></h2><ul>
<li><h3 id="Oriented-object-programming"><a href="#Oriented-object-programming" class="headerlink" title="Oriented-object programming"></a><strong><font color=pink>Oriented-object programming</font></strong></h3><ul>
<li><p><strong><font color=pink>用户。类的用户就是使用类的程序(员)。这是通常情况。与程序的用户不一样。</font></strong></p>
</li>
<li><p><strong><font color=pink>inline 最好写在外面的定义处</font></strong></p>
</li>
<li><p><strong><font color=pink>mutable 可变数据成员 永远可以改变 具体例子就是外面想要设计一个计数器来统计这个类的实例次数 无论是作为const还是非const都要计数</font></strong></p>
</li>
<li><p><strong><font color=pink>类内初始化只能用花括号和等号 这里区分下圆括号和花括号 两者本身都是一样的调用构造函数只是有些区别 一花括号不允许隐式转换；二花括号才能用在类内三花括号才能默认构造函数</font></strong></p>
</li>
<li><p><strong><font color=pink>const成员重载 显然只用底层const才能重载通常会借用一个共有的const功能函数</font></strong></p>
</li>
<li><p><strong><font color=pink>尽量多些工厂函数</font></strong></p>
</li>
<li><p><strong><font color=pink>友元类，类中所有的函数都可以访问原来的函数的所有成员</font></strong></p>
</li>
<li><p><strong><font color=pink>volatlile 就是告诉编译器不能优化的意思。基本语法限制和const完全一样。也存在底层顶层，也存在数组对象。两者可以同时叠加的。</font></strong></p>
</li>
<li><p><strong><font color=pink>constexpr 由数据类型和初始值同时决定。const 字面量。关键判断就是能不能在编译的时候就知道是不是能求值。constexpr 函数</font></strong></p>
</li>
<li><p><strong><font color=pink>默认形参永远符合位置解析。所以需要进行覆盖的话必须要满足位置。这是一个比较大的限制，默认形参声明在函数声明里面，并且函数可以多次声明，对于已经声明过默认形参的形参，下一次声明时，直接省略就好，不能重复声明。在定义函数的时候也可以写默认形参，但是依然不能重写已经存在的。同时默认形参的初始值，可以是除了局部变量外的所有值，求值发生在运行阶段</font></strong></p>
</li>
<li><p>**<font color=pink>字面值类型——算术，指针，引用&#x2F;  而io 类之类就不是字面值类型。 constexpr 函数形参返回值都是字面值类型。同时有且只有一个return 语句在函数体里面 函数调用的时候编译器会将此类函数转换为对应字面值。同时返回的表达式不一定是常量。看函数调用情况。 constexpr int scale(int size){return new_fun()<em>size} 假如new 是一个constexpr func 若size是常量返回就是常量表达式</font></em>*</p>
</li>
<li><p><strong><font color=pink>函数参数传递，理解的关键就是要知道形参对象和局部变量一样都会申请堆的空间然后自动销毁。所以就明白了引用传参和拷贝传参。传参相当于初始化。初始化const当然是不是const都无所谓 重载的时候 顶层是无法区分形参的，因为适用的参数都相同，所以不能区分重载。只有底层才能重载，因为此时的 const不能转换为其他类型。</font></strong></p>
</li>
<li><p><strong><font color=pink>只有const_cast&lt;T*&gt; 可以改变，同时也只能改变变量的底层const 属性</font></strong></p>
</li>
<li><p><strong><font color=pink>函数定义中没有命名的参数，其实可以有，只要函数体没有使用就可以的。例如 ++ 运算符的使用情况。static_cast 本质就是覆盖编译器的类型检查，因为大多数类型检查都是根据静态类型进行的</font></strong></p>
</li>
<li><p><strong><font color=pink>位域 不能取地址的，通常定义为无符号类型 只能整型和枚举类型 通常包含一些二进制运算和枚举常量枚举类似于 类 有class就是限定作用域的 没class就是不限定 同时可以同时定义对象变量 类似class  const对象必须定义时候初始化 枚举看似不用的原因是不提供初始值的情况下是从0开始的</font></strong></p>
</li>
<li><p><strong><font color=pink>对于多重继承首先，用虚继承解决菱形继承问题。然后对于虚继承只会改变派生类的派生类的情况。并且在构造的时候顺序是按照派生列表顺序找到所有的虚基类然后按同样顺序初始化所有的非虚基类。默认的是默认构造函数，所以要保证默认构造函数存在。派生列表不允许多次出现同一个基类，但是实际继承没有什么限制，但是虚基类的问题只在继承时有关系，对于类中存在的变量不会有关系！！</font></strong></p>
</li>
<li><p><strong><font color=pink></font></strong></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP</title>
    <url>/2023/09/16/CSAPP/</url>
    <content><![CDATA[<ul>
<li><h2 id="CSAPP"><a href="#CSAPP" class="headerlink" title="CSAPP"></a>CSAPP</h2><ul>
<li><h3 id="terms-colletion"><a href="#terms-colletion" class="headerlink" title="terms colletion"></a>terms colletion</h3><ul>
<li>snippet re-useble code part maybe name the directory</li>
</ul>
</li>
<li><h3 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h3><ul>
<li>to long didn’t read and a linux simplified manual cm</li>
</ul>
</li>
<li><p><a href="/doc/normal.pdf">Try</a></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>TGA_CXX</title>
    <url>/2023/09/22/TGA-CXX/</url>
    <content><![CDATA[<h3 id="TGA关于c"><a href="#TGA关于c" class="headerlink" title="TGA关于c++"></a><font color=seablue>TGA关于c++</font></h3><ul>
<li><h4 id="C-操作文件-这里记录一些相关要用的知识点-便于统一看"><a href="#C-操作文件-这里记录一些相关要用的知识点-便于统一看" class="headerlink" title="C++操作文件 这里记录一些相关要用的知识点 便于统一看"></a>C++操作文件 这里记录一些相关要用的知识点 便于统一看</h4><ul>
<li>**流访问，有open std::ios::binary ,.good(),.get(),.read()的一些参数 **</li>
<li><strong>重载函数规范有点忘记。</strong></li>
<li><strong>copy (stored data) to a different location, especially so as to protect against loss.  <font color=gold>dump in computer mean</font></strong></li>
<li><strong>ESCAPE SYMBOL 溢出符号</strong></li>
<li><strong><font color=seagreen>Run-length encode a lossless encode method  just to replace the runS(many values occurs consecutivelt) w12b2cd13e32 .eg</font></strong></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/const.png"
                      alt="const只是语法检查 所以地址转换是一个编程漏洞"
                ></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>CXX</tag>
      </tags>
  </entry>
  <entry>
    <title>TLCL@2</title>
    <url>/2023/09/30/TLCL-2/</url>
    <content><![CDATA[<h2 id="TLCL"><a href="#TLCL" class="headerlink" title="TLCL"></a>TLCL</h2><blockquote>
<p>新的开始 </p>
</blockquote>
<h4 id="今天怒创了两个用户-密码都是老密码alt-t-google-translate-x2F-the-search-box-alt-left-ctrl-shift-aalt-左右键是返回上一个页面-ctrl-tab-下一个标签-ctrl-shift-tab-上一个"><a href="#今天怒创了两个用户-密码都是老密码alt-t-google-translate-x2F-the-search-box-alt-left-ctrl-shift-aalt-左右键是返回上一个页面-ctrl-tab-下一个标签-ctrl-shift-tab-上一个" class="headerlink" title="今天怒创了两个用户 密码都是老密码alt t google translate &#x2F; the search box alt left   ctrl shift aalt 左右键是返回上一个页面 ctrl tab 下一个标签 ctrl shift tab 上一个 "></a><font color=aqua>今天怒创了两个用户 密码都是老密码<br>alt t google translate &#x2F; the search box alt left   ctrl shift a<br>alt 左右键是返回上一个页面 ctrl tab 下一个标签 ctrl shift tab 上一个 </font></h4><h3 id="发现两个有用的东西-google搜索栏使用小数字键盘的上下键可以查看推荐搜索-然后就是cmd中打开md-x2F-example-md-键入就可以-原来要运行可运行文件要在前面加上一个-x2F"><a href="#发现两个有用的东西-google搜索栏使用小数字键盘的上下键可以查看推荐搜索-然后就是cmd中打开md-x2F-example-md-键入就可以-原来要运行可运行文件要在前面加上一个-x2F" class="headerlink" title="发现两个有用的东西 google搜索栏使用小数字键盘的上下键可以查看推荐搜索 然后就是cmd中打开md .&#x2F;example.md 键入就可以 原来要运行可运行文件要在前面加上一个.&#x2F;"></a><font color=pink>发现两个有用的东西 google搜索栏使用小数字键盘的上下键可以查看推荐搜索 然后就是cmd中打开md .&#x2F;example.md 键入就可以 原来要运行可运行文件要在前面加上一个.&#x2F;</font></h3><h4 id="command-syntaxsyntax2syntax3q-amp-a"><a href="#command-syntaxsyntax2syntax3q-amp-a" class="headerlink" title="command syntaxsyntax2syntax3q&amp;a"></a><font color=seagreen><a class="link"   href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key" >command syntax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="http://docopt.org/" >syntax2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_01" >syntax3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://stackoverflow.com/questions/9725675/is-there-a-standard-format-for-command-line-shell-help-text" >q&amp;a <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></h4><h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/history.png"
                      title="历史的操作"
                ></p>
<ul>
<li><h3 id="历史操作"><a href="#历史操作" class="headerlink" title="历史操作"></a>历史操作</h3><ul>
<li><em><strong>history 操作，history | less |grep tldr</strong></em></li>
</ul>
</li>
<li><h3 id="权限security"><a href="#权限security" class="headerlink" title="权限security"></a>权限security</h3><ul>
<li><em><strong>change the mode chmod cmd 改变rwx属性可以使用八进制数字来表示也可以用字符 <font color=red><a class="link"   href="http://billie66.github.io/TLCL/book/chap10.html" >chmod <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></strong></em></li>
<li><em><strong>su and sudo su 就是以另一个身份运行shell 而sudo是以另一个身份执行命令 最大的区别是su会重建一个设立了环境 而sudo不会</strong></em></li>
<li><em><strong>chown 改变用户权限 目前使用不是很多</strong></em></li>
<li><em><strong>passwd 命令用作更改i密码</strong></em></li>
<li><em><strong><font color=pink>good in wsl2 额可以touch 创建文件 同时可以code 编辑code似乎有许多有趣的指令</font></strong></em></li>
<li><em><strong><font color=red>想要切换用户 也就是一个全新的bash的话 用 su -l doudou .eg 退出的时候使用 exit就可以了</font></strong></em></li>
<li><em><strong><font color=blue>至于使用创建用户的命令就是adduser name 注意名字不能以大写字母开头 doudou</font></strong></em></li>
</ul>
</li>
<li><h3 id="核心概念-Process-进程link"><a href="#核心概念-Process-进程link" class="headerlink" title="核心概念 Process 进程link"></a>核心概念 Process 进程<a class="link"   href="http://billie66.github.io/TLCL/book/chap11.html" >link <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul>
<li><em><strong>init kernel进行run&#x2F;etc里的script所以为什么可以更改的原因</strong></em></li>
<li><strong>ctrl + c 强制返回的一种方法</strong></li>
<li><em><strong><font color=pink>&#x2F;proc    &#x2F;sys 文件系统 可以查看相关硬件划分信息</font><br>备份文件的名字无关紧要，只要选择一个容易理解的文件名。扩展名 “.bak”、”.sav”、 “.old”和 “.orig” 都是用来指示备份文件的流行方法。哦，记住 cp 命令会默默地覆盖已经存在的同名文件。  bak stand for backup file</strong></em></li>
</ul>
</li>
<li><h3 id="Nano与其他文本编辑器"><a href="#Nano与其他文本编辑器" class="headerlink" title="Nano与其他文本编辑器"></a>Nano与其他<a class="link"   href="http://billie66.github.io/TLCL/book/chap12.html" >文本编辑器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul>
<li><em><strong><font color=pink>之前学的很多bash的指令到很多编辑器里都是一样的</font></strong></em></li>
<li><em><strong><font color=pink>source .bashrc 生效指令</font></strong></em></li>
<li><em><strong><font color=pink>ctrl o in nano 保存</font></strong></em></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>signature</title>
    <url>/2023/10/02/signature/</url>
    <content><![CDATA[<h2 id="ps了一个签名方便以后用"><a href="#ps了一个签名方便以后用" class="headerlink" title="ps了一个签名方便以后用"></a><font color=pink>ps了一个签名方便以后用</font></h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%AD%BE%E5%90%8D.png"
                      alt="我的签名"
                ></p>
<blockquote>
<p>你别说有点书法的感觉 哈哈哈哈哈！</p>
</blockquote>
<h3 id="还是应该记录下方法-ps-魔棒选择-每次扣几笔然后ctrl-c-ctrlv-复制一个图层-最后合并可见图层"><a href="#还是应该记录下方法-ps-魔棒选择-每次扣几笔然后ctrl-c-ctrlv-复制一个图层-最后合并可见图层" class="headerlink" title="还是应该记录下方法 ps 魔棒选择 每次扣几笔然后ctrl c ctrlv 复制一个图层 最后合并可见图层"></a><font color=pink>还是应该记录下方法 ps 魔棒选择 每次扣几笔然后ctrl c ctrlv 复制一个图层 最后合并可见图层</font></h3>]]></content>
      <tags>
        <tag>signature</tag>
      </tags>
  </entry>
  <entry>
    <title>TLCL@3</title>
    <url>/2023/10/04/TLCL-3/</url>
    <content><![CDATA[<h2 id="TLCL-chapter-3"><a href="#TLCL-chapter-3" class="headerlink" title="TLCL chapter 3"></a>TLCL chapter 3</h2><h3 id="GOOOOOOOOOOOOOOD-解决了上传静态文件的-问题-在markdown里面变成-download-images-file-normal-pdf"><a href="#GOOOOOOOOOOOOOOD-解决了上传静态文件的-问题-在markdown里面变成-download-images-file-normal-pdf" class="headerlink" title="GOOOOOOOOOOOOOOD 解决了上传静态文件的 问题 在markdown里面变成 [download](\..\images\file\normal.pdf)"></a><font color=pink>GOOOOOOOOOOOOOOD 解决了上传静态文件的 问题 在markdown里面变成 [download](\..\images\file\normal.pdf)</font></h3><ul>
<li><h3 id="发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记"><a href="#发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记" class="headerlink" title="发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记"></a><font color=aqua>发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记</font></h3></li>
<li><p>#<font color=yellow>我是真的有病 注意更改 .bashrc 文件之前要保存一下原有配置</font></p>
</li>
<li><h2 id="Cmake-and-Makefile"><a href="#Cmake-and-Makefile" class="headerlink" title="Cmake and Makefile"></a><font color=salmon>Cmake and Makefile</font></h2><ul>
<li>export PATH&#x3D;”$PATH:&#x2F;usr&#x2F;bin”	注意规范 前面没有$</li>
</ul>
</li>
<li><h3 id="文件操作here"><a href="#文件操作here" class="headerlink" title="文件操作here"></a>文件操作<a class="link"   href="http://billie66.github.io/TLCL/book/chap16.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul>
<li>设计很多底层硬件，由于wsl与虚拟机文件差别较大暂时skip read</li>
</ul>
</li>
<li><h3 id="网络葵花宝典下载"><a href="#网络葵花宝典下载" class="headerlink" title="网络葵花宝典下载"></a>网络<a href="/doc/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.pdf">葵花宝典下载</a></h3><ul>
<li>netstat 指令</li>
<li>ftp指令</li>
<li>telnet指令 都是可以直接使用相关协议</li>
<li>ftp lftp都可以下载文件</li>
<li><em><strong><font color=pink>wget指令直接下载界面 可行男泵</font></strong></em></li>
</ul>
</li>
<li><h3 id="SSH-secure-shell"><a href="#SSH-secure-shell" class="headerlink" title="SSH secure shell"></a>SSH secure shell</h3><ul>
<li><strong>这是一个协议 port number22</strong></li>
<li><strong><a class="link"   href="https://phoenixnap.com/kb/ssh-to-connect-to-remote-server-linux-or-windows#:~:text=Open%20the%20terminal%20on%20the,ssh%20localhost%20and%20hit%20enter." >一个sshlocalhost教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></li>
<li><strong>最近ssh遇到很多问题这里集中总结一下</strong><ul>
<li><strong>关于启动服务器<a class="link"   href="https://askubuntu.com/questions/1379425/system-has-not-been-booted-with-systemd-as-init-system-pid-1-cant-operate" > <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <br><font color=red> sudo service ssh restart 这个命令有作用 类似的还有 sudo service ssh status 关键就是 service 操作具体可见tldr service</font></strong></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="locate-amp-find"><a href="#locate-amp-find" class="headerlink" title="locate &amp; find"></a>locate &amp; find</h3><ul>
<li><em><strong><font color=pink>我是真的有病，又一次忘记保存全部没了</font></strong></em></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\github.1.0\My_blog_hexo\source\images\tests.png"
                     
                ></li>
</ul>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\github.1.0\My_blog_hexo\source\images\lo.png"
                     
                ></p>
<ul>
<li><p><strong>注意可以进行执行自己的操作 -exec cmd ‘{}’ ‘;’ 注意 {} ； 必不可少 {} 代表的是当前路径 ； 代表命令的结束 要引用起来 因为都是特殊涵义的字符 可以用+ 这样就是全部执行 而不是每次都执行一次 同时可以用-ok 指令代替我们的-exec 这样每次都会进行一下询问 ！！！！</strong></p>
</li>
<li><p><strong><font color=green>压缩文件</font></strong></p>
<ul>
<li><em><strong>gzip and gunzip</strong></em></li>
<li><em><strong>gzip + file 注意没有中间选项 此时是原始文件 但是可以对一压缩的文件进行选项查看</strong></em></li>
<li><em><strong>gunzip -c file.gz 查看压缩文件的内容</strong></em></li>
<li><em><strong>bzip2 也是一个类似于 gzip的命令 压缩程度更高 gzip -d 就相当于解压缩了</strong></em></li>
</ul>
</li>
<li><p><strong><font color=blue>归档文件 archiving !!!!</font></strong></p>
<ul>
<li><strong>tar tape archive 备份归档 一组独立的文件或者几个目录 或者两者兼有 通常后缀 为.tar h或者 .tgz 表示 gzip压缩过的归档包</strong></li>
<li><strong>四个模式 注意先写模式 再写选项</strong></li>
<li><strong>cf czf 都是创建 tvf 列举查看 xf xvf 就是复原 注意路径名格式</strong></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/tar.png"
                     
                ></li>
<li><em><strong>zip unzip 与tar和gzip的结合  类似 但是更多用于 与windows交互</strong></em></li>
</ul>
</li>
<li><p><em><strong>同步<a class="link"   href="http://billie66.github.io/TLCL/book/chap19.html" >可以看看但是似乎目前用的不多 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></p>
</li>
<li><p><em><strong><font color=pink>中间暂时跳过了文本处理和正则来个比较重要的make</font></strong></em></p>
<ul>
<li>脚本语言不需要编译 而是直接执行 例如 shell脚本 python PHP perl ruby</li>
<li>tar tzvf tarfile | head — 检查指令</li>
<li>通过这个可以看到一些标准版本源代码的组织形式 其中有一些大写的如README INSTALL 等介绍文件 同时 还有configure文件用于 配置的 同时就是各种头文件和源文件</li>
<li><em><strong><font color=red>系统的源码通常维护再&#x2F;usr&#x2F;src 中 供多个用户试用的源码通常再&#x2F;usr&#x2F;local&#x2F;src 中</font></strong></em></li>
<li>构建通常两步 .&#x2F;configure make</li>
<li>.&#x2F;configure 主要配置相关的需要的环境和依赖项同时创建makefile</li>
<li>sudo make install 对于一些包装良好的库 可以直接执行此命令安装成功</li>
</ul>
</li>
<li><p><em><strong><font color=pink>LINUX小子第二步——Shell脚本</font></strong></em></p>
<ul>
<li>编写脚本三步</li>
<li><em><strong>写一个脚本</strong></em></li>
<li><em><strong>让其可执行 chomod 755 file 对所有人都可执行 700只有拥有者可以执行</strong></em></li>
<li><em><strong>放在一个shell能找到的位置 配置PATH 这个原理就是对于可执行文件 如果直接输入名字 shell会在环境变量的path路径中寻找 因此对于通常自己的没有位于相关路径的脚本是找不到的所以需要文件路径通常我们使用相对路径 .&#x2F;prog</strong></em></li>
</ul>
</li>
<li><p><em><strong><font color=green>安装chrome成功 还得是微软教程但是有乱码的问题同时除了搜索以为ia其他时候都很慢</font></strong></em></p>
</li>
<li><p><em><strong><font color=green>Good 现在查看html文件就直接google-chrome + 文件路径</font></strong></em></p>
</li>
<li><h3 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a><font color=blue>脚本编写</font></h3><ul>
<li><em><strong>注意通常而言在脚本里面 全大写代表常量 小写代表变量</strong></em></li>
<li><em><strong>一定要正确的书写变量名 在命令行内也可以直接进行变量使用 不需要提前声明 declare -r TITLE 强制命令常量</strong></em></li>
<li><em><strong>变量名展开的几种形式</strong></em></li>
<li><img src="/../images/vara.png" alt="../images/vara.png"></li>
<li><em><strong><font color =red>还有一种高级的操作叫作 here document <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/here.png"
                     
                ></font></strong></em></li>
<li><em><strong>shell函数</strong></em><ul>
<li>function name{} &#x2F; name(){}两种</li>
<li>先定义在使用 return语句控制权</li>
<li>局部变量在内部</li>
<li>定义方式 local var eg local foo foo&#x3D;0 外部不存在</li>
<li>完全可以用脚本函数 直接写道 .bashrc中 来代替别名</li>
</ul>
</li>
<li><strong>分支控制</strong><ul>
<li>$? 检测最近的一个指令执行退出情况 0为成功</li>
<li>上述的这个正是if控制实现的底层原理</li>
<li>格式就是if cmd;the cmd; fi 可以借[elif]<ul>
<li>还有各种文件比较操作<a class="link"   href="http://billie66.github.io/TLCL/book/chap28.html" >逆天 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>通常是if [expression]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color=MediumSpringGreen>Df -h 指令 查看所有磁盘情况 不错的指令</font></p>
</li>
<li><p><strong><font color=cornsilk>su -l usrname    alt+n &#x2F;p 历史命令搜索  tar xvf 提取 gpg 一种内置的加密程序 gpg –verify gpg –recv-keys  gpg–fingerprint etc.</font></strong></p>
</li>
<li><p><strong><font color=cornsilk>今天遇到了实际很多会是链接的问题需要文件夹而非可执行文件的问题 JAVA_HOME 还有就是 wget 真方便 然后需要检查是不是一个tgz 可恶哩</font></strong></p>
</li>
<li><p><strong><font color=pink>export PATH&#x3D;~&#x2F;bin:”$PATH”类似的命令记住了</font></strong></p>
</li>
<li><p><strong><font color=cornsilk>. .bashrc 激活注意  每次修改环境变量时都要激活一下</font></strong></p>
</li>
<li><p><strong><font color=cornsilk>issu 解决 sudo usermod –append –group sudo &lt;username&gt; 就可以加权限了 </font></strong></p>
</li>
<li><p>sudo useradd </p>
</li>
<li><p><strong><font color=cornsilk>ssh 问题解决历程目前还没解决 10&#x2F;31 <a class="link"   href="https://www.hanselman.com/blog/how-to-ssh-into-wsl2-on-windows-10-from-an-external-machine" >port forwarding <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://superuser.com/questions/571196/port-forwarding-to-a-vmware-workstation-virtual-machine#:~:text=On%20Windows%2C%20you%20can%20access,setup%20on%20a%20typical%20router." >port forwarding in vmware <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.tutorialspoint.com/hadoop/hadoop_multi_node_clust" >hadoop manual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br></font></strong></p>
</li>
</ul>
</li>
<li><h2 id="更多键盘操作"><a href="#更多键盘操作" class="headerlink" title="更多键盘操作"></a><font color=aqua><a class="link"   href="https://stackoverflow.com/questions/9679776/how-do-i-clear-delete-the-current-line-in-terminal" >更多键盘操作 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></h2></li>
<li><p>ctrl + u 删除当前行（命令）</p>
</li>
<li><p><font color=maroon>注意 git clone 最后在url后面加一个.<font color=blue>git</font></font></p>
</li>
<li><p><font color=cyan>deb 有统一的包管理所以可能下载安装更见简单 有内置命令来解决   runfile 通常是脚本完成</font></p>
</li>
<li><h2 id="apt-对于终端用户更加友好-相当于一个集合-集合很多命令的东西-然后就是apt-get-更加底层-有"><a href="#apt-对于终端用户更加友好-相当于一个集合-集合很多命令的东西-然后就是apt-get-更加底层-有" class="headerlink" title="apt 对于终端用户更加友好 相当于一个集合 集合很多命令的东西 然后就是apt-get 更加底层 有"></a><font color=pink>apt 对于终端用户更加友好 相当于一个集合 集合很多命令的东西 然后就是apt-get 更加底层 有</font></h2></li>
<li><h2 id="sudo-apt-get-autoremove-这是一个安全的指令用来-clean-you-system-没事就可以输入一下-原理就是清楚不再被任何应用使用的依赖-lib-stackoverflow-上面似乎还有一些其他工具可以-但是目前-这个命令就可以了"><a href="#sudo-apt-get-autoremove-这是一个安全的指令用来-clean-you-system-没事就可以输入一下-原理就是清楚不再被任何应用使用的依赖-lib-stackoverflow-上面似乎还有一些其他工具可以-但是目前-这个命令就可以了" class="headerlink" title="sudo apt-get autoremove 这是一个安全的指令用来 clean you system  没事就可以输入一下 原理就是清楚不再被任何应用使用的依赖 lib !!!! stackoverflow 上面似乎还有一些其他工具可以 但是目前 这个命令就可以了"></a><font color=yellow>sudo apt-get autoremove 这是一个安全的指令用来 clean you system  没事就可以输入一下 原理就是清楚不再被任何应用使用的依赖 lib !!!! stackoverflow 上面似乎还有一些其他工具可以 但是目前 这个命令就可以了</font></h2></li>
<li><p><font color=green>非登录就是不需要输入用户和密码 echo $0 查看 如果是-bash  就是登录 bash 就是非登录 主要区别就在于载入相关启动文件</font></p>
</li>
<li><p>cat -n </p>
</li>
<li><p>power9 是一个超级电脑的架构流式处理器</p>
</li>
<li><p>expansion 尤其是 brace expansion 还有 quoting 引用就是 “” ‘’</p>
</li>
<li><h2 id="root-开机自启项和sysmecl"><a href="#root-开机自启项和sysmecl" class="headerlink" title="root 开机自启项和sysmecl"></a><a class="link"   href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config" >root 开机自启项和sysmecl <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2></li>
<li><p>rm -r删除非空文件夹 rmdir rm -d删除空文件夹</p>
</li>
<li><p>descend into directory 就是问是否同时删除里面的文件 yes即可 但是这首会一个一个出现 所以最好还是不要-i当文件很多的时候</p>
</li>
</ul>
<h2 id="真的不好说-autoremove-把我mpi删了-乐！！！"><a href="#真的不好说-autoremove-把我mpi删了-乐！！！" class="headerlink" title="真的不好说 autoremove 把我mpi删了 乐！！！"></a><strong><font color=red>真的不好说 autoremove 把我mpi删了 乐！！！</font></strong></h2><ul>
<li><p><font color=pink>ssh passphrase 我的同样的通用密码</font></p>
</li>
<li><p><a class="link"   href="https://www.strongdm.com/blog/ssh-passwordless-login" >ssh passwordless <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><font color=orange>who指令可以查看其他用户在本机的使用情况。注意理解 linux 是一个多用户多任务的操作系统。而windows 是一个单用户假多任务的操作系统</font></p>
</li>
<li><p>useradd 添加用户 但是没有提示 userdel 删除用户</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>BombLab</title>
    <url>/2023/10/07/BombLab/</url>
    <content><![CDATA[<h3 id="血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫"><a href="#血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫" class="headerlink" title="血淋淋的教训啊 关bash的时候一起关了 直接没保存 全部没了 😫"></a><font color=pink>血淋淋的教训啊 关bash的时候一起关了 直接没保存 全部没了 😫</font></h3><ul>
<li><h2 id="离散有趣知识点"><a href="#离散有趣知识点" class="headerlink" title="离散有趣知识点"></a><font color=lightgreen>离散有趣知识点</font></h2><p><font color=orange>离散马上要结课了，里面很多还是很有趣的，这里就零散记载一些有趣或者是有用的知识点</font></p>
</li>
<li><p>析取是或者，合取是与。蕴含命题就是条件语句。逆否等价于原来的条件语句。 p仅当q等价于p-&gt;q。也就是等价于如果p则q 将命题用于语句翻译可以简化原理。常见的等价式子以及德摩根定律。</p>
</li>
<li><p>合取范式，析取范式，可满足问题，数独。极大项，极小项。极大项与极小项的关系就是取反。注意规定的真值不同，极小项是合取，使式子为真，极大项是析取，使得式子为假 主析取范式，主合取范式就是每一项是极大（小）项 求主析取范式 主析取范式和住合取范式下标是互补的</p>
</li>
<li><p>谓词就是形容词 函数 量词就是全称存在 唯一性量词</p>
</li>
<li><p>量词的否定 嵌套量词的否定就是移动否定就可以了连续移动 条件语句和量词组合 不能分发</p>
</li>
<li><p>归谬法似乎是将需要证明的结论的反命题作为前提引入，然后根据所有前提得到一个a^~a 的情况 </p>
</li>
<li><p>而反证法 是这样 我们要证明 p -&gt; q ,那么我们可以证明其等价的逆否命题， ~q -&gt; ~p 这样来得到原命题成立</p>
</li>
<li><p>归谬证明法 就是通过 得到<del>p -&gt; (r^</del>r) 这样的式子为真 然后得到 p 为真，一般就是一个命题 p 而不是条件语句 条件语句的证明需要假设p,<del>q 然后得到 ~p ，p; q,</del>q 两组矛盾式得到其中一组即可</p>
</li>
<li><p>直接证明 反正法 归谬证明</p>
</li>
<li><p>鸽巢原理 鸽巢原理注意实际应用 找到什么是盒子 什么是物品 </p>
</li>
<li><p>排列和组合</p>
</li>
<li><p>环排列需要除以环中的元素数量</p>
</li>
<li><p>很多组合恒等式可以通过建模，运用一种组合场景来进行证明</p>
</li>
<li><p>范德蒙德恒等式 挺有用的 也挺好理解 变形</p>
</li>
<li><p>重复排列的问题 就是平方 组合就稍微复杂</p>
</li>
<li><p>递推关系式 求解 就是一个特解组合上一个伴随解</p>
</li>
<li><p>递推关系的寻找  本事是寻找当前问题能不能由子问题或者说是先前状态转换而来。</p>
</li>
<li><p>目前我的理解中生成函数的使用图景并不是很多 目前有一个就是求解计数问题。 生成函数还可以求解递推关系</p>
</li>
<li><p>容斥原理</p>
</li>
<li><p>容斥原理 公式里面的加减是交替的 并且肯定显然从 加法开始</p>
</li>
<li><p>容斥原理配合组合数来使用</p>
</li>
<li><p>容斥原理求解映上函数 这个其实可以单独抽象成一个标准模型 成为许多问题的解决的原理 而且这种模型如果直接求解很容易出现问题 重复求解</p>
</li>
<li><p>限制条件可以考虑求全部情况 然后减去互斥的情况</p>
</li>
<li><p>模运算 有同余恒等式 满足加或者乘法的运算律</p>
</li>
<li><p>求模运算得到的结果始终是正值 计算被模的数是负数</p>
</li>
<li><p>模指数运算 二进制转换指数 然后每算一项都模一次</p>
</li>
<li><p>gcd 欧几里得算法 裴树算法可以用来证明一些等式</p>
</li>
<li><p>ab mod m&#x3D;amod m b mod m</p>
</li>
<li><p>求模的逆 运用欧几里得算法 就是求贝祖系数</p>
</li>
<li><p>求解线性同余式的方法就是运用欧几里得算法求出逆 而逆其实就是求解 贝祖系数 对了还有一个前提就是 a 与 m要满足互素 但是即使不互素 满足一定条件就可以求解</p>
</li>
<li><p>中国剩余定理 求解线性同余方程组的一种方法 原理同上 然后就是类似的一种叫做反向替代的方法</p>
</li>
<li><p>费马小定理 用来求解整数模指数运算</p>
</li>
<li><p>原根和离散对数 是一些密码学的基础</p>
</li>
<li><p>费马小定理的推广 欧拉函数和欧拉定理 勤奋的欧拉哈哈哈哈哈</p>
</li>
<li><p>RSA 的原理 凯撒加密加三模26移位密码 移位数k就是密钥 仿射密码求解的关键就是求同余方程</p>
</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑电路/c++</title>
    <url>/2023/10/11/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="大爱逻辑电路，简洁是美的灵魂"><a href="#大爱逻辑电路，简洁是美的灵魂" class="headerlink" title="大爱逻辑电路，简洁是美的灵魂"></a><font color=pink>大爱逻辑电路，简洁是美的灵魂</font></h3><ul>
<li><h2 id="My-Efficient-c-想不到吧"><a href="#My-Efficient-c-想不到吧" class="headerlink" title="My Efficient c ++ (想不到吧)"></a><font color=deepskyblue>My Efficient c ++ (想不到吧)</font></h2><p><font color=salmon>同时，我觉得既然是总结，咱们就换一种视角串联整个c ++ 知识点。</font></p>
</li>
<li><p><font color=pink>模板</font></p>
<p><font color=lightgreen>模板推断，也就是实例化是编译器的工作。理解实例化，只有实际调用或者是定义时才会实例化。并且不同实例的函数或者类是独立的。同时模板定义一般写在头文件里面。class 和 typename 是相同的含义。模板具有默认类型参数，所以平时看定义的时候注意一下</font></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N,<span class="type">unsigned</span> M&gt; <span class="built_in">compare</span>(<span class="built_in">char</span> (&amp;a)[N],<span class="built_in">char</span> (&amp;b)[M]);	<span class="comment">// 非类型实参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> F=less&lt;T&gt;&gt;<span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp;v1,<span class="type">const</span> T&amp;v2,F f=<span class="built_in">F</span>());</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; <span class="keyword">class</span> Numbers&#123;&#125;;</span><br><span class="line">Numbers &lt;&gt; b; <span class="comment">// 使用默认参数 任何时候&lt;&gt;都不能省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Debugdelete</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*p)</span><span class="type">const</span></span>&#123;<span class="keyword">delete</span> p;&#125;	<span class="comment">// 之所以有const的原因是const保护的是删除器的成员，区分清楚保护的对象 p 是外来的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Debugdelete</span>()(); <span class="comment">//在一个临时对象上调用operator()</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>,Debugdelete&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>,Debugdelete())</span></span>; <span class="comment">// 这里可以窥见删除器的本质就是一个可调用对象，这是一个简洁而深刻的概念 全新的 这是常见的用法</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(compareIntfunction)</span>*&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span> ,compareIntfunction)</span></span>; <span class="comment">// 类似的 具体原理就是指针调用析构函数时会是使用删除器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i,<span class="type">const</span> std::string &amp; msg)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>(i&gt;=data-&gt;<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);&#125;<span class="comment">// 这个工厂函数写得很好！！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;<span class="built_in">A</span>(It b,Ite);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  	A&lt;T&gt;::<span class="built_in">A</span>(It b,It e):<span class="built_in">data</span>(make_shared&lt;std::vector&lt;T&gt;&gt;(b,e))&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><font color=violet>类模板的成员模板</font></p>
<p><font color=violet>正是依靠这个实现迭代器构造函数.——一个问题，由于实例化时，每一个独立的源文件都需要一份实例，可能存在重复的性能消耗，所以我们可以显示控制实例化 extern 声明一个具体的类型参数的模板，然后必须在某一文件里有定义 template 开始。最后记得链接在一起。定义其实也就是一句话，对于类模板来说这会使得所有成员都实例化，这点注意哦<br>这里也有一个有趣的问题就是shared_ptr 与 unique_ptr 删除器的实现方式。shared_ptr 可以随时reset 改变删除器所以实际是将删除器作为成员保存，指针形式保存，析构时大概就是 del? del(p): delete p; 而 unique_ptr 只允许定义时传入作为模板参数，所以就是编译时绑定效率更高，但是不能任意改变。</font></p>
</li>
<li><p><font color=yellow>异常处理</font></p>
<p><font color=cornsilk>异常处理包含两个过程，异常捕获和异常处理。捕获依靠throw 表达式，处理依靠try catch 语句块。 注意想要被catch 捕获需要使用try 存在 try 的多重嵌套，依照调用链反向寻找所有层次的catch 语句直到匹配，如果一个都不匹配则terminate直接终止。有一些标准库定义的错误类，有些需要初始化const char[]。 .what()方法可以查看字符串内容 栈展开其实就是。 展开过程会销毁对象，依照局部对象的销毁原则。<br>异常对象可以是标准库定义，也可以自己定义，完全类型有可访问的析构与构造函数，同时如果在throw 语句中解引用指针，如果是一个派生对象，基类指针则抛出的部分只有其基类的部分</font></p>
</li>
<li><p><font color=cyan>随机数</font></p>
<p><font color=lightgreen>随机数使用，包含两个部分，一个部分是随机数引擎，另一个是随机数分布。引擎生成一系列unsigned ，分布完成我们的需求生成所需的指定类型给定范围，满足特定概率分布的随机数 。引擎需要种子，否则也是固定的伪随机 ,default_random_engine 其实是系统预定义的最佳引擎，具体有三个。然后分布种类是模板，需要指定类型别名。调用的方法类似 u(e) 。 u是分布种类。 e 是对象。</font></p>
</li>
<li><p><font color=salmon>5G555 多谐振荡器 产生脉冲</font></p>
</li>
<li><h2 id="数字电路要义"><a href="#数字电路要义" class="headerlink" title="数字电路要义"></a><font color=pink>数字电路要义</font></h2><ul>
<li><p><font color=lightgreen>逻辑函数</font></p>
<p>使用与非门来建立所有三种逻辑门，实现电路的统一。异或可以用于奇偶校验 奇数个变量为1 结果就是1 偶数个为0  对偶函数就是0 1 也要互换记得和反演一样 同或就相反  与或表达式就是先与后或 区别最小项最大项的方法 就是 最小项之和 最大项之积<br>卡诺图注意最小项在图中对应的顺序 卡诺图中每个圈至少需要一个一个独立 的1（最小项）</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Parallel-Programming</title>
    <url>/2023/10/12/Parallel-Programming/</url>
    <content><![CDATA[<h3 id="HPC-Parallel-Programming、"><a href="#HPC-Parallel-Programming、" class="headerlink" title="HPC - Parallel-Programming、"></a>HPC - Parallel-Programming、</h3><h3 id="重大发现就是我们的这个触摸板-可以做到切换-多个手指同时下滑-就可以显示桌面-左右滑动就可以实现-alt-的切换功能-然后还有就是-f11-对于我们的网页-也可以进行全屏显示-f12-进行监测-同时-还可以触摸屏左右两指滑动进行返回前进历史返回-发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退-使用三个手指是alt功能-使用四个手指是windows桌面切换-还有一个就是-ctrl-e-时搜索url框"><a href="#重大发现就是我们的这个触摸板-可以做到切换-多个手指同时下滑-就可以显示桌面-左右滑动就可以实现-alt-的切换功能-然后还有就是-f11-对于我们的网页-也可以进行全屏显示-f12-进行监测-同时-还可以触摸屏左右两指滑动进行返回前进历史返回-发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退-使用三个手指是alt功能-使用四个手指是windows桌面切换-还有一个就是-ctrl-e-时搜索url框" class="headerlink" title="重大发现就是我们的这个触摸板 可以做到切换 多个手指同时下滑 就可以显示桌面 左右滑动就可以实现 alt 的切换功能 然后还有就是 f11 对于我们的网页 也可以进行全屏显示 f12 进行监测 同时 还可以触摸屏左右两指滑动进行返回前进历史返回 发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退 使用三个手指是alt功能 使用四个手指是windows桌面切换 还有一个就是 ctrl + e 时搜索url框"></a><font color=pink>重大发现就是我们的这个触摸板 可以做到切换 多个手指同时下滑 就可以显示桌面 左右滑动就可以实现 alt 的切换功能 然后还有就是 f11 对于我们的网页 也可以进行全屏显示 f12 进行监测 同时 还可以触摸屏左右两指滑动进行返回前进历史返回 发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退 使用三个手指是alt功能 使用四个手指是windows桌面切换 <br>还有一个就是 ctrl + e 时搜索url框</font></h3><ol>
<li><h3 id="并行程序设计入门开始"><a href="#并行程序设计入门开始" class="headerlink" title="并行程序设计入门开始"></a><font color=seablue>并行程序设计入门开始</font></h3><ol>
<li><strong><a class="link"   href="https://heptagonhust.github.io/HPC-roadmap/" >RoadMap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>来自七边形</strong></li>
<li><em><strong>这里文件<a href="/doc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA.pdf">并行设计</a></strong></em></li>
<li><strong><a class="link"   href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html" >Nvidia cuda guidance <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></li>
<li><em><strong>MPI<a class="link"   href="https://www.netlib.org/utk/papers/mpi-book/mpi-book.html" >tutorial <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></li>
<li>MPI<a class="link"   href="https://mpitutorial.com/tutorials/mpi-introduction/" >manual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#optimizing-cuda-applications" >nvidia <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><font color=violet>下载了几个nvidia的的samples在happyplace&#x2F;0a 里面 可以make一下</font></li>
<li></li>
<li><em><strong>这里保存几个markdown的颜色</strong></em></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee1.png"
                     
                ></p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee2.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee3.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee4.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee5.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>HPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Begin_Again</title>
    <url>/2023/10/15/Begin-Again/</url>
    <content><![CDATA[<h3 id="计算机科学中的自然原理"><a href="#计算机科学中的自然原理" class="headerlink" title="计算机科学中的自然原理"></a>计算机科学中的自然原理</h3><ul>
<li><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><font color =green>感谢过去一年中给予我启发的诸多事物，无论是一本书如CSAPP，一堂课如数字电路，或者一个人如Prof.Strang，所有这些人事都是促使我更加严肃地审视计算机科学与其背后丰富而美丽的思想。所以，我希望继承那些前辈，那群充满热情与想象力的先驱的工作，在这里对CSAPP中的美妙理论进行简答而又深刻的阐释（有点自大哈哈哈哈），希望在有限的时间与文字中，探寻科学与自然的美。</font></strong></p>
</li>
<li><h2 id="你好！世界"><a href="#你好！世界" class="headerlink" title="你好！世界"></a><font color=pink>你好！世界</font></h2><blockquote>
<p>萨冈和她的你好忧愁，我和我的你好世界。Hello World,梦开始的地方，我们就从一个hello world.c 程序的生命开始进行一场快速的计算机世界漫游。</p>
</blockquote>
<ul>
<li><font color=aqua>程序是怎么编写的呢，首先我们会需要一个文本编辑器，也就是我们常用的devc++或者是vscode，vim，emacs。文本编辑器就是编辑文本文件的，我们缩写的源文件也属于文本文件。文本文件就是只含有阿斯克码的文件，其余的文件都是二进制文件。编写后，我们就可以通过一系列指令来使程序运行。对于一个.c文件而言。我们可以用gcc 命令来生成可执行文件。gcc就似乎编译驱动程序 这是nux终端的命令。当启用后，首先运行的是预处理器，对于含#的指令，如#include预处理器会将头文件全部插入到源文件中，同时完成宏的拓展。这是纯粹的文本替换，其他什么都没有发生。然后就是编译器，编译器将.c文件转换为汇编语言格式，可以理解为机械码的助记符，这是程序员可以阅读和编写的。然用汇编器汇编为二进制，此时是一个可重定位的可执行文件，此时通过ld将引用的库一起链接形成一个可执行文件保存在内存中。调用时，通过加载器加载到cpu进行执行。</font></li>
<li><font color=pink>几个关键概念。首先，计算机的硬件组成。CPU，内存空间极其缓存结构和虚拟地址，网络与I&#x2F;O 进程与线程。这里我们能慢慢接触到抽象与设计的感觉。</font></li>
<li><font color=blue><em><strong>一切皆文件 ，linux将设备文件都以同一种方式进行处理，让建立一种广泛而统一的接口成为可能</strong></em></font></li>
</ul>
</li>
<li><h2 id="从理论到实践"><a href="#从理论到实践" class="headerlink" title="从理论到实践"></a><font color=MediumAquamarine>从理论到实践</font></h2><p><strong><font color=ForestGreen>在学习每一个章节的过程中，我们会逐渐感觉到与一些相似的内容串联了起来。这种知识路径形成环，环闭合的感觉非常类似于我在高中看科幻小说时形成的想法。哈哈哈哈哈。这里就列举所有对应的知识群，然后随着不断学习深入，持续补充~~（突然想到也许我得去补充几个emoji和颜文字）</font></strong></p>
<ul>
<li><strong><font color=Lavender>二进制族群——数字电路的设计非常优美简洁;CPU流水线；</font></strong></li>
<li><strong><font color=lavender>程序机器级表示——优化技巧</font></strong></li>
<li><strong><font color=lavender>链接——Makefile脚本和Cmake 的使用 以及Vscode 相关json文件的配置</font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
</ul>
</li>
<li><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a><font color=orange>FAQ</font></h2><ul>
<li><font color=pink>buffer overflow 字符串溢出覆盖栈上内容读取字符串造成</font></li>
<li><font color=pink>为什么重载函数不能返回区别，因为编译器重整符号时只会考虑函数名字和参数类型</font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
</ul>
</li>
<li><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><ul>
<li><font color=brown>浮点数与整数两种格式，拥有不同的表示方法，所以进行类型转换时要注意。整型通过补码表示。公式是唯一的-2^n + 源码的二进制。浮点数是一中近似的表示，对于太多小数位，进行加减时可能出现差。还有就是有符号与无符号的区别以及对应的溢出问题，截断问题。最后就是其实很多函数%d 并不关心真正的类型也不会检查，这只是告诉函数将以一个整型的方式进行内存寻找。</font></li>
<li><font color=cyan>big-end &amp;&amp; small -end 大小端 注意只存在于多个字节的数据的问题 例如0x12345678 小端机就是 78 56 34 12 就是地位在小地址，注意在网络编程获取主机名于端口时可能有影响，需要调用相应修改转换函数。</font></li>
<li><font color =Orchid>计算机处理加法乘法都远远快于除法。同时可以尽量写位运算，当然编译器可能也帮你优化。数字的表示与实现都很精妙 前辈的只会佩服。</font></li>
</ul>
</li>
<li><h2 id="汇编简介"><a href="#汇编简介" class="headerlink" title="汇编简介"></a><font color=PowderBlue>汇编简介</font></h2><ul>
<li><font color=Orchid>首先我们要知道，计算机只认识01，01 构成了整个世界，在数字电路的学习中我们也能有这样的体会。事实上，我们所写的程序最终会转换成01的机器代码，所有的文件不论是文本视频图片文件最终都是01串。而汇编代码就是位于机器代码的一种助记符</font></li>
<li><font color=sandybrown>gcc -Og O1 O2 O3 通常而言 O1 分析 O2 可接受优化 Word因特尔的字就是 16bit 寄存器 6个参数寄存器 rdi rsi rdx rcx r8 r9 然后返回 rax 栈 rsp 计数器PC rip 然后就是被调用者寄存器 我们来看一下机械逻辑是怎么形成过程的。栈，核心，栈帧栈的空间。然后就是三个部分，传递控制，传递数据，分配和释放内存。控制传递依赖两个命令与rip call 会将放回地址即下一条弹入到栈中，然后rip变为label的地址。ret就会压栈然后rip回到返回地址。 数据控制就是通过栈存储多余参数调用，被调用者保存寄存器数据，局部变量存储完成的。</font></li>
<li><font color=lightcoral>指针与数组，数组就是转化为i指针运算。通过改变内存寻址来实现c语言中的指针类型。结构而言，字段就是基地址偏移量。引入重要的对齐概念：一句话任何大小为K字节的数据类型的首地址都要为K的倍数，intel不强行对齐。因此就可能会补全。buffer overflow 就是字符串溢出覆盖栈上数据，然后对应防范有栈随机化和金丝雀技术。 alloca 栈上分配空间。</font></li>
<li><font color=wheat>浮点数，单独一组寄存器 ymm 256 64bytes,xmm 32bytes. SSE,AVX架构。包含头文件可以使用。</font></li>
</ul>
</li>
<li><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a><font color=yellowgreen>优化</font></h2><ul>
<li><font color=greenyellow>优化面对的挑战。memory aliasing 就是同一个地址由多个指针变量使用，一些激进优化可能导致问题。函数调用对全局状态的改变。</font></li>
<li><font color=lightblue>CPE，周期每元素一个度量单位。延迟，就是严格顺序执行时一个操作需要的实践。发射时间就是两个相同命令执行所需的间隔，为1就是完全流水化时间。吞吐量，就是发射时间的倒数乘以功能单位。优化方向有减少循环内部计算。减少函数调用，合理内联。减少同一值的反复求值过程。循环展开。多路合并，也就是累计变量。写出简短便于求值使用数据传递控制的条件判断。然后就是使用向量操作。减少内存引用，使用局部变量存储。然后就是重新结合提高指令级并行度。 </font></li>
<li><font color=plum>关键路径，就是分析优化的一种指令级维度的技术。将汇编代码进行分析，观察其中的循环寄存器以及相关数据链，然后数据链对应就是一个关键路径，看关键路径有无线性缩短。乱序处理，流水线，分支预测，投机执行。CPU的技术。程序分析。unix 上的gprof ，linux上的valgrind, intel的vtune，以及nvidia的nsight 好多profiler。其中gprof 使用需要加一个-gp 选项在gcc中</font></li>
<li><font color=cadetblue>Amdahl’s law 就是想要加速一个系统，其加速比取决于加速部分时间占据整个系统的比重以及加速程度。</font></li>
</ul>
</li>
<li><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a><font color=cornflowerblue>内存</font></h2><ul>
<li><font color=coral>DRAM，SRAM，ROM，memory ,cache .等名词分清楚。SRAM 构成高速缓存的物理媒介快贵。DRAM构成主存的媒介也就是运存。ROM一般指磁盘一类的flash disk ,CD , ssd 都是不同的存储。</font></li>
<li><font color=rosybrown>DRAM 芯片结构。单个芯片有超单元矩阵构成，每个超单元一般有一个byte.然后2位地址引脚，8位数据引脚掌控数据的传输和行列索引。将芯片封装乘模块。叠8个，一次64位。通过内存控制器广播来讲相同索引的8byte数据聚合成一团数据。改进 DDR SDRAM 双倍数据速率同步DRAM 就是两倍的时钟上升沿</font></li>
<li><font color=olive>ROM是一类统称（非易失性存储），目前最主流的是flash memory。然后还有最新的SSD。ROM 上存储的一些程序叫做固体firmware 例如bios.通过总线进行访存。不过典型计算机使用的是磁盘技术。 连接设备i&#x2F;o 桥 ，系统总线与内存总线。io设备诸如键鼠GPU都是通过io总线尤其是PCI(外围设备互联总线)连接的，io总线比系统和内存总线慢，但是功能更加多样。</font></li>
<li><font color=springgreen>DMA磁盘。 磁盘直接内存访问，将磁盘内容发送到主存后再发送一个intercurpt型号。SSD使用闪存技术趋势，存储器尤其是DRAM 渐渐跟不上CPU的发展，差距越来愈大。随着单核性能趋近饱和，多核处理器出现，吞吐量成为另一个限制条件，而不再是延迟。</font></li>
<li><font color=aqua>locality 。深刻而间接的原理——局部性。时间局部就是重复变量，空间就是步长越小的引用</font></li>
<li><font color=aqua>memory hierarchy缓存实现的基本原理。通常将k+1层的数据c化为连续hunk成为block，与k层的cache交换都是以block作为一个传输单元。然后缓存命中就是k层中找到要访问数据，反之就是不命中。不命中有很多原因种类。冷不命中就是缓存开始时空的。然后由于很难做到随机任意替换的策略，也许是某种倍数一一映射替换策略可能导致冲突不命中。然后如果我们访问的工作集超过缓存的大小会发生容量不命中。寄存器文件由编译器管理，l1 l2 L3 缓存由硬件直接管理可以做到任意替换策略。主存由os 即虚拟内存。磁盘可能由分布式内存软件管理。 TLB 翻译后备缓存器由 硬件MMU管理。</font></li>
<li><font color=cornsilk>存储器结构实现 地址查询的实现本质是一种简单的哈希查询。S 组数，整个地址空间划分成组，每组有许多行，每行有一个有效位，标记为以及块，块中有好几位。 BxSxE ,依据每个组中的行数分三类，E&#x3D;1 直接映射高速缓存 组选择，行匹配，字抽取</font></li>
<li><font color=burlywood>理解划分，t,s,e 首先 s 划分组划分的是cache的组数 会比+1层的组数少，所以也许存在倍数映射，这是靠t标记位实现的，所以t+s真的唯一确定k+1内存块的位置。所以判断的 时候不仅要看有效位还要看t标识位。所以有时候会存在内存抖动问题就是冲突不命中刚好同一行反复驱逐</font></li>
<li><font color=cyan>组相联高速缓存 ，区别就是需要扫描标记位和有效位，因为同一组的所有行都有可能拥有有效数据，同样的在驱逐行时，也需要一定驱逐的策略。最近最少使用.eg</font></li>
<li><font color=pink>全相连高速缓存 只有一个组，所以关键是在扫描标记位和有效位 需要并行搜索标记，所以一般用于小的 eg TLB</font></li>
<li><font color=lightgreen>写操作，两个类型。在写命中时，就是cache中有需要被写的对象时，直写就是直接改变内存和cache，写回就是改变cache,维护一个改变位，推迟改变内存。 在写不命中时也有两个，写分配就是写内存的同时把其加载到cache,非写分配就是不加载。通常我们考虑写回加写分配。 i-cache缓存指令只读,d-cache 缓存数据。总结上面的影响，cache大小。越大命中率越高，但访问时间越长。块大小，越大，空间局部性越好，时间局部性越差，因为行数越少越容易被替换，相连度，越大越复杂，命中使&#x3D;时间越长，但是不命中处罚越低，</font></li>
<li><font color=goldenrod>应用 矩阵乘法优化。。</font></li>
</ul>
</li>
<li><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><font color=Tan>链接</font></h2><ul>
<li><font color=green>编译驱动程序gcc 一套流水作业-v查看注意最后执行的时候会调用一个系统的加载器来复制到内存并转移控制ld 静态链接器在详细认识ld前要一下基本认识。ld两大基本任务。符号解析和重定位。symbol resolution and relocation .符号解析式将符号引用与符号定义关联。重定位是将符号定义与内存关联。大部分指令都有汇编器编译器确定好，ld仅仅奉命完成</font></li>
<li><font color=yellow>可执行文件，三种可重定位，可执行，共享（特殊的可重定位），linux是ELF，windows是PE，可重定位目标文件的格式。ELF头然后中间很多节(.session)然后是节头部表。.text 代码 .rodata .data .bss .symtab .rel.text .rel.data几个比较重要的 .bss 未初始化的全局静态 以及初始化为0的 节省空间函数就在.text里面显然</font></li>
<li><font color=deepskyblue>符号表 符号：三种：模块m定义的全局符号（函数与全局变量），模块m引用的全局符号，m定义的局部符号（static函数和只被m引用的全局以及静态变量）注意所有局部变量都没有条目（栈）因此可以使用static 隐藏模块的函数(模块就是一个可执行二进制文件)。symtab 包含一个条目的结构数组对应可看书P469 readelf 程序可以看二进制文件</font></li>
<li><font color=pink>符号解析，对于局部变量编译器确保唯一。编译器处理全局符号。对于全局符号，划分强弱，以处理重命名情况。 一，不允许有多个同名强符号。二，一个强多个弱同名，选择强，三，多个弱同名任意选择。函数与初始化了的全局变量为强，未初始化的全局变量为弱。 -fno-common 来使得不能生成common二唯一变量。我们使用了静态库技术。模块打包成库文件。对于实际链接时，加载器只会复制库文件中实际引用的部分，减少内存浪费。静态库的格式是archive.  .a 后缀 AR工具自己创建 。 –static 参数告诉驱动程序gcc生成一个完全链接的可执行文件，也就是说可以直接执行了，不需要动态链接。</font></li>
<li><font color=cornsilk>重定位 两步，将所有输入模块的节聚合然后分配到具体的运行时内存，唯一绝对的地址。（定义）。将引用是其指向正确的地址。重定位符号引用：PC相对引用和绝对引用两种。可执行文件，格式多了.init 入口点 组织成片，对齐。加载execve函数可以调用加载器。 运行时内存映像。0x400000开始本质是fork了一个子进程</font></li>
<li><font color=lightgreen>动态链接，动态链接器.so  DLL -shared 参数指示创建一个共享文件，-fpic 创建位置无关代码。共享库就是不复制模板引用的节，而是一些用于定位到 信息，等到实际执行的时候，再利用信息重定位。运行时动态链接dlopen接口打开，dlsym引用一个符号 dlclose 关闭 java也是类似使用c接口的</font></li>
</ul>
</li>
<li><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><font color=Maroon>进程</font></h2><ul>
<li><p><font color=yellowgreen>进程就是一个运行的程序的实例。可以从功能上理解就是一个具体完成我们程序的过程。从组成上就是包括一系列的物理资源。包括内存，寄存器文件，控制器，内核栈等信息。总之就是上下文。</font></p>
</li>
<li><p><font color=salmon>异常，，就是逻辑控制流发生改变的情况，event事件也是如此。 异常发生在内核模式下。异常有中断interrupt 陷阱 trap 故障 终止。 终端就是硬件上，异步发生的。 trap 就是系统调用 system call  对于异常有三种情况 Icur 返回 Icur Inext 或者直接俄abort。 </font></p>
</li>
<li><p><font color=yellow>shell 执行一个命令就是fork 了一个新的进程并发 就是多任务 多进程 很多错误都是有定义的 有硬件设计者或者是内核维护 同样的异常处理程序也是。 可以通过 errno来查看 函数就是 stderror(error)</font></p>
</li>
<li><p><font color=deepskyblue>进程</font></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;		<span class="comment">// 子进程得到的是副本</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(...)</span></span>;</span><br><span class="line">  <span class="function">unsighed <span class="type">int</span> <span class="title">sleep</span><span class="params">(ui)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pause</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 还有可以设置环境变量的sysm call env</span></span><br></pre></td></tr></table></figure></div>

<p><font color=deepskyblue>进程三个状态 运行 停止 终止 停止就是挂起 可以接受信号后继续运行 其中终止三种 接受到一个信号，主程序返回，exit函数</font></p>
<p><font color=pink>理解子进程共享状态 关键： 副本虚拟内存的副本。仔细研究就是 相同的执行程序，内存，data等节。然后相同的用户栈信息，共享文件描述符，共享共享库也就是相同的工具 最大不同就是PID 子进程是0 父进程是子进程的PID返回对于fork 一次调用两次返回 注意这是系统调用 从内核返回到用户模式 并发执行父子进程 </font></p>
<p><font color=lightgreen>进程操作，主要是理解不用背。 未回收的进程就是僵尸进程交给init 进程 PID&#x3D;1 所有进程的祖先 waitpid wait 可以等待并且有一定的行为可以操作   fork 和 exevce 就是实现 sh的关键 大概就是 fork 一个子进程然后进行 execve 执行 对应的命令</font></p>
</li>
<li><p><font color=lightblue>信号 linux 信号 可能来自内核检测到一个系统事件(event) 也可能来自其他程序的kill发送 接受三种 忽略 终止 或者信号处理程序</font></p>
</li>
<li><p><font color=cornsilk>strace 命令 可以使用-static 编译后查看程序中所有系统调用的轨迹 pmap 显示进程的内存映射 &#x2F;proc 内核提供的一个可以在用户模式下查看系统信息的文件 还有&#x2F;sys   execve 在内存里拥有一个内存栈 存储有argv 和 env 以及初始化函数的栈帧 非常的good</font></p>
</li>
<li><p><font color=pink>信号</font></p>
<p><font color=pink>信号是操作系统提供的内核。接受信号的物理实现 内核为每一个进程维护两个位向量,pending &amp; blocked.规则：一个类型至多一个待处理信号，多余发送直接丢弃。进程可以 选择性阻塞信号，这样的信号不会被接收，但是能够发送，只要传送信号，pending就会置为，只要接受，pending就会清除，这里接受可以理解为成功捕获并响应。更准确的说是trap 陷入那一刻起就恢复，因此可以执行handler K 时 捕获k<br>进程组 一般子进程会具有父进程的组pid。 job 一个前台job 很多个后台job job 就是一个进程组<br>signal 函数可以修改信号默认行为 每个信号都有默认行为 sigkill sigstop 不可修改 <br>编写信号处理程序的忠告 处理程序简单 调用异步安全函数sprintf 之类不安全。 保存errno 对全局变量访问期间要暂时阻塞信号 volatile声明防止缓存不一致 sig_atomic_t 声明变量 单变量原子操作</font></p>
<p>Richard Stevens<br><font color=pink>我们每次一个命令执行完后都会return main 所以当前进程会终止 然后被也许 init 或者父进程回收 子进程也会继承信号阻塞的信息向量 信号许多时候会造成竞争，所以我们也需要禁止某种操作，所以我们需要阻塞某些信号。 最后一个 sigsuspend 函数用于等待操作 详细请见 我们的P527 讨论<br>非本地跳转setjump longjump 函数实现的 可以超过一般的处理程序调用的规则进行调用</font></p>
</li>
</ul>
</li>
<li><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a><font color=lightgreen>虚拟内存</font></h2><ul>
<li><font color=lightgreen>虚拟内存针对核心对象的是主存</font></li>
<li><font color=lightgreen>虚拟内存的核心思想就是把磁盘的所有字节划分为一个连续的数组构成一个虚拟地址空间。然后将主存划分为一个物理地址空间，将磁盘的内容缓存在主存上，类似于SRAM缓存体系，这个就是DRAM 缓存体系，很多地方是相同的。我们有操作系统维护一个于虚拟页数（就是缓存里面的块）相同的一个PT（page table 页表） PTE一个条目里可以简化为一个有效位标志是否被缓存，以及一个物理地址字段对应其被缓存在主存上的实际地址。一个page 有三个状态(未分配就相当于磁盘未被使用；分配未缓存，已经被分配例如使用了malloc,但是还没有被加载到主存中；已分配已缓存，此时有效位置位)。现在你直到了malloc 的实际用法。还有就是因为巨大的不命中处罚，所以一个虚拟页较大，并且全相联。同时按需调度，到最后一刻才真正加载到主存。 getrusage 函数可以查看缺页情况。</font></li>
</ul>
<p><font color=lightgreen>虚拟内存如何实现一个统一的内存图景。这样想，我们任何一个程序的开始都一样，这个是虚拟地址，因为内核为每一个进程都维护了一个完整相同的独立的虚拟地址页表，并且虚拟地址要翻译为物理地址，所以啦，我们只需要在虚拟地址向物理地址的映射做一点手脚，我们认为控制这个映射就可以实现任意内存分配 简化加载，我们可以划出虚拟页表指向目标文件中的内容，这就是文件内存的映射，mmap 可以在应用层控制。 简化内存分配 malloc 实际的物理地址可以散落各处 实现内存保护。有几位标识读，写，执行权限。CPU 每次产生一个地址都需要查看PTE 所以在翻译的硬件MMU 中有一个缓存 TLB了解就好 翻译过程可以感兴趣再看看。还有就是使用了一个叫做多级页表的方式减少内存占用。</font></p>
<p><font color=pink>图景的实现原理。内核为每一个进程都维护了一个虚拟地址空间。并将虚拟内存组织成区域也叫做段。例如数据段，代码段，共享库段。实际过程中内核为每一个进程记录一个task_struct 的结构数组，里面包含着进程上下文信息。其中mm_struct 记录了有关虚拟地址的信息。在这个结构中存在一个链表每个node 对应一个段的相关信息。 缺页处理，首先判断是否位于虚拟内存内，如果不在就触发一个段错误。1 .然后判断权限是否对应，如果错误 2.然后开始替换，然后返回到除法信号的指令再次翻译地址。注意虚拟内存上的分配与磁盘上的存储是两个不同概念。只有当前执行的时候我们才加载，而加载的实际含义语义其实是让它具有虚拟地址。让其映射到虚拟地址空间！！！！！！！！！好好理解。抽象成一个空间集合！！！！简洁而有效。</font></p>
<p><font color=deepskyblue>memory mapping。 定义由上面其实页明白就是将一个虚拟内存区域与一个磁盘的对象关联起来，然后初始化这段虚拟内存的内容。映射磁盘对象的时候，有两种。对于Linux普通文件，将文件区分成片，映射到对应的虚拟内存页面。实际上并没有进入物理内存，而是使用按需调度机制。还有就是匿名文件，其实就是选择物理内存上一个牺牲页然后覆盖为0，实际上也没有磁盘的流量。 现在我们特殊讨论一下我们的共享对象。也就是映射的实际情况。首先，对于我们的这个共享对象，我们只需要一个物理内存中的副本，每一个进程可以在自己各自的不同的虚拟内存段上映射，同时每一个进程对于该共享对象的修改都是公开的。 同时还有私有对象，即每一个都是独立的。这种独立的实际事项方式是，先共享映射不过我们设置只读，当正在有探测到写入的时候，我们在复制该对象给写入的进程，尽量推迟从而提高效率。这就是写时复制技术。这也是fork 保持独立的实现原理。私有的，写时复制。execve函数就是一个删除现存虚拟内存重新映射的一个过程 然后mmap 函数可以让我们要求内核开辟虚拟内空间然后把我想要映射的对象关联起来。至于malloc 显式分配器的实践就是一个应用，可以参看书P587 .</font></p>
</li>
<li><h2 id="系统级I-x2F-O"><a href="#系统级I-x2F-O" class="headerlink" title="系统级I&#x2F;O"></a><font color=salmon>系统级I&#x2F;O</font></h2><ul>
<li><p><font color=salmon>一切皆文件的终极体现。就是将所有的i&#x2F;o设备抽象成文件，提供统一的文件接口。 打开文件得到一个唯一的文件描述符。0 stdin 1 stdout 2 stderr. k seek记录文件位置。读文件，读过大小限制后会自己触发一个EOF 而非有这个东西。文件。普通文件，套接字文件，目录。还有一些其他的。每个进程都会记录当前的工作目录，可以通过 cd 命令改变</font></p>
</li>
<li><pre><code class="cpp">#include&lt;sys/types.h&gt;
#include&lt;sys/stats.h&gt;
#include&lt;fcntl.h&gt;

int open();
int close();
int read();
int write();
// Richard Stevens 和他的RIO包 R.I.P 缓存的使用减少系统trap
// 针对不同的应用情景选择不同的i/o 自己写包装更好的尤其是网络编程
//
</code></pre>
</li>
<li><p><font color=salmon>共享文件的实现，维护三个表，针对进程也有一些东西。同时fork的时候也是这样的。</font></p>
</li>
</ul>
</li>
<li><h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a><font color=yellow>并行编程</font></h2></li>
<li><p><font color=cyan>线程，信号量是实现对全局变量的访问。防止竞争。竞争可以使用进程图来直观表示。同时要防止死锁。还有很多，好几个基于线程进程，i&#x2F;o复用的编程模型</font></p>
</li>
<li><p><font color=blue>Open MPI 和 mpch 似是两个不同的mpi 实现 我看的教程似乎是 mpich ,但是一般而言都可以如果只是学习的话 我不过上次我似乎安装的是 openmpi</font></p>
</li>
<li><h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a><strong><font color=Teal>MPI</font></strong></h3><p><strong><font color=DarkCyan>这里就把mpi的使用在这里写了。先补充一点前置知识。冯诺依曼体系。cpu主存分离。导致大多时钟时间去访存。进程就是一个程序的实例可以看成一个综合体包括I&#x2F;o设备即一组文件描述符表，然后主存，前两者共同由虚拟地址实现。此为被处理器表现为独享。多任务即并发。每一个执行时间片。上下文切换。因此硬件计算的优化集中在对冯诺依曼体系的优化大致有如下几个。<br>Cache 在主存与寄存器之间设置三层高速缓存，SRAM，利用局部性原理<br>虚拟地址，可以看作讲主存作为磁盘文件的Cache.同时还有很多好处，如简化加载链接，提供更安全的地址守护等。<br>指令级并行<br>线程级并行TLP 细粒度多线程就是一个线程每执行他的一条指令就切换。粗粒度就是在遇到需要较长时间的指令才切换<br>SMT 同步多线程<br>SISD 单指令流 单数据流 SIMD 单数据多指令流 处理向量运算 大型简单计算GPU就是 处理图像 大量线程 具体可以在学习CUDA后补充<br>MIMD 两种常见类型 注意有多个处理单元即多个处理器 是异步的没有全局时钟 一个是共享内存系统，多个核共享一个内存系统，分布式内存系统，多个核——内存对。第一类具体有两个<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/UMA.png"
                     
                ><br>分布式 最常见的就是cluster集群 以太网连接的一组PC就是 而每一台本身可能是共享内存所以称为混合系统<br>互联网络，可以理解为连接结点的结构。性能依赖于信息读取传输，而这有由硬件的互联网络决定。<br>共享内存系统中有两个 总线bus和交叉开关矩阵crossbar容易理解总线结构简单固定 ，小规模时高效，当结点增多可能出现阻塞，抢夺，因为大小是固定的，无法调整。<br>CrossBar <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Switch.png"
                     
                ><br>上图结构保证了不会出现信息覆盖<br>分布式网络互联结构 其实就是互联网本身的一些结构了<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/net.png"
                     
                ><br>带宽是衡量网络传输速度的，宽度就是讲网络划分为两部分最少的同时通信数量<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/net2.png"
                     
                ><br>延迟和带宽 两个指标<br>共享一致性问题以及解决方案 首先由于Cache 当一个x的内存值改变时，另一个核中cache里缓存的值可能没变。两种方法解决，监听总线和用目录记录。伪共享问题与cache 命中有关 尤其与cache大小有关 当一个核的工作区恰好覆盖一个缓存时，那么就会发生进程间跳跃地对缓存覆盖，最终其实没有共享，反而增加不命中率。<br>对于共享内存系统我们通常派生多线程，分布式我们派生多进程<br>SPMD 单程序多数据流 if(thread0&#x2F;process 0){}elif(1&#x2F;1){}的结构<br>共享内存中的问题：线程不确定性 通过 mutex 和 信号量来互斥实现 同时对于可重入函数的使用 对应的许多拥有static变量的函数就是线程不安全函数当多个线程调用时可能发生问题，解决方法可以是自己上锁或者调用对应库中的线程安全函数<br>分布式中的问题：最多的API就是解决消息传递的。而且其也可以在共享内存中使用，原理就是逻辑上讲共享空间分割为多个独立空间有点像虚拟空间的操作 通常这样的API包含一个send 一个recv函数 然后rank来唯一表示进程 然后缓冲区区分 然后0对应stdout 以及一些广播和归约函数，最常见API MPI message passing interface <br>输入输出问题 输入输出问题常常因为异步而具有不确定性这里有一些规范convention</font></strong></p>
<p><strong><font color=pink>习惯<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/convention.png"
                     
                >总结而言就是没有任何两个文件标识符在实际输入输出时交叉，各自分组线程独自管理<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/speedup.png"
                     
                >可扩展性 增加规模与同时增加核数线程数。效率不变<br>计时通常指程序开始到结束的时间</font></strong></p>
<p><strong><font color=Teal>并行程序设计步骤Foster方法<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/fosterm.png"
                     
                >注意就是平均分配 同时要注意凝聚如果下一个依赖于上一个就可以凝聚为一个任务</font></strong></p>
<ul>
<li><p><strong><font color=lightyellow>MPI详解</font></strong></p>
<ul>
<li><font color=salmon><a class="link"   href="https://www.geeksforgeeks.org/creating-an-mpi-cluster/" >MPI集群的搭建方法 感觉mpi 也逐渐成为其他更高层计算框架实现的底层原理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></li>
<li><font color=yellow>通信子，通信子可以看作一组可以互相通信的进程，初始时有MPI创建了一组WORLD,可以创建多组。可以调用函数得知对应大小以及每一个的rank。</font></li>
<li><font color=yellow>Recv 与 Send函数的语义。各自有自己的缓冲区其实就是指定的存储区。tag用于互相匹配。有status结构来实际获取。匹配包括：同一个communicator，rank匹配。tag匹配。传输信息type匹配。接受去内存大于发送区。对于接受函数有两个宏量。MPI_ANY_SOURCE MPI_ANY_TAG 字面意思就是可以任意接受。发送没有 且一定要指定好comm</font></li>
<li><font color=yellow>MPI_Status参数获取实际传送的字节数。MPI_STATUS_IGNORE</font></li>
<li><font color=yellow>Send语义，可以阻塞，此时不返回。可以缓冲，放入内部存储器，然后返回。返回时并不知道是否成功发送。实际是如果发送信息小于默认的截止大小就缓存，否则就阻塞。Recv一定阻塞。可能出现悬挂</font></li>
<li><font color=yellow>前面的是点对点 还有可以广播的集合通有内置的操作和我们自定义的operator 同样的还有信息的传播 API</font></li>
<li><font color=yellow>线程可以理解为轻量级进程 一个正在运行的程序在一个处理器上的实例 编译器的话需要一个-lpthread 参数</font></li>
<li><font color=yellow>注意我们的这个全局变量需要定义在所有的函数外面然后 main 就是一个主线程</font></li>
<li><font color=orange>目前看来我们需要做到就是明白原理，然后学下具体的API  </font></li>
<li><font color=yellow></font></li>
<li><font color=yellow></font></li>
<li><font color=yellow></font></li>
<li><font color=yellow></font></li>
<li><font color=yellow></font></li>
</ul>
</li>
<li><p><font color=yellow></font></p>
<ul>
<li><font color=yellow></font></li>
<li><font color=yellow></font></li>
</ul>
</li>
</ul>
</li>
<li><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a><font color=slateblue>CUDA</font></h2><ul>
<li><font color=slategrey>CPU 芯片，其实L3缓存占占据了最大的位置 <br>重要的任务就是判断是任务间是否独立 如果独立可能才可以分离task 就是指的一些指令和数据的集合<br>task parallelism 关注多核上的函数并行 data parallelism 关注多核上的数据并行 cuda、主要解决data parallelism <br>核利用率的问题</font></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>自然</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/20/CS224N/</url>
    <content><![CDATA[<h1 id="CS224N"><a href="#CS224N" class="headerlink" title="CS224N"></a><font color=velvet>CS224N</font></h1><ul>
<li><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a><font color=MediumSpringGreen>前置知识</font></h2><ul>
<li><h3 id="TERM"><a href="#TERM" class="headerlink" title="TERM"></a><font color=yellow>TERM</font></h3><ul>
<li><font color=green>line up对齐</font></li>
</ul>
</li>
<li><p><font color=aqua>in-place 就是一般是method 直接俄改变变量的 eg 。.add()</font></p>
</li>
<li><p><font color=aqua>cross product in matrix 就是我们所学的叉乘</font></p>
</li>
</ul>
</li>
<li><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a><font color=chocolate>什么是机器学习</font></h3><ul>
<li><p>机器学习我的理解就是在一定条件下完成一定任务，其中任务的完成由程序本身实现。</p>
</li>
<li><p>监督学习 类似回归问题和分类问题</p>
</li>
<li><p>无监督学习类似聚类算法，没有提前的正确规则，让机器找规律</p>
</li>
<li><p><strong><font color=azure>anaconda 的使用 </font></strong></p>
<ul>
<li>原理就是 conda安装更方便 类似aptitude 可以自动帮助安装 然后就是创建虚拟环境在每个虚拟环境下安装自己的包 避免版本和包冲突</li>
<li>conda create –name <env-name>  <package-name></li>
<li>conda env list</li>
<li>conda –help</li>
<li>conda activate <env></li>
<li>conda info -e</li>
<li>conda deactive 退出环境</li>
<li><font color=red>注意要关代理 创建环境的时候更新版本的时候也要关代理 可以设置使得能够在代理下使用但是有一点麻烦</font></li>
</ul>
</li>
<li><h3 id="pytorch-tutorial"><a href="#pytorch-tutorial" class="headerlink" title="pytorch tutorial"></a><a class="link"   href="https://pytorch.org/tutorials/beginner/blitz/autograd_tutorial.html" >pytorch tutorial <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul>
<li><font color=pink>tensor 的维度 创建tensor torch.empty(3,4)里面是描述tensor 的shape attribute 两个数字说明是两个dim 然后3 说明有三个行向量 4就是每个行向量有4 个元素 empty 不会进行初始化的 1 dim 就是vector 2 dim is a matrix torch.zeros(),.ones(),.rand(), 要从已有的tensor 创建拥有一样shape 的 tensor 需要用法 *_like () method 具体就是这个中括号的层数 torch 也可以直接用python 的 list 和 tuple创建甚至是混合的；在创建tensor的时候可以确定dtype,然后也看可以使用方法.to(torch.int32)</font></li>
<li><font color=pink>数学操作 内置的算术操作针对每一个元素做标量操作 对于两个tensor 也是进行的in-place 操作 但是必须要相同的shape 否则runtime error 一个特殊的例外就是broadcast 详细思考一下 </font></li>
<li><font color=pink>braodcast 从shape的last to first开始比较，当相等 或者其中一个为1 或者其中一个不存在都满足 直到比较完 判断时候broadcastable 然后算数的规则是用prepend 1 不玩较小维度的维度 然后对应的每个维度取最大值 注意 in-place 操作也支持broadcast </font></li>
<li><font color=pink>理解broadcast 的关键就是意识到dim&#x3D;1 的时候我们可以把这个重复的地去乘</font></li>
<li><font color=pink>size 就是指一个维度的元素个数 从last 开始 dim 0 dim 1 注意是从0开始的，然后对应的是shape 的第一个(3,2,1) dim&#x3D;0 size&#x3D;3 注意是相反的！！！！！！</font></li>
<li><font color=pink>创建tensor 的时候指明一个required_grad 这样才能够在后面调用 grad时计算此项的gradient </font></li>
<li><font color=pink>仔细研读了一下 每一个tensor 都有维护一个.grad 来存储自己的偏导数 </font></li>
<li><font color=pink>torch.tensor()总是拷贝tensor 要尽量避免拷贝 detach() 改变 required属性</font></li>
<li><font color=pink>卷积的filter是一个多维的matrices 一定要注意的是我们的结果始终是一个2d matrix 对于一个filter不是多个filter 妈的 kernel 就是filter 带bias 的卷积操作就是卷积的时候加上bias 得到输出 传入kernel size 是一个int默认就是方正</font></li>
<li><font color=pink>dim 就是一个方向可以堆叠的方向 然后可以看括号来判断</font></li>
<li><font color=pink>N batch size 自己定义一些东西 dataset 可以抽象成一个 list  每一个元素就是一个 map 例如 path: label 之类的 feature 就是我们的prediction label 就是实际值 定义dataset 和 dataloader 就是第一步 注意一张定制化的思想 很不错面向对象编程</font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
</ul>
</li>
<li><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><font color=orange>流程</font></h3><ul>
<li><p><font color=lightgreen>custom dataset and dataloader</font></p>
<p>   <font color=lightgreen>dataset 抽象定义为一个map 有一个annotation file 存储所有的样本的名字 还有存储的路径 两者结合可以得到一个图片的完整路径 然后预定义transformer 三个必要的 函数 ——init—— 就是 self.img_labels read csv 读入csv 然后定义dir和 transform  ——len——  ——getitem——  对于dataloader 设置加载方式 batch shuffle  多线程加速等</font></p>
</li>
<li><p><font color=lightgreen>layer</font></p>
<p>   <font color=lightgreen>Linear 就是一个layer 改变输入的最内层dim 的size 由输入的参数决定 注意我们的这个layer里面已经有预先设定好的bias 和 weight 相当于就是 对于图像可能就是一个 convolve </font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
<li><p><font color=lightgreen></font></p>
</li>
</ul>
</li>
<li><h3 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a><font color=pink>梯度下降算法</font></h3><ul>
<li>同步更新所有变量 </li>
<li>出发点是想要拟合一段数据 然后我们想让整个数据组的误差最小。因此我们求导。可以理解为山坡上寻找下降路线。由于公式会随着接近局部最小点而自己缩小前进距离这是一个学习。</li>
</ul>
</li>
<li><p><font color=seagreen>输入是一个特征向量 的函数求偏导本质就是我们在微积分里面学习的矢量函数求导链式法则 θ的每个分量看作一个维度 然后是复合函数求导</font></p>
</li>
</ul>
</li>
<li><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a><font color =violet>极大似然估计</font></h3><ul>
<li>就是我们依照描述的事件写出这个事件发生的概率表达式，这个表达式由一个变量（涉及概率密度）决定。我们想求这个变量使得改概率函数取一个最大值。</li>
</ul>
</li>
<li><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a><font color=Maroon>代价函数</font></h3><ul>
<li>感觉与目标函数类似，一般与误差函数具有相同或者相反的单调性，然后通过一些数学技巧进行改写，以简化计算。</li>
</ul>
</li>
<li><h3 id="Batch-Gradient-Descent"><a href="#Batch-Gradient-Descent" class="headerlink" title="Batch Gradient Descent"></a><font color=Teal>Batch Gradient Descent</font></h3><ul>
<li>这个就是传统的梯度下降，每一次前进时都要求遍历整个数据集来更新计算代价函数然后求偏导，计算量是非常巨大与难以实现的。具体原因我们会发现，偏导数求得的公式与每一个样本都有联系，例如差平方求和之类的。</li>
</ul>
</li>
<li><h3 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a><font color=Aqua>Linear Algebra</font></h3><ul>
<li>在此再次向Pro.Strang致以最崇高的敬意。</li>
</ul>
</li>
<li><h3 id="注意点——向量拓展的梯度下降以及向量函数"><a href="#注意点——向量拓展的梯度下降以及向量函数" class="headerlink" title="注意点——向量拓展的梯度下降以及向量函数"></a><font color=gold>注意点——向量拓展的梯度下降以及向量函数</font></h3><ul>
<li><p>注意函数变量的两个层面，一个是输入样本的维度，即样本向量的每一个维度，另一个是拟合函数中的变量即θ。h(x)(假设函数)&#x3D;θ0<em>1+θ1</em>x1 + θ2*x2+…… .eg 最后写成矩阵点积 多元线性回归</p>
</li>
<li><p>通常向量n+1 个 第0个是1为了简化表达 其余都是一个特征维度</p>
</li>
<li><p>根据上述结论重写表达式就是将θ化成对应n+1维向量然后求偏导时乘以一个xj^(i)的值。</p>
</li>
<li><p>比列失调的等高线梯度下降可能出现震荡，使用特征缩放相当于变量代换更高效将值约束在-1，1之间大约 还有归一化处理 使得平均值在0 x1-u1 代换 本质就是线性组合 u1 就是平均值 x1-u1&#x2F;s u1 就是平均值 s就是标准差 就是概率论</p>
</li>
<li><p>关于学习率α 过大可能会波动或者发散 国小很慢 总之尝试不同的一系列值</p>
</li>
<li><p>多项式回归 但是我还是有问题 函数都是人提出来 没有机器自己去寻找</p>
</li>
<li><h3 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a><font color=cyan>Normal Equation</font></h3><ul>
<li>线性代数永远的神，但是我已经忘记了~~~~~ 其实就是线代中的回归方程 男泵投影！！！！！</li>
<li>似乎用于线性回归，缺点：当n增大时会很慢 复杂度为3次方 而梯度下降可以正常的 大概10000为界限 例如 Word2vec 使用梯度下降法 而且只使用与线性 梯度是通法</li>
<li>pinv inv pinv 进阶求逆 可以是伪逆 可是当时没看</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="Deep-learning"><a href="#Deep-learning" class="headerlink" title="Deep learning"></a><font color=tan>Deep learning</font></h2><ul>
<li><p><font color=red>简介。机器学习就是找函数function.在台大的课中只会有梯度下降 梯度下降开始的值朴素的是随机的，但是可能存在更好的 初始值	全面的回归求解其实就是训练<br>模型就是我们提出的拟合方程 课程采用的是绝对值衡量</font></p>
</li>
<li><h2 id="piecewise-linear-curve所有线性的折线都可以用一组z来拟合-同理对于光滑的-我们可以无线细分-由piecewise-linear-curve-来逼近-进一步又由蓝色来逼近-！！！！！！！！！！！"><a href="#piecewise-linear-curve所有线性的折线都可以用一组z来拟合-同理对于光滑的-我们可以无线细分-由piecewise-linear-curve-来逼近-进一步又由蓝色来逼近-！！！！！！！！！！！" class="headerlink" title="piecewise linear curve所有线性的折线都可以用一组z来拟合 同理对于光滑的 我们可以无线细分 由piecewise linear curve 来逼近 进一步又由蓝色来逼近 ！！！！！！！！！！！"></a><font color=lavender>piecewise linear curve所有线性的折线都可以用一组z来拟合 同理对于光滑的 我们可以无线细分 由piecewise linear curve 来逼近 进一步又由蓝色来逼近 ！！！！！！！！！！！</font></h2></li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/efunc.png"
                     
                ></p>
</li>
<li><p>y&#x3D;csigmoid(b+wx);  hard sigmoid w slopes b shift  </p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/bff.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/beauti.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ddd.png"
                     
                ></p>
</li>
<li><p>sigmoid 的个数自己决定</p>
</li>
<li><p>实际的y帽 叫做 label</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/theta1.png"
                     
                ></p>
</li>
<li><p>batch 将N划分作batch随机的来求梯度</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/epoch.png"
                     
                ></p>
</li>
<li><p>epoch 是所有包都看了一遍 update就是一次更新 不一样</p>
</li>
<li><p>batch size learning rate 都是hyper parameter</p>
</li>
<li><p>ReLU rectified linear unit cmax(0,b+wx)就是hard sigmoid</p>
</li>
<li><p>就可以在所有sigmoid 使用的地方用ReLU</p>
</li>
<li><p>统称为activation function 老师都用的ReLU </p>
</li>
<li><p>可以多层进行变换 layers 就是得到a后再带入进去</p>
</li>
<li><p>多次ReLU 意思就是</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/network.png"
                     
                ></p>
</li>
</ul>
</li>
<li><p>为什么更深 乐 老师太好玩了！！！！</p>
</li>
<li><p>overfitting 过拟合问题 worse on unknown data</p>
</li>
<li><p>backpropagation </p>
</li>
<li><h3 id="anoconda-创建指令是全局的conda-create-然后可以在里面下载包-用vscode-启动可以-注意激活的时候要把代理关了"><a href="#anoconda-创建指令是全局的conda-create-然后可以在里面下载包-用vscode-启动可以-注意激活的时候要把代理关了" class="headerlink" title="anoconda 创建指令是全局的conda create 然后可以在里面下载包 用vscode 启动可以 注意激活的时候要把代理关了"></a><font color=pink>anoconda 创建指令是全局的conda create 然后可以在里面下载包 用vscode 启动可以 注意激活的时候要把代理关了</font></h3></li>
<li><h2 id="jupyter-notebook-guide"><a href="#jupyter-notebook-guide" class="headerlink" title="jupyter notebook guide"></a><a class="link"   href="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/install.html" >jupyter notebook guide <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2></li>
<li><p>jupyter 可以使用命令行调用 </p>
</li>
<li><pre><code class="python">jupyter notebook 然后就进入了browser
</code></pre>
</li>
<li><h2 id="Colab-使用"><a href="#Colab-使用" class="headerlink" title="Colab 使用"></a><strong><font color=slategray>Colab 使用</font></strong></h2><ul>
<li><p>python code 和 shell code 其中！接shell cmd cd除外 %cd</p>
</li>
<li><p>可以选择执行的硬件 GPU runtime type 里面</p>
</li>
<li><p>ctrl+ enter 执行一个代码cell</p>
</li>
<li><p>总体而言其实就是jupyter 只不过是个互联的jupyter.</p>
</li>
<li><p>左侧的文件图标查看结构 注意下载邮寄 可以上传到google硬盘</p>
</li>
<li><p>注意自己使用的时候是在google的GPU上 所以程序结束就会消失  注意自己保存</p>
</li>
<li><p><strong><font color=lightcyan>打开新的需要在file 里面upload notebook!!!! 可以的 注意一次只能有一个session 所以需要关掉前面的 notebook maybe<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/save.png"
                     
                >真的很不错一个tesla 真棒 然后我可以试试ssh之类的</font></strong></p>
</li>
<li><p><font color=yellow>然后现在发现了 ctrl+e 普通搜索很快 然后url 对url很快 因为对普通搜索会转换为我们的query 条目 然后会比较慢！！！</font></p>
</li>
<li><p><a class="link"   href="https://github.com/virginiakm1988/ML2022-Spring" >ML github repo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>pytorch tensor 相当于 array 可以GPU 加速</p>
</li>
<li><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a><font color=green>Pytorch</font></h2><ul>
<li>tensor就是高维数组 </li>
<li>还得复习一下基本的python 语法 list dict class func 基本的一些使用 顺便复习写一写爬虫</li>
<li>tensor constructor numpy zero tensor unit tensor</li>
<li>每个batch 的 loss funct 可能存在不同的差别</li>
<li>sigmoid 或者 Relu 叫做 neuron 总体叫做 neural network</li>
</ul>
</li>
<li><h2 id="Python-review"><a href="#Python-review" class="headerlink" title="Python review"></a><font color=purple>Python review</font></h2><ul>
<li><p>if var in list:  if var not in list:</p>
</li>
<li><p>if var1,var2 not in list；</p>
</li>
<li><p>for key,value in dict:</p>
</li>
<li><p>for key in sorted(dict.keys()):</p>
</li>
<li><p>for value in sorted(dict.values())</p>
</li>
<li><p>answer &#x3D; input(‘please enter your answer’)</p>
</li>
<li><p>int(input(‘how old are you’)) </p>
</li>
<li><p>f”{var1_has_defined} {var2_has_dafined}” mesg_to_be_printed&#x3D;f””</p>
</li>
<li><p>python 函数调用时候 可以直接指定 def fun(var1,var2): …… fun(var1&#x3D;yes,var2&#x3D;no) 但是一定要记住名字 不要出错</p>
</li>
<li><p>默认形参也是放在后面</p>
</li>
<li><p>while some_list:</p>
<p> ​	item&#x3D;list.pop()</p>
<p> ​	do_with(item)</p>
</li>
<li><p>dict[‘new_key’]&#x3D;new_value</p>
</li>
<li><p>def fun(list_para):…     fun(list[:]) 传递一个切片  函数都是引用一定会修改变量的</p>
</li>
<li><p>可变形参 def func(*tuple_para): def func2(size,**dict_para):</p>
</li>
<li><h3 id="Class-in-Python"><a href="#Class-in-Python" class="headerlink" title="Class in Python"></a><font color=maroon>Class in Python</font></h3></li>
<li><p>class my_class(): 开头的书写方法</p>
<ul>
<li>def __init(self,para1,para2)__	self 必须第一个</li>
<li>然后接着是 self.para&#x3D;para(实际传入实例类的形参)这样写之后this 相当于才拥有这些成员</li>
<li>​	普通方法 def member_func(self): 不要忘记了self</li>
<li>如果要有具有默认初始值的属性 可以直接在__init()__ 下面进行写 self.prop&#x3D;1000 prop 不用出现在init括号里面</li>
<li><font color=aqua>继承</font></li>
<li>首先必须括号里写明继承的类 class derived(base):</li>
<li>super()._<em>init(para,para,para)</em>_注意里面没有self 继承全部内容</li>
<li>自己属性接着写就可以</li>
<li>可以重写父类方法 名字不同就可以</li>
<li>可以类实例作为成员 self.class_mem&#x3D;classA()</li>
</ul>
</li>
<li><p>这个 <strong>init</strong> 不是必须的方法 只是用来定制实例化时 类似的还有 _<em>self</em>_  _<em>next</em>_  等用来控制 迭代器的 同时呢 生成器 generator 是一个综合了上面方法功能的函数 yield  generator expression</p>
</li>
</ul>
</li>
<li><p><font color=green>文件操作</font></p>
<ul>
<li>with open(‘filename’) as name:  不需要close了 因为with</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong><font color=cornsilk>工具</font></strong></h2><pre><code>    *  training data 上的loss过大
</code></pre>
<ul>
<li>Model bias 就是 我们的函数太简单 解决方法 一 增加 特征量 二 增加layer deep learning</li>
<li>优化问题 梯度下降的问题</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/optm.png"
                     
                ></li>
<li>怎么解决 优化的问题 next lecgt</li>
<li>一定区分 overfitting 和 优化问题 一个是test data 一个是 training data<ul>
<li>overfitting <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/freestyle.png"
                     
                ></li>
<li>解决方法 增加 training data 二 data augmentation 就是自己创造一些条件 创造一些资料 需要有道理</li>
<li>减小弹性 增加限制</li>
<li>full- connected比较有弹性目前我们讨论的； CNN 比较无弹性<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/stop.png"
                     
                ></li>
</ul>
</li>
<li>区分 overfitting 与 model bias  存在一个complexity 与 bias 关系</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/trade.png"
                     
                ></li>
<li>刚刚好的<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/aaa1.png"
                     
                ></li>
<li></li>
</ul>
</li>
<li><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><font color=pink>Tips</font></h3><ul>
<li><font color=mediumspringgreen>critical point saddle point &amp; local minima 前者更多 通过hessian 矩阵来判断 特征值来判断 全正或者全负local其余就是saddle point</font></li>
<li><font color=mediumspringgreen>针对local point 的方法 batch size  一般来说越小noise 越多但实际上更好 但是在并行计算下可能更慢 第二 momentum 惯性一样的下一步加成</font></li>
<li><font color=mediumspringgreen>learning rate 的问题 有一个方法 叫做 Adam Optimizer 就是RSM 加上 momentum 的结合 可以动态改变learning rate 。 也就是说我们的learning rate可能也是 loss stuck的原因，而非 critical point </font></li>
<li><font color=mediumspringgreen>loss 函数也有影响 对于分类问题而言 使用最多的 是 cross entrophy 原来是用似然函数 好处就是 可以将整个surface 放得平缓</font></li>
<li><font color=mediumspringgreen><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Fea.png"
                     
                >理解权重影响的问题 和这个surface是怎么来的 我们要不断修正的是w1 w2  mean 就是平均值 standard deviation 就是标准差 标准化  数学的影响就是 loss converge 收敛更快 但是还是有个问题，在实际的多层神经网络中 每经过一层 可能分别差别又会变大 所以我们还是需要不断地进行normalization 可以是activationfunc 之前 也可以之后 sigmoid 最好之前 因为可以化到-1 1 之间使得函数的值变化比较大<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/norm.png"
                     
                > 这个优化提升的是训练速度 主要是<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/arx.png"
                     
                ></font></li>
<li><font color=mediumspringgreen>CNN 卷积神经网影像处理，一个图像就是一个RGB的三位channel 的tensor 就是一个高维的叠加的数组 拉直就是一个向量 但是我们一般不会全部进行训练 我们会进行一定的相关的简化receptive field 这样做的一个理论 就是探查pattern 用pattern 去进行识别</font></li>
<li><font color=mediumspringgreen>一般通常选取都是三个channel 然后此时的长宽称为kernel size 3X3 通常就可以了 stride hyper para 超出的部分进行padding <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/stri.png"
                     
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/filter.png"
                     
                ></font></li>
<li><font color=mediumspringgreen>fully connected layer弹性最大  receptive field 共享参数 减小了弹性这两个加起来就是convolution al layer 对应的就叫 CNN model bias 较大<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/fmap.png"
                     
                >这里的channel变成了neuron 的个数了</font></li>
<li><font color=mediumspringgreen>pooling 方法 max pooling  的方法 为了减少运算量 现在开始减少了<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/CNN.png"
                     
                >下面那个是flatter 还有一个重要应用 就是 playing go</font></li>
<li><font color=mediumspringgreen>分类问题softmax的原因简单解释 就是 我们用one-hot 向量表示我们的类 然后用1 然后我们将softmax 将其转换为-1 到 1 当然我觉得可能还是因为概率分布的问题就是越大的比例越大</font></li>
</ul>
</li>
<li><h2 id="self-attention-自注意"><a href="#self-attention-自注意" class="headerlink" title="self-attention 自注意"></a>self-attention 自注意</h2><ul>
<li><font color=pink>问题引入 加入我们处理的input data是一个向量序列 而不是一个向量。 对应的输入也有不同的种类。比如说输入的每一个向量都计算一个label 例如判断文本每个单词的 词性 或者类似的分裂问题 。或者一个输出 比如对一句话进行定义  反正应用情形自己去想象 最复杂也许是seq2seq 输出的已是一个序列 例如翻译</font></li>
<li><font color=pink>sequence labeling 如果仅仅使用前面的network 然后单独输入的话存在一个巨大的问题就是无法做到考虑上下文使用情形有限</font></li>
<li><font color=pink>attention is all you need <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/matr.png"
                     
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/attention.png"
                     
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/multi.png"
                     
                ></font></li>
</ul>
</li>
<li><h2 id="Seq2seq"><a href="#Seq2seq" class="headerlink" title="Seq2seq"></a>Seq2seq</h2><ul>
<li><font color=pink>encoder FFN feed forward network </font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
<li><font color=pink></font></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA</title>
    <url>/2023/10/24/CUDA/</url>
    <content><![CDATA[<h1 id="CUDA-amp-Algorithm"><a href="#CUDA-amp-Algorithm" class="headerlink" title="CUDA&amp;Algorithm"></a><strong><font color=darkturquoise>CUDA&amp;Algorithm</font></strong></h1><ul>
<li><h2 id="Prelace"><a href="#Prelace" class="headerlink" title="Prelace"></a><font color=pink>Prelace</font></h2><p><strong><font color=mediumaquamarine>希望通过CUDA走进计算的前言，并且加深我对计算机体系结构的认知。同时从另一条路走进我们的machine learning 与 deep learning.同时也在这里写下一些算法的学习知识。</font></strong></p>
</li>
<li><h2 id="F-amp-Q"><a href="#F-amp-Q" class="headerlink" title="F&amp;Q"></a><font color=DarkSeagreen>F&amp;Q</font></h2><ul>
<li><p>内存布局具体硬件实现忘了，忘了栈实际上是在cache还是memory里</p>
</li>
<li><p>nvidia-smi 才是查看设别的指令 nvidia-smi -q 不错 </p>
</li>
<li><p>nvprof 已经弃用了 ncu（nsight-compute) 现在是profiler</p>
</li>
<li><p>nsight-compute 需要 全局安装 sudo apt install -y 选项<a class="link"   href="https://developer.nvidia.com/nvidia-development-tools-solutions-err_nvgpuctrperm-permission-issue-performance-counters#AllUsersTag" >issue <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><font color=pink>driver 是一个硬件用来显示的   tookit就是一个集合 有些下载method可以同时下载适配的 driver 总结就是除了会安装还要学会卸载</font></p>
</li>
<li><p>These instructions must be used if you are installing in a WSL environment. Do not use the Ubuntu instructions in this case; it is important to not install the <code>cuda-drivers</code> packages within the WSL environment. <font color=red>乐死</font></p>
</li>
<li><p>Installation using RPM or Debian packages interfaces with your system’s package management system. When using RPM or Debian local repo installers, the downloaded package contains a repository snapshot stored on the local filesystem in &#x2F;var&#x2F;. Such a package only informs the package manager where to find the actual installation packages, but will not install them.</p>
<p>If the online network repository is enabled, RPM or Debian packages will be automatically downloaded at installation time using the package manager: apt-get, dnf, yum, or zypper.</p>
</li>
<li><p>安装是很复杂的 wsl有单独的教程 然后就是 有 post-installation mandatory actions !!</p>
</li>
<li><p>The <code>PATH</code> variable needs to include <code>export PATH=/usr/local/cuda-12./bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</code>. Nsight Compute has moved to <code>/opt/nvidia/nsight-compute/</code> only in rpm&#x2F;deb installation method. When using <code>.run</code> installer it is still located under <code>/usr/local/cuda-12.2/</code>.<font color=cyan>记住这个路径问题 在opt里面</font></p>
</li>
<li><p><font color=pink>妈妈我终于解决这个问题了 就是我在安装后没有设置环境变量 啊啊啊啊啊啊 男泵</font></p>
</li>
<li><p><a class="link"   href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#post-installation-actions" >今后还可能出现的 问题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>开始在vscode 里面进行配置 nsight debug</p>
</li>
<li><p>ctrl + space </p>
</li>
<li><p>命令面板很好用目前看来 ctrl shift + p</p>
<h2 id="我修改了提示-ctrl-t-s-好有用啊-还有就是控制面板太好用了有很多提示键-然后-task-也可以在里面选择生成"><a href="#我修改了提示-ctrl-t-s-好有用啊-还有就是控制面板太好用了有很多提示键-然后-task-也可以在里面选择生成" class="headerlink" title="我修改了提示 ctrl + t + s 好有用啊 还有就是控制面板太好用了有很多提示键 然后 task 也可以在里面选择生成"></a>我修改了提示 ctrl + t + s 好有用啊 还有就是控制面板太好用了有很多提示键 然后 task 也可以在里面选择生成</h2><ul>
<li><strong>[launch attach&amp; launch.json entry](<a class="link"   href="https://code.visualstudio.com/docs/editor/debugging" >Debugging in Visual Studio Code <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</strong></li>
</ul>
</li>
<li><p>dropdown configuration 就是下落的可以滑动的竖直设置栏</p>
</li>
<li><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a><a class="link"   href="https://code.visualstudio.com/docs/editor/variables-reference" >预定义变量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3></li>
<li><h3 id="最新发现-ctrl-alt-n-code-runner-似乎无所不能-但是不能调试只是"><a href="#最新发现-ctrl-alt-n-code-runner-似乎无所不能-但是不能调试只是" class="headerlink" title="最新发现 ctrl alt n code runner 似乎无所不能 但是不能调试只是"></a>最新发现 ctrl alt n code runner 似乎无所不能 但是不能调试只是</h3></li>
<li><p>program 就是 要debug的文件</p>
<ul>
<li><p><font color=gold>注意这个launch 是调试 要先生成可执行文件 也就是task 先配置的是task 然后是 launch.json</font></p>
</li>
<li><p><font color=green>重点出现了 发现可能的解决方案 就是prelaunch task 原来之前的是task 在debug后运行或者至少同时</font></p>
</li>
<li><p><font color=yellow>原来c_cpp_pr 是C++插件的配置文件不会影响</font></p>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="Heterogeneous-Computing"><a href="#Heterogeneous-Computing" class="headerlink" title="Heterogeneous Computing"></a><strong><font color=tan>Heterogeneous Computing</font></strong></h2><ul>
<li><p><font color=teal>host指cpu，host codes run in CPU ,CPU code is responsible for managing the code and environment and device code running in GPUs.</font></p>
</li>
<li><p><font color=cornsilk>common GPU architectur GeForce Tesla and Fermi in Tesla  Tesla professional hpc. GeForce consumer GPUs</font></p>
</li>
<li><p><font color =cornsilk>two metrics to discribe the GPU compute capability .the core no. and the memory</font></p>
</li>
<li><p><font color =cornsilk>互补的 CPU 逻辑复杂 擅长分支预测控制流切换 GPU 擅长大量数据 简单控制 并行计算 Threads of CPU are heavyweighted 上下文切换开销大。 GPU就是相对轻量级 的</font></p>
</li>
<li><p><font color =cornsilk>CUDA driver API and CUDA runtime API 我们一般使用 runtime API cuda codes 包含两个部分 一个是host code 另一个是device code </font></p>
</li>
<li><p><font color =cornsilk>kernels 就是device code 里的并行函数由 nvcc 编译 nvcc 会区分host code and device code 然后就是完全分开执行 good<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cucode.png"
                     
                ></font></p>
</li>
<li><p><font color =cornsilk>hello from GPU GPU program structure 5 steps 分配显存 加载数据 invoke kernel 返回数据 销毁显存</font></p>
</li>
<li><p><font color =cornsilk>locality temporal locality and spatial locality 这是编写cpu程序注意的 而GPU 将存储架构和线程结构都展示给程序员</font></p>
</li>
<li><p><font color =cornsilk>three key abstractions 三个关键抽象对于GPU 1. hierarchy of thread groups 2. hierarchy of memory 3. barrier synchronization </font></p>
</li>
<li><p><font color=cornsilk><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/nvcc.png"
                     
                >nvcc 支持的文件后缀 .c 普通的是可以编译的</font></p>
</li>
<li><p><font color=cornsilk>programming model 其实就是 抽象 通过使用compiler and library &amp; OS 对hardware architecture 的抽象   scalability 可拓展性</font></p>
</li>
<li><p><font color=cornsilk>Host CPU and its memory ; Device : GPUs and its memory eg h_ for host m; d_ for device space</font></p>
</li>
<li><p><font color=cornsilk>Kernel 即跑在GPU 的codes我们可以看作是一个普通函数 实际上 GPU将其分配在多个线程上同时运行 ，当kernel运行后控制会立马交还给cpu以开始其他工作 异步工作。serial code 串行码 complemented by parallel code</font></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Memory management */</span></span><br><span class="line"><span class="built_in">malloc</span>(); -&gt; <span class="built_in">cudaMalloc</span>();</span><br><span class="line"><span class="built_in">memcpy</span>(); -&gt; <span class="built_in">cudaMemcpy</span>();</span><br><span class="line"><span class="built_in">cudaMemset</span>();</span><br><span class="line"><span class="built_in">cudaFree</span>();	<span class="comment">// all in device memory which is seperated from host memery!!</span></span><br><span class="line"><span class="comment">// the signature of the func</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="type">void</span>**devPtr,<span class="type">size_t</span> size)</span></span>;<span class="comment">// the pointer is returned in the devPtr</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span> <span class="params">( <span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count,cudaMemcpyKind kind )</span> <span class="comment">// the kind takes one of the following types cudaMemcpyHostToHost --HostToDevice --Dev2Dev D2H this func 是同步的 host 会阻塞知道完成</span></span></span><br><span class="line"><span class="function"><span class="comment">// cudaError_t enumerated type include cudaSuccess .eg </span></span></span><br><span class="line"><span class="function">    <span class="type">char</span>*<span class="title">cudaGetErrorString</span><span class="params">(cudaError_t error)</span></span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><font color=cornsilk>Global memory and shared memory in device just like memory and cache in CPU 前面的分配的函数都是在global memory 里面就像我们的malloc一样 目前我们所知道的由于这样内存分类 对应的指针是不能类型转换的，只能用cudaMemcpy来完成转移 后期由unified memory</font></p>
</li>
<li><p><font color=cornsilk><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/bg.png"
                     
                >通常而言 grid是二维 block是三维  blockDim gridDim dim3 type 没有初始化的filed自动为1</font></p>
</li>
<li><p><font color=cornsilk>P88 warp执行模型 32 个thread 硬件层面都会变成 warp 然后分散在SM上执行 之所以可以是主要是内存资源决定的 32 cores是共享的 前面说到多个warp scheduler 调度将warp的一个指令放到16core的一个组合上运行 其中register file 决定了warp 数量 shared memory 决定sm的block数量 然后warp切换上下文没有开销 都是data分割的 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/limiter.png"
                     
                ></font></p>
</li>
<li><p><font color=cornsilk><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/warp.png"
                     
                >warp 注意4 这个数字是由架构中每个SM的scheduler决定的 stall warp eligible warp 因此我们要最大化active warps</font></p>
</li>
<li><p><strong><font color=mediumseagreen>divergence 会执行所有分支 我们将分支按warp 划分</font></strong></p>
</li>
<li><p><strong><font color=pink>latency hiding <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/latency.png"
                     
                >类似于CPU的调度 latency就是时间 一般用clock cycle 计算大小</font></strong></p>
<ul>
<li><font color=cornsilk>P91 有趣的排队理论 就是需要同时并行的操作数&#x3D;延迟（cycle）*预期throughput throughput 与 bandwidth used interchangably bandwidth refer to as peak data transfer per time unit throughput refer to as any operations       rate metrics都是throughput单位 ops per cycle per SM 也可以进一步用warps表示也就是&#x2F;32 so the underlying thing of latency hidding is that you should increase the parallesiem to move like sequential ops without waiting </font></li>
</ul>
</li>
<li><p><font color=pink>latency hidding 总体而言需要更多的并行操作也就是需要更多的active warps 但是这个数量又是由memory and register 限制的所以configuration 很重要</font></p>
</li>
<li><p><font color=cornsilk>有趣的建议 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/tipss.png"
                     
                ></font></p>
</li>
<li><p><font color=cornsilk>一些使用CUDA 的建议 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/bsize.png"
                     
                >太大的block size 会使每个thread硬件资源很少 太小的 block size warp 数量太少</font></p>
</li>
</ul>
</li>
<li><h2 id="GPU-ARCH"><a href="#GPU-ARCH" class="headerlink" title="GPU ARCH"></a><font color=Pink>GPU ARCH</font></h2><ul>
<li><strong><font color=cyan>The GPU architecture is built around a scalable array of <em>Streaming Multiprocessors</em> (SM). GPU hardware parallelism is achieved through the replication of this architectural building block. </font></strong></li>
<li><strong><font color=cyan>P 68我们先可以把SM看作一个比较强的硬件 一个grid 对应一个 kernel 一个grid的block可以分配到多个 SMs 然后一个SM 可以有多个block 也可能来自不同的grid(kernel 并发)每一个线程都具有流水线</font></strong></li>
<li><strong><font color=cyan>SIMT warp为一个基本管理 thread warp中每一个线程的内存与寄存器与计算资源都是独立的 SM将 block划分为warps 所以最好为32的倍数</font></strong></li>
<li><strong><font color=cyan>Even though all threads in a warp start together at the same program address, it is possible for individual threads to have different behavior. SIMT enables you to write thread-level </font></strong></li>
<li><strong><font color=cyan><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/SM.png"
                     
                ></font></strong></li>
<li><strong><font color=red>一个block只能安排在一个SMs！！！记住知道执行结束都在一个SMs 同样的一个SM可以同时有多个block</font></strong><ul>
<li><strong><font color=cyan>一个grid其实就是整个device了只是支持kernel的并行操纵 然后有个SM商店 shared memory 按照block划分 register 几万个按照thread划分因此 一个block间的thread可以shared mem 交流 While all threads in a thread block run logically in parallel, not all threads can execute physically at the same time. As a result, different threads in a thread block may make progress at a different pace.同一个block中的thread以warp执行 所以实际没有物理并行 这里可能会在 shared mem访存时出现竞争 CUDA提供了block内部的同步函数 但是多个block 之间没有提供同步函数 </font></strong></li>
</ul>
</li>
<li><strong><font color=cyan>一个core通常有一个整数ALU和浮点ALU <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/device.png"
                     
                >gigathread 就是全局的安排block到SM的</font></strong></li>
<li><strong><font color=cyan>two warps and issue one instruction from each warp to a group of 16 CUDA cores, 16 load&#x2F;store units, or 4 special function units (illustrated in Figure 3-4). The Fermi architecture, compute capability 2.x, can simultaneously handle 48 warps per SM for a total of 1,536 threads resident in a single SM at a time. 我们的这个关键就是 分组 其实有四个组合 然后选择其中一个一个作为执行选项 然后对于两个warp scheduler 就是两条流水线 然后其实每一组调度都可以看作是并行的了 不用再去管物理上的运行了上面说的48 个warp就是 同时dispatch 48 个 而不是同时运行 48个</font></strong></li>
<li><strong><font color=cyan>64KB memory 被分成了shared memory 和L1 cache两者关系运行更改通过runtime API </font></strong></li>
<li><strong><font color=red>Fermi also supports concurrent kernel execution: <font color=bluseagreen>multiple kernels launched from the same applicationtion context executing on the same GPU at the same time.</font> Concurrent kernel execution allows programs that execute a number of small kernels to fully utilize the GPU, as illustrated in Figure 3-5. Fermi allows up to 16 kernels to be run on the device at the same time. Concurrent kernel execution makes the GPU appear more like a MIMD architecture from the programmer’s perspective.<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/conc.png"
                     
                ></font></strong></li>
<li><strong><font color=cyan>LD&#x2F;ST 使用来进行转换地址的单元 16 个也是因为并行的原因</font></strong></li>
<li><strong><font color=cyan>kepler dynamic parallelism 允许 nested kernel invoke ; Hyper-Q 避免一个失败的kernel 调用 idle CPU 太长时间 多个task queue</font></strong></li>
<li><strong><font color=cyan>P 79 nvprof profiling driven 性能测试初步 类似linux里的一个 profile Event and metric</font></strong></li>
<li><strong><font color=cyan>memory bandwidth; compute resource ; latency</font></strong></li>
<li><strong><font color=cyan>Warps are the basic unit of execution in an SM. When you launch a grid of thread blocks, the thread blocks in the grid are distributed among SMs.  就是可以多个相同grid block在一个SM，也可以一个SM有来自不同block 最终硬件上都是一维</font></strong></li>
<li><strong><font color=cyan>warp 的划分原则 consecutive threadIdx.x !! 最后是向上取取整warps 如果非整数倍会出现空闲的不活跃thread 但是仍然会消耗占用硬件自资源也就是最终都是一维的硬件实现</font></strong></li>
<li><strong><font color=cyan>Warp Divergence 就是分支判断的问题 会 连串掩码式地执行 在优化等级较高时时间开销接近正常 解决就是 让一个分支用warp size 与运行</font></strong></li>
<li><strong><font color=cyan><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/reso.png"
                     
                >仔细想想居然很大程度上我们的这两个是独立影响的</font></strong></li>
<li><strong><font color=cyan>P89 A thread block is called an <em>active block</em> when compute resources, such as registers and shared memory, have been allocated to it. The warps it contains are called <em>active warps</em>. Active warps can be further classifi ed into the following three types: 三种 selected warp stalled warp eligible warp selected 不多于4个 是不是类似于我所说的流水线 4个选项 </font></strong></li>
<li><strong><font color=cyan>block太小 可以认为与大block相比同样的共享内存能偶拥有的thread 数量较少 所有register等没有充分利用 ；太大，线程太多，没有足够的thread</font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
<li><strong><font color=cyan></font></strong></li>
</ul>
</li>
<li><h2 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a><font color=slatecyan>Synchronization</font></h2><ul>
<li><strong><font color=cornsilk>两个层面 host and device 2 thread </font></strong></li>
</ul>
</li>
<li><p><strong><font color=cornsilk><strong>device</strong> void __syncthreads(void) 一个让同一个block 的线程同步的函数</font></strong></p>
</li>
<li><ul>
<li><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a><font color=yellow>Configuration</font></h2></li>
<li><p><strong><font color=cornsilk>配置函数 对于 blockdim 的innermost x 一般是32 的倍数 这个是有 warp 决定的 同时 一个block的thread数量不能超过 1024</font></strong></p>
</li>
<li><p><strong><font color=cornsilk>通常而言 block 数量越多 并行度越高 但是load throughput会下降 但是load efficency 更高 具有更高的achieved occupancy 但是实际上 由于 block 数量的限制反而会限制active warp </font></strong></p>
</li>
<li><p><strong><font color=cornsilk><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/bal.png"
                     
                ></font></strong></p>
</li>
<li><p><strong><font color=cornsilk>第一个常见的算法就是 reduction 树形结构</font></strong></p>
</li>
<li><p><strong><font color=cornsilk>有 neighbor reduction 和 interleave reduction 后者拥有更好的global memory的局部性所以性能更好</font></strong></p>
</li>
<li><p><strong><font color=cornsilk>unrolling loop 同样的一个方法循环展开真的非常快 wtf 注意这里是Unrolling loop 注意 同步函数是用来进行 一个block 之间的同步的 block之间无法同步 </font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
<li><p><strong><font color=cornsilk></font></strong></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>佩索呀</title>
    <url>/2023/10/29/%E4%BD%A9%E7%B4%A2%E5%91%80/</url>
    <content><![CDATA[<h3 id="Darling-I-‘m-getting-older-亲爱的，我原来也会变老"><a href="#Darling-I-‘m-getting-older-亲爱的，我原来也会变老" class="headerlink" title="Darling . I ‘m getting older. (亲爱的，我原来也会变老)"></a>Darling . I ‘m getting older. (亲爱的，我原来也会变老)</h3><ul>
<li><p>Everyday poetry.</p>
</li>
<li><p><a class="link"   href="https://poets.us20.list-manage.com/track/click?u=e329a0cb6f08842f08a05d822&id=50cda6fc43&e=dce612a19d" >Sippokni Sia <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a href="https://poets.us20.list-manage.com/track/click?u=e329a0cb6f08842f08a05d822&id=a7f92fa877&e=dce612a19d"><strong>Winnie Lewis Gravitt</strong></a></p>
<p>I am old, Sippokni sia. Before my eyes run many years, Like panting runners in a race. Like a weary runner, the years lag; Eyes grow dim, blind with wood smoke; A handkerchief binds my head, For I am old. Sippokni sia.Hands, once quick to weave and spin; Strong to fan the tanchi; Fingers patient to shape dirt bowls; Loving to sew hunting shirt; Now, like oak twigs twisted. I sit and rock my grandson. I am old. Sippokni sia.Feet swift as wind o’er young cane shoots; Like stirring leaves in ta falla dance; Slim like rabbits in leather shoes; Now moves like winter snows, Like melting snows on the Cavanaugh. In the door I sit, my feet in spring water. I am old. Sippokni sia.Black like crow’s feather, my hair. Long and straight like hanging rope; My people proud and young. Now like hickory ashes in my hair, Like ashes of old camp fire in rain. Much civilization bow my people; Sorrow, grief and trouble sit like blackbirds on fence. I am old. Sippokni sia hoke.</p>
<ul>
<li>我不知道人们所说的衰老是什么样子的，也许是透过镜子发现曾经的皮肤已经松弛下垂，也许当他们发现他们跑不过一个最小的孩子，但我感觉衰老是发生在一瞬间，仅仅一瞬间，就像过了一辈子，只是从前漫长的岁月从未被老去的忧伤笼罩，就像山顶的雾终于散去，时间失去了从前的神秘。</li>
<li>告别，寻找告别</li>
<li>春天总是一去不返</li>
<li>无法思考，无法摆脱，3点，神秘力量，是她吗……</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>自然</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm</title>
    <url>/2023/11/02/Algorithm/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a><font color=yellow>Algorithm</font></h1><ul>
<li><strong><font color=seagreen>最近点对问题</font></strong><ul>
<li><font color=pink>分治法求解 垂直线分割 实际使用时可以对应实际的问题进行优化 比如使用一个 strip  然后可以在递归的最底层加入一个全局的区间值的判断 双重循环 但是每一层都是O(n^1&#x2F;2)判断方法是否存在在特殊情况失效 例如几乎垂直或者水平的点对。所以可以单独的进行筛选 类似机器学习的算法的改进 多个维度通道 简化的一些思想 </font></li>
<li><font color=pink>对称性思想 每一个维度都是一样的</font></li>
<li><font color=pink>建表  对于频繁使用的信息进行见表索引检索哈希码 向量 量化处理</font></li>
<li><font color=pink>曼哈顿距离</font></li>
</ul>
</li>
<li><strong><font color=seagreen>概率分析与随机算法</font></strong><ul>
<li><font color=pink></font></li>
</ul>
</li>
<li><strong><font color=seagreen>正太分布问题思考</font></strong><ul>
<li><font color=pink>解决一种问题 就是关于某个中心点对称任何维度的可能性相同。 同时随着偏离中心概率减小 关键就在于与角度无关 非常的厉害</font></li>
</ul>
</li>
<li><strong><font color=seagreen>随机问题</font></strong><ul>
<li><font color=pink>随机生成一个数组的方法 一 可以为每个元素生成一个优先级 然后根据rank 进行排序</font></li>
</ul>
</li>
<li><strong><font color=seagreen>排队论</font></strong><ul>
<li><font color=pink>所有人排在一起，那个窗口空去哪个</font></li>
</ul>
</li>
<li><strong><font color=seagreen>同时获得最大值和最小值</font></strong><ul>
<li><font color=pink>同时维护两个值比较 n-1</font></li>
</ul>
</li>
<li><strong><font color=seagreen>活动安排问题</font></strong><ul>
<li><font color=pink>选择一个拥有最多活动的集合 集合的实践区间不存在重叠。使用贪婪算法，按照结束时间排序，然后每次都加入最早结束的时间 最核心的地方就是按结束时间思考，存在多解问题，原因在于开始阶段。</font></li>
</ul>
</li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
<li><strong><font color=seagreen></font></strong></li>
</ul>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Winter</title>
    <url>/2023/11/21/Winter/</url>
    <content><![CDATA[<h2 id="Winter"><a href="#Winter" class="headerlink" title="Winter"></a><font color=violet>Winter</font></h2><blockquote>
<p>我是未来世界唯一的程序员。这是一条来自未来的讯息。在我的时代，支配世界的算法被我洞晓。过去的人啦，想要改变未来吗？去探索吧，这个世界背后运行的真理！						—— 2079 . 12 . 24 </p>
</blockquote>
<p><strong><font color=deepskyblue>世界の仕組みについての真実を理解しました</font></strong></p>
]]></content>
      <tags>
        <tag>自然</tag>
      </tags>
  </entry>
  <entry>
    <title>DL</title>
    <url>/2023/11/23/DL/</url>
    <content><![CDATA[<h2 id="Deep-learning-premier"><a href="#Deep-learning-premier" class="headerlink" title="Deep learning premier"></a><font color=pink>Deep learning premier</font></h2><p><font color =violet>志を受け継ぎ世界と戦う</font></p>
<ul>
<li><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a><font color=lightgreen>Transformer</font></h2><p>transformer是什么？变形金刚！！！ 好吧transformer 是用来解决seq2seq的一个模型。 seq2seq是一种模式，一些常见的情形：翻译，听译，语音辨识，听译 男泵 万恶之源 硬train一发 chatbot 之类的也是</p>
<p>BOS</p>
<ul>
<li><p>NLP QA模式 问题回答的一种模式</p>
</li>
<li><p>multi-label 就是每一个输入对象可能身上有多个标签</p>
</li>
<li><p>transformer 就是求解s2s的一个模型 encoder 和 decoder</p>
</li>
<li><p>residual connection 这个是与self attention 不一样的地方把input 和 output加起来</p>
</li>
<li><p>为什么能够应对seq2seq的情况</p>
<p>输入有两个部分 一部分来则于自己之前的输出</p>
<p>masked -attention 为什么需要</p>
<p>单纯看自己的输入作为输出的时候不可能停止下来，机，器，学。习。惯…… 首先我们需要准备以恶搞special toke as end(断) 所以原理就是让机器学习断，在该停止时候最大的概率输出end</p>
<p>上面是对于AT NAT是同时产生所有的输出 解决停止问题 有两个，第一个单独训练一个classifier来判断长度，方法二，传入很多begin token.忽略end 后的 输出 NAT 更好的并行化，可以控制长度 但是效果很难达到AT multi-modality</p>
<p>decoder 和 encoder的连接依靠一个叫做 cross-attention 的操作完成的就是 decoder 产生的向量q然后对每一个encoder的output k做kq，然后得到的新的v作为input丢到fc进行之后操作</p>
<p>train的时候采用分类的视角 计算向量之间的cross-entrophy 并且在训练情况下，我们给decoder的是正确的答案 就是一个监督 tearcher forcing </p>
<p>训练的一些 tips copy mechanism 例如chat-bot 将一些从来没有见过的词汇 直接进行复制 例如做摘要的时候 pointer network</p>
<p>TTS 语音合成 guide attention 就是规定 attention的顺序 有固定的过程 需要提前分享任务的特征monotonic attention</p>
<p>观察确定 我们的encoder 就是输出简单的数据 作为中间向量</p>
<p><font color=yellow>beam search</font> greedy path可能存在问题 局部最优不代表全局最优 类似于老师讲的王者问题 加入随机 decoder加一点 noise</p>
<p><font color=pink>BLEU score 用来检测inference 的指标但是训练的时候使用的是cross -entrophy 这两个没有关联的，没有相关性的blet score无法微分 一种策略使用 rl reinforcing learning reward与 agent来硬train一发</font></p>
<p><font color=cornsilk>在训练的时候加入一些错误的情况，scheduled sampling 也很直觉啊，面对错误的时候得到正确的这样学习应对错误的能力</font></p>
</li>
</ul>
</li>
<li><h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a><font color=deepskyblue>self-attention</font></h2><ul>
<li>q,k 矩阵学习 multi-head 就是分出多个 q 矩阵 然后得到bi,j 然后再处理成一个 positional embding , hand-crafted 目前的 目前是一个全新的领域 也可以学习。 self-attention 之间是没有位置关系的，然后q k 也不一定需要包含整个窗口</li>
</ul>
</li>
<li><h2 id="Batch-normalization"><a href="#Batch-normalization" class="headerlink" title="Batch normalization"></a><font color=salmon>Batch normalization</font></h2><p>layer norm 是对同一个feature(sample)不同的dim 进行计算 mean和 deviation 而 batch norm 是对所有不同的feature 的同一个dim 进行处理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/transf.png"
                     
                ></p>
<ul>
<li>position coding 位置资讯 </li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/bert.png"
                     
                ></li>
</ul>
</li>
<li><p>实际设计中还可以在顺序上进行变换 上述大概就是encode 结构</p>
</li>
<li><p>decoder</p>
<ul>
<li>bos （begin special token）特殊的符号 标记开始</li>
<li>masked self- attention 和通常的attention 有一些区别</li>
<li>为什么 因为decoder是一个一个产生的 在产生前面的输出时，后面的右边的输出还没有产生 无法考虑</li>
<li>autoregressive</li>
<li>自己不断运作，输出再次作为输入然后一直运行  存在停止的问题 方法就是设置另一个token 有时候与begin其实是同一个 实际实现可能是一个one-hot 向量，end也是自己产生的男泵</li>
<li>NAT non-autoregressive</li>
</ul>
</li>
<li><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a><font color=white>pytorch</font></h2><ul>
<li><p>总体流程就是，先定义我们的数据， dataset可以理解为存储我们的数据，feature 和 label ，然后dataloader 以我们想要的方式加载数据，自定义操作，包括batch ,还有 transform 等等。</p>
</li>
<li><p>然后就是定义 目标函数 loss ，以及一个优化器 optimizer ，有了之后定义 响应的train 和 test 函数 ，最后还有对模型的保存以及调用 和实际运用。</p>
</li>
<li><p>tensor (array)统一的却应用广泛的数据结构 ，就是一个高维数组，最外面的维度为dim&#x3D;0 注意顺序 然后基本上有外面可能用到的所有操作，只需要用时自己去找api 查资料就可以了。</p>
</li>
<li><p>dataloader &amp; dataset</p>
<ul>
<li>torch.utils.data.dataset torch.utils.data.dataloader 两个基本的提供的模块除此之外很多专门领域的domain-specified 的库都有自己的相关的。 注意一般来说,然后从我们的视角来看，就是一个数组 索引得到feature and label 同时得到。a,b&#x3D;dataset[index]大概这样，然后label 一般存在一个csv文件（逗号分隔文件里面）然后就自定义__init—— len getitem三个函数	init 的时候传入的 是一个annotation_file 和 dir 两个都是字符串，然后两个transform 函数一个transform 一个 target_transform</li>
<li>pandas 是一个数据处理  比如读取csv_file 之类 os 就是处理字符串之类的</li>
<li>dataloader 的每一次迭代返回两个tensor 对应feature和label</li>
<li>transform modify featu target_transform modify label<ul>
<li>常见的totensor 就是实现normalize 并且使得元素在0-1 之间。 vector lambda就是自定义操作</li>
</ul>
</li>
</ul>
</li>
<li><p>build the network</p>
<ul>
<li>torch.nn 所有存在的neuralnet的父类。 module其实就可以理解为layer 一个神经网络就可以理解为 a module itself that consists of other modules(layers) from torch import nn</li>
<li>第一步先check一下可不可以用硬件加速</li>
<li>然后继承 nn.Module 然后定义两个东西 init 和 forward方法</li>
<li>我们来break down and see every module拆解看看每一层<ul>
<li>flatten 在图形里面用来将一个image 矩阵转换为一个一维数组</li>
<li>linear 层就是进行一个线性转换 我们需要预先输入一个weigth 和 bias参数 然后对feature 进行变换</li>
<li><font color=pink>这里一个额外的补充知识点 就是call 特殊方法可以实现将类作为i函数调用 这就是为什么我们可以调用model，将数据作为参数输入进去 linear其实就是继承了nn.Module</font></li>
<li>妈的，我逐渐反应过来了，linear层里面的bias ,weight都是默认输出话，随机的其实，因为这个是我们要学习的参数，所以随机初始化就可以了。不需要什么预置输入</li>
<li>这里提前所以个东西 Relu 可以解决sigmoid 和tanh的过饱和问题缓解过拟合问题 也是目前默认激活函数</li>
<li>flatten默认改变的是最里面的层 没有改变channel 和batchsize</li>
<li>nn.sequential 就是一个layer的顺序容器 其实经过一个sequential 我们就可以发现输出了y 相当于fully connected network 啊男泵</li>
<li>nn.softmax 如果分类还需要过一层 注意通常要指定softmax操作的维度</li>
<li>parameter() named_parameters()这两个方法可以让神经网络追踪传入的参数哦从而进行学习</li>
<li>终于逐渐理解了</li>
</ul>
</li>
</ul>
</li>
<li><p>automatic differentiation</p>
<ul>
<li><p>关于tensor 的矩阵乘法 要了解到tensor最后面的参数一定是列向量 这个有点差异</p>
</li>
<li><p>parameter 就是我们需要进行optimize的 weight bias 都是。对于这些参数，我们需要优化，所以我们需要预先设定require_gradient ,默认是false</p>
<ul>
<li><p>然后调用Function 类，这个在每一个tensort 的 grad.fn 属性里存这一个指针，表示该tensor所使用的反向传播计算时的函数</p>
</li>
<li><p>在tensor的grad 里面维护的是计算得到的梯度值</p>
</li>
<li><p><font color=orange>所以现在我们可以这样理解forward就是利用model来进行计算，backword就是train，所以后面我们训练完成的时候，需要使用 with torch.no_grad()的方法</font></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/DAG.png"
                     
                ></p>
</li>
</ul>
<p>  现在来审视这个 DAG leaves is input tensor root is output tensor and the node is function !!!!!</p>
<ul>
<li>然后实际的是实现中我们使用了雅各布矩阵直接做矩阵乘法！！！</li>
</ul>
</li>
</ul>
</li>
<li><p><font color=violet>Optimizing model</font></p>
<ul>
<li>在上面的过程我们可以明白了，forward其实就是调用预测时候的算法，所以实际上就是直接调用我们的init 里面的层 然后返回就可以了</li>
<li><font color=cyan>在这里我们区分一下parameter ,就是在里面起作用的东西，hyperparameter 更像是一些设置配置参数 例如 learning rate ,batch size ,number of epochs</font><ul>
<li>loss function 。 对于回归问题我们通常使用的是MSELoss, 对于classification 我们通常使用的 是 negative  log likelihood NLLLoss 然后nn.crossentropyloss 就是 logsoftmax和NLLLoss的结合</li>
<li>我们前面学的adam rmsprop sgd 其实就是不同的optimizer 也就是minimize的时候使用的算法</li>
<li>实际运行的时候有三个步骤<ul>
<li>第一步就是先显式置零，同时自动累计grad,以免没重复加</li>
<li>第二步就是运行反向传播算法</li>
<li>第三步 调用.step()方法进行更新</li>
</ul>
</li>
<li>最后就是进行实现两个loop 一个train loop 一个 test loop</li>
</ul>
</li>
<li><font color=pink>Save and load the model</font><ul>
<li>组后要进行保存和加载的化调用响应的方法即可 ，然后注意两个东西就是.eavl() 模式的切换，记住这个是避免dropout和batch normalization 的一个东西</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="computational-graph"><a href="#computational-graph" class="headerlink" title="computational graph"></a><font color=salmon>computational graph</font></h2><ul>
<li><p>反向传播</p>
<p>前向传播和反向传播 forward and backward torch的抽象 forward 可以理解为求值 从input 到output 从leaf到root 反向传播就是求误差，根据链式法则求取偏导然后更新参数进行optimize。</p>
</li>
<li><p>torch的实际实现过程</p>
<p>根据我们对neuralnet 的定义  一个sequential 里面有很多layer，然后forward就是调用这个module ,在进行forward pass的时候会进行两件事情，第一件事就是按照要求计算得到output tensor第二件事就是建立其DAG，每个结点就是对应的求导函数，在后续的backward pass中调用进行求导</p>
<p> what you run is what you differentiate.</p>
<ul>
<li>tensor 需要保存，用来求导</li>
<li>对于数学上不可求导的函数或者是未定义情况有指定的数学方式来处理</li>
<li>先要阻止gradient 可以更改text manager mode 以及.eval(),同时要想控制子图subgraph的性质 可以对单个tensor 调用 require_grad</li>
<li>torch.nn 中parameter默认要求导，中间变量都会求导</li>
<li>现在终于懂了</li>
<li>lossfunction 进行 backward()相当宇求梯度然后得到grad值，optimizer 则是根据不同的类型操作 grad 进行更新所有  parameter  .step()就是进行一步 。 .zero_grad()就是重置tensor</li>
</ul>
</li>
<li><p>梯度消失和爆炸 的原因</p>
<p>我们在计算梯度的时候采用的是反向传播求取雅各布矩阵，由于很多hidden layer都会采用一些激活函数对于sigmoid而言，其倒数最大值为0.25 如果乘以w 后得到的积仍然小于1 如果很多小于1累计起来可能造成靠近输入层的参数更新极为缓慢，当然输出层的影响较小，爆炸则是产生NaN 或者不稳定。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="transformer-is-all-you-need"><a href="#transformer-is-all-you-need" class="headerlink" title="transformer is all you need"></a><font color=deepskyblue>transformer is all you need</font></h2><ul>
<li><font color=yellow>正向的 rnn 。 双向的rnn 可以正反同时读取我们的，</font></li>
<li>LSTM 关键四个们 标量也是用来学习的 每个单元可以用来替代之前的neuron 然后只是输入需要四倍，因为三个们和一个输入 。使用的是sigmoid 函数表示打开的程度。实际的模型还会在输入中参考中间步骤的输入</li>
<li>BPTT learning train  的 方法。考虑时间的关系。</li>
<li>train的问题 error surface存在很平坦到很陡峭的分界限，所以存在参数的抖动。 clipping 解决方案，就是为gradient 做一个上界，如果超过就直接等于。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>APSP</title>
    <url>/2023/12/05/APSP/</url>
    <content><![CDATA[<h1 id="APSP"><a href="#APSP" class="headerlink" title="APSP"></a><font color=deepskyblue>APSP</font></h1><ul>
<li><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a><font color=pink>Prerequisites</font></h2><ul>
<li><font color=yellow><a class="link"   href="https://www.bilibili.com/video/BV1YW411h7Pk/?spm_id_from=333.337.search-card.all.click&vd_source=c8c7f6103570a31005f12d5a33a60b47" >morphine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 先来一剂Green Day 牌吗啡！<br>在结尾处，准备总结一下实验的一些基本环境配置和有用链接以及FAQ留个之后看到这个网页以及遇到问题的人，所以如果是有问题需要解决可以先看看结尾。保证可以复现乐 : ) </font></li>
<li><a class="link"   href="https://cmake.org/cmake/help/latest/guide/tutorial/A%20Basic%20Starting%20Point.html" >Cmake <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><font color=yellow>熟悉cmake 的常见函数或命令以及了解下makefile 的原理 有点搞笑 我们的这个prefix 的路径似乎不能使用 ~ 而必须使用绝对路径 </font></li>
<li><a href="/doc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA.pdf">OpenMP</a><font color=yellow>OpenMP</font><ul>
<li><font color=lightgreen>首先，我们知道对于floyd算法的三层for循环中 ,最外层k 是无法并行化的，因为每一个k的路径比较依赖于已有的路径，需要顺序进行更新，但是内层i,j循环在src dest一定时，k 可以按照任何顺序选取所以是可并行的。因此private(i,j).</font></li>
<li><font color=lightgreen>OpenMP 原理 就是启用多线程，具体运行的时候可以跑在多核上，并行运算。底层就是pthread 实现的</font></li>
<li><font color=lightgreen>平衡负载，我采用的是dynamic ，不过可以多试试看看，static guide 都可以尝试，默认的也可以，感觉每次迭代的计算量似乎是随机的但是总体是均匀的 感觉static 应该就可以，dynamic 还是用在计算量会增加的比较好</font></li>
<li><font color=lightgreen>线程数的设置，过多会增大合并开销，同时还存在内存分配问题，降低效率，数量过少会导致并行度不够，根据我的猜想，看CUDA简介的经验，使用一个和迭代数以及某些硬件属性数的倍数或者因子书。32 64 之类的。问题不大，实践是检验真理的唯一方式，多试试就可以了，试了再来补充。</font></li>
<li><font color=lightgreen>编译器优化猜想，首先就是编译器可能帮我做了loop unrolling ,估计是fully peel the loop有可能。 然后就是寻址方式，依照CSAPP 上的，对于一个定长二维数组，确定一些基指针，然后使用定长进行改变。减少访存。然后就是使用局部变量来保存一些结果减少内存访问。同时也可能使用了一些向量化操作(AVX指令等等）。常熟计算(constant propgation)编译时计算，也就是constexpr。将小函数进行内联，但是本例中似乎不存在。</font></li>
<li><font color=lightgreen><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/omp.png"
                     
                ></font></li>
<li><font color=lightgreen>这个只是使用了最基本的for 内层循环并行，和负载动态分配</font></li>
<li><font color=lightgreen><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/simd_omp.png"
                     
                ></font></li>
<li><font color=lightgreen>这个比较客观，在第一次基础上使用了omp的 simd优化最内层循环。4096的加速比接近baseline的100倍，当然我这里选择的是64线程数 使用128线程差距不大。不过我个人感觉没有找到更好的方法进行线程数的调参。不知道有没有除了顺序试错外更高效准确的判断方法，还待我考察，欢迎学长指教。</font></li>
</ul>
</li>
<li><font color=yellow><a class="link"   href="https://arxiv.org/pdf/1811.01201.pdf" >AVX参考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>avx优化</font><ul>
<li><font color=lightgreen>使用的是AVX512，用一个 mask store 来实现比较运算。</font></li>
</ul>
</li>
</ul>
</li>
<li><p><font color=pink><a class="link"   href="https://www.jstage.jst.go.jp/article/transinf/E95.D/12/E95.D_2759/_pdf" >BFW <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>(算法优化——Blocked Floyd Algorithm</font></p>
<ul>
<li><font color=lightgreen>查找了一下资料，似乎这个可以提高数据的局部性，当然需要设置好所分的矩阵块的大小，使处理一个数据块的工作集内存大概等于 L2 cache .但是感觉实现这个算法本身加速比不是很明显，然后分块的话额外内存开销较多。（还有就是懒:) 所以就没有进行应用。</font></li>
</ul>
</li>
<li><p><font color=pink>Pthread接口实现多线程</font></p>
<ul>
<li><font color=lightgreen>可以，今天用pthread把内层两个循环并行处理了一下，加速比大概500倍。跑4096的图用了13s左右，我自己设置的线程数为<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Re1.png"
                     
                >这个时候文件夹还没改名，当然但就算法运行时间大概11s左右</font></li>
<li><font color=lightgreen>使用局部变量优化了一下 大概8s 多一点<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Re3.png"
                     
                ></font></li>
</ul>
</li>
<li><p><font color=pink>AVX512改写内层循环 速度大概2s提升 4倍</font></p>
<ul>
<li><font color=lightgreen>不过这里我有一个问题，就是理论上直接来看，应该会提升16倍，实际上只提升4倍左右，我自己猜测的原因是缓存问题，由于嵌套循环，存取的时候空间局部性不是很好，等后面有时间profile 一下。</font></li>
<li><font color=lightgreen><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/unrool.png"
                     
                >循环展开64 后 线程数 90 接近突破2s</font></li>
<li><font color=lightgreen>记录下首次突破 2s 作了128的循环展开 然后将线程数调到了100<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/2s.png"
                     
                >后续测试感觉 64循环展开 和 128差不多了。感觉实际上我们的128循环展开可能效果还差一点，因为使每一个线程的工作负载变大了。</font></li>
<li><font color=lightgreen>感觉实在找不到什么可以优化的地方了（在我目前所学的知识范围内）<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/final.png"
                     
                >大概在1.85s左右 悲。有一个分块floyd算法，改善局部性，感觉就单独实现而言，确实可以通过减少工作集内存的范围来提高空间局部性。但是因为涉及到要重写pthread,感觉反而会增加线程创建的开销。因为需要不断迭代子方块，然后进行pthread_create和pthread_join。</font></li>
<li><font color=lightgreen>本来想学一学使用 vtune 来剖析一下，似乎集群没有装，然后数据scp 命令没有使用权限，所以没有profile很多对性能的猜测都是自己的直觉 乐！</font></li>
<li><font color=lightgreen>至于GPU的算法，看了一下，似乎没有看到集群有装CUDA，所以没打算写，看后面有没有时间参考下资料看一看。</font></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>hpc</tag>
      </tags>
  </entry>
  <entry>
    <title>环形物语</title>
    <url>/2023/12/19/%E7%8E%AF%E5%BD%A2%E7%89%A9%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="Tales-from-the-Loop"><a href="#Tales-from-the-Loop" class="headerlink" title="Tales from  the Loop"></a><font color=deepskyblue>Tales from  the Loop</font></h1><h1 id="环形物语"><a href="#环形物语" class="headerlink" title="环形物语 "></a><font color=pink>环形物语</font> <br></h1><h2 id="环就在你心中"><a href="#环就在你心中" class="headerlink" title="环就在你心中"></a><font color=lightgreen>环就在你心中</font></h2>]]></content>
      <tags>
        <tag>自然</tag>
      </tags>
  </entry>
</search>
