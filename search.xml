<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kruskal</title>
    <url>/2023/03/27/Kruskal/</url>
    <content><![CDATA[<h2 id="Kruskal算法与并查集"><a href="#Kruskal算法与并查集" class="headerlink" title="Kruskal算法与并查集"></a>Kruskal算法与并查集</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ul>
<li><h4 id="以边入手"><a href="#以边入手" class="headerlink" title="以边入手"></a>以边入手</h4></li>
</ul>
<p>从边入手，将边按照权递增排序，所以我们需要使用边集数组。</p>
<ul>
<li><h4 id="并查集判断"><a href="#并查集判断" class="headerlink" title="并查集判断"></a>并查集判断</h4>由于使用了边，但是我们要判断是否会形成回路。所以使用查集。</li>
</ul>
<h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><ul>
<li><h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> begin, end;</span><br><span class="line">	ArcType weight;		<span class="comment">// ? the begin mean the point of the arcs</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且我们也要用到并查集的知识 感觉非常巧妙</span></span><br><span class="line"><span class="comment">//算法的是现实思想 这个就是使用的边集数组 对应的特有的数据结构</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/先理解我们并查集的思想吧</span><br><span class="line"><span class="comment">// 实现所需要具有的数据结构 一个整数数组 两个函数 find and join</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N&#123; <span class="number">1000</span> &#125;;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">int</span> Rank[N];		<span class="comment">// find 函数优化时所需要使用的一个标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pre[i] = i;		<span class="comment">// 起始的时候全部为自己代表自己全部时分开的</span></span><br><span class="line">		Rank[i] = <span class="number">1</span>;	<span class="comment">// 深度全是1	0 也可以</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>		<span class="comment">// 查找 x 的根结点 还是一个树形结构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == pre[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pro</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">// 查找的时候顺便完成一个路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x == pre[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> pre[x] = <span class="built_in">find_pro</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">// 因为是一个尾递归所以可以写成以一个循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x != pre[x])</span><br><span class="line">		x = pre[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;	<span class="comment">// 我们使用的 </span></span><br><span class="line"><span class="comment">// 并查集 还有一个方法就是 并join()</span></span><br><span class="line"><span class="comment">// pro的非递归写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pro_</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="type">int</span> r = x;</span><br><span class="line">	<span class="keyword">while</span> (pre[r] != r)</span><br><span class="line">	&#123;</span><br><span class="line">		r = pre[r];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (x != r)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = pre[x];</span><br><span class="line">		pre[x] = r;</span><br><span class="line">		x = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issame</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);		<span class="comment">// 优雅</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (Rank[x] &lt; Rank[y])</span><br><span class="line">		pre[x] = y;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Rank[x] == Rank[y])</span><br><span class="line">			Rank[x]++;</span><br><span class="line">		pre[y] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OKay so far 我们写我们要使用的函数 Find</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span>* parent, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (parent[f]&gt;<span class="number">0</span>)</span><br><span class="line">		f = parent[f];</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序的时候可以用 qsort 也可以自己写</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>思路整理 ，首先运用一个整数数组来存每个元素的前驱，然后设定一个代表元，通过不断向上访问得到代表元。所以并查集本质任然是一个树形结构，研究连通的关系。</p>
<ul>
<li><h4 id="将邻接矩阵转换为一个边集数组"><a href="#将邻接矩阵转换为一个边集数组" class="headerlink" title="将邻接矩阵转换为一个边集数组"></a>将邻接矩阵转换为一个边集数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">edgecpy</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, Edge* e)</span>	<span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vertexnum<span class="number">-1</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;G.vertexnum;j++)</span><br><span class="line">			<span class="keyword">if</span> (G.arcs[i][j] &lt; INF)</span><br><span class="line">			&#123;</span><br><span class="line">				e[k].begin = i;</span><br><span class="line">				e[k].end = j;</span><br><span class="line">				e[k].weight = G.arcs[i][j];</span><br><span class="line">				++k;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后我们基本就得到了全部了</p>
<p>附上完整代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status  <span class="title">cmp_</span><span class="params">(<span class="type">void</span> <span class="type">const</span>* e1, <span class="type">void</span> <span class="type">const</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (((Edge*)e1)-&gt;weight &gt; ((Edge*)e2)-&gt;weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MST_Kruskal</span><span class="params">(<span class="type">const</span> AMGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Edge* edges = <span class="keyword">new</span> Edge[MVNum];	<span class="comment">//	创建一个边集数组</span></span><br><span class="line">	<span class="type">int</span>* parent = <span class="keyword">new</span> <span class="type">int</span>[G.vertexnum];</span><br><span class="line">	<span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> min_casts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(parent, <span class="number">0</span>, <span class="built_in">sizeof</span>(parent));</span><br><span class="line">	<span class="built_in">edgecpy</span>(G, edges);</span><br><span class="line">	<span class="built_in">qsort</span>(edges,G.arcnum, <span class="built_in">sizeof</span>(Edge), cmp_);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.arcnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m = <span class="built_in">Find</span>(parent, edges[i].begin);</span><br><span class="line">		n = <span class="built_in">Find</span>(parent, edges[i].end);</span><br><span class="line">		<span class="keyword">if</span> (m != n)</span><br><span class="line">		&#123;</span><br><span class="line">			parent[m] = n;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; edges[i].begin &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; edges[i].end &lt;&lt; <span class="string">&quot; )\n&quot;</span>;</span><br><span class="line">			min_casts += edges[i].weight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>从边出发，并查集的思想很重要</p>
</blockquote>
<p><img src="/../images/tian.jpg"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra</title>
    <url>/2023/03/27/Dijkstra/</url>
    <content><![CDATA[<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><ul>
<li><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在一个图中，怎样找到一个点，到其余任何一个点的权值最小的路径，这个就是最短路径问题。</p>
</li>
<li><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><h4 id="从点入手"><a href="#从点入手" class="headerlink" title="从点入手"></a>从点入手</h4><p>我们从点的角度考虑，每次选择最短的路径，然后将新的端点家啊如考虑的集合。</p>
</li>
<li><h4 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h4><p>我们会遇到一个问题就是，如果新的点构成一条更短的路径，所以每加入一个点，就进行一个检查</p>
</li>
<li><h4 id="INF"><a href="#INF" class="headerlink" title="INF"></a>INF</h4><p>INF来建立，已判断是否相连</p>
</li>
</ul>
</li>
<li><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><ul>
<li><h4 id="final数组"><a href="#final数组" class="headerlink" title="final数组"></a>final数组</h4><p>final数组来判断是否已经有最短路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span>[i] = <span class="number">0</span>;	<span class="comment">// 0代表没有找到</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Path数组"><a href="#Path数组" class="headerlink" title="Path数组"></a>Path数组</h4><p>Path来记录到达每一个对应的顶点的上一个前驱结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MVNum];		<span class="comment">//存储最短路径的下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MVNum];	<span class="comment">//存储各点的最小路径的权值和</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>记住更新判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.vexnum; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INF;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; C[w] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = C[w];	<span class="comment">//不用考略的原因在于final</span></span><br><span class="line">				k = w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span>[w] = <span class="number">1</span>;	<span class="comment">//找到了就先标记一个然后开始更新检查</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; min + G.arcs[k][w] &lt; C[w])</span><br><span class="line">			&#123;</span><br><span class="line">				P[w] = k;		<span class="comment">// 保证了找到到每一个点的最短路径</span></span><br><span class="line">				C[w] = min + G.arcs[k][w];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEDGE	50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF	0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE	100</span></span><br><span class="line"><span class="comment">// 迪杰斯特拉算法本质是一种贪心算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AMGraph</span></span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> vexnum;</span><br><span class="line">	<span class="type">int</span> arcnum;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MVNum];		<span class="comment">//存储最短路径的下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MVNum];	<span class="comment">//存储各点的最小路径的权值和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v0,Patharc P, ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> v, w, k, min;	<span class="comment">//以前的一种习惯</span></span><br><span class="line">	<span class="type">int</span> <span class="keyword">final</span>[MVNum];	<span class="comment">// 这个数组用来判断 一个点是否已经找到了最短路径</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span>[i] = <span class="number">0</span>;	<span class="comment">// 0代表没有找到</span></span><br><span class="line">		P[i] = v0;<span class="comment">//假设每个都设为v0</span></span><br><span class="line">		C[i] = G.arcs[v0][i];	<span class="comment">//	同理为到v0 的距离 第一次一定满足</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span>[v0] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//P[v0] = v0;  目前似乎可以不用</span></span><br><span class="line">	C[v0] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.vexnum; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INF;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; C[w] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = C[w];	<span class="comment">//不用考略的原因在于final</span></span><br><span class="line">				k = w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span>[w] = <span class="number">1</span>;	<span class="comment">//找到了就先标记一个然后开始更新检查</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; min + G.arcs[k][w] &lt; C[w])</span><br><span class="line">			&#123;</span><br><span class="line">				P[w] = k;		<span class="comment">// 保证了找到到每一个点的最短路径</span></span><br><span class="line">				C[w] = min + G.arcs[k][w];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>贪心思想，每次选择最优解，妙处在这个记录路径的数据结构，以及判断的选择，标记的思想。</p>
</blockquote>
<p><img src="/../images/to.jpg"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MARKDOWN</title>
    <url>/2023/03/22/MARKDOWN-0/</url>
    <content><![CDATA[<h2 id="本文总结一些学习到的Markdown语法以及相关工具"><a href="#本文总结一些学习到的Markdown语法以及相关工具" class="headerlink" title="本文总结一些学习到的Markdown语法以及相关工具"></a>本文总结一些学习到的Markdown语法以及相关工具</h2><ol>
<li><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li><h4 id="标题设置"><a href="#标题设置" class="headerlink" title="标题设置"></a>标题设置</h4><ul>
<li><em>等级标题</em><br> # ## ### 类似的一共有六级 数量不同代表不同的大小</li>
</ul>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></li>
<li><h4 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a><em>斜体（Italic）</em></h4><p> 应该有很多种 ，不过较为普适的是*单词* 例子</p>
<h2 id="这是一个例子"><a href="#这是一个例子" class="headerlink" title="这是一个例子"></a><em>这是一个例子</em></h2></li>
<li><h4 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a><strong>粗体</strong></h4><p> 普适的**单词**</p>
<h2 id="这是一个例子-但是实际上每个标题都默认了"><a href="#这是一个例子-但是实际上每个标题都默认了" class="headerlink" title="这是一个例子  但是实际上每个标题都默认了"></a><strong>这是一个例子</strong>  但是实际上每个标题都默认了</h2></li>
<li><h4 id="又粗又斜"><a href="#又粗又斜" class="headerlink" title="又粗又斜"></a><em><strong>又粗又斜</strong></em></h4><p> ***单词*** 注意上面的都是紧紧挨着单词的 </p>
</li>
<li><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p> \ 类似其他的语言 直接 一个反斜杠</p>
</li>
<li><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><ol>
<li>可以先敲两个空格之后 然后换行</li>
<li>可以用 &lt;br&gt;</li>
<li>我在Vscode 和 typora 似乎可以直接换行啊</li>
</ol>
</li>
</ol>
<ol start="7">
<li><h4 id="其他几种格式"><a href="#其他几种格式" class="headerlink" title="其他几种格式"></a>其他几种格式</h4><ol>
<li>分割线 *** ___ — 至少三个<br> 举个例子</li>
</ol>
<hr>
<hr>
<hr>
<h3 id="三个效果好像一样"><a href="#三个效果好像一样" class="headerlink" title="三个效果好像一样"></a>三个效果好像一样</h3><ol>
<li>删除线<br> 两个~~单词~~<br> <del>Winter</del></li>
<li>下划线<br> 用的html语法 就是&lt;u&gt;&lt;&#x2F;u&gt;  <em><strong>注意是一个斜杠</strong></em><br> 举个例子 <u>For Ms.Winter</u></li>
</ol>
</li>
</ol>
<ol start="8">
<li><h3 id="——引用与序表"><a href="#——引用与序表" class="headerlink" title="——引用与序表"></a>——引用与序表</h3><pre><code> 引用（为什么已经引用了？？？）
</code></pre>
<ol>
<li>引用<br> （不明所以啊）看一看啊&gt; &gt;&gt; 类似的 举个例子    <blockquote>
<p>你好啊 你们逗号吗</p>
<blockquote>
<p>我很好</p>
<blockquote>
<p>真的吗   </p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>有序列表<br> 就是我现在写的这些数字标号 注意要隔开<br> 举个例子    <ol>
<li>好<ol>
<li>好<ol>
<li>好 似乎最多只有三级  每次tab一下就可以自动升级或者降级</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>无序列表<br>   - 使用这个符号<br>   举个例子 <ul>
<li>好 好 好 好<ul>
<li>好</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="重新实验"><a href="#重新实验" class="headerlink" title="重新实验"></a>重新实验</h3><pre><code> 你好 哦 我懂了 如果在有序表之后再两个tab 就可以有这样一个块
</code></pre>
</li>
</ol>
</li>
<li><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><pre><code>你啥感觉卡斯柯估计是客观的就卡死了干净ask房间昆仑山感觉

阿贾克斯打个卡速度过快发生你的开发代码 ***似乎没什么用***
</code></pre>
<ol start="11">
<li><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span>:</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>就是使用```cpp &#96;&#96;&#96;哇好厉害啊</p>
</li>
<li><h4 id="空格表示"><a href="#空格表示" class="headerlink" title="空格表示"></a>空格表示</h4><p>这个有点有趣 $~~~~$ 可以指定任意个数的</p>
</li>
<li><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ol>
<li><em>超链接</em><br>使用&lt;&gt; 直接写一个地址就可以     同样可以使用邮箱地址<br><a class="link"   href="https://www.w3school.com.cn/" >https://www.w3school.com.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><em>引用式超链接</em><ol>
<li>  <a class="link"   href="https://www.w3school.com.cn/" >link1djfj <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
</li>
<li><em>设定文字的超链接</em></li>
</ol>
<pre><code> 1.  使用[显示名字](url)
</code></pre>
</li>
</ol>
<p>   <a class="link"   href="https://www.w3school.com.cn/" >这里是一个链接地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 也可以是一个文件路<br>          2.  <em>带有一个titile</em><br>  所谓的title就是悬停再链接上会显示的文字 举个例子 放在()里 url用空格相连 这是一个链接<a class="link"   href="https://www.w3school.com.cn/"  title="Look at you">Look at me <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>    &#x2F;&#x2F;感觉还是挺方便的<br>        3. <em>带有格式化的链接</em><br>  <strong><a class="link"   href="https://www.w3school.com.cn/" >hello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong><br>  <em><a class="link"   href="https://www.w3school.com.cn/" >hello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em><br>  <em><strong><a class="link"   href="https://www.w3school.com.cn/" >hello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em><br>   <a href="https://www.w3school.com.cn/" title="Hello,World"><code>hello</code></a><br>  注意最后一个 是[`word`](url &quot;title&quot;) 的写法<br>        4. <em>引用式链接</em><br>   大概就是 创建一个链接创建一个标签 然后可以多次使用了 举个例子<br>   首先创建 [link]: <a class="link"   href="https://www.w3school.com.cn/" >https://www.w3school.com.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  注意有： 且有一个空格</p>
</li>
</ol>
<p>   <a class="link"   href="https://www.w3school.com.cn/" >我将进行第一次引用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>   用法格式 [显示文字][标签名]</p>
<ol>
<li><h4 id="图片的使用"><a href="#图片的使用" class="headerlink" title="图片的使用"></a>图片的使用</h4><ol>
<li><p>格式 ！[这是图片](本地地址 “图片标题”)</p>
</li>
<li><p>带有链接的图片 ！[[这是一个图片](本地地址)](链接) 地址可以是url 注意两个[[]]</p>
</li>
<li><p>举个例子 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/jiaj.jpg"
                      alt="My photo"
                >     </p>
</li>
<li><p><a href="https://www.w3school.com.cn/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://th.bing.com/th/id/OIP.avb9nDfw3kq7NOoP0grM4wHaEK?w=282&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7"
                      alt="My photo"
                ></a></p>
<ol>
<li><h4 id="文字与背景颜色"><a href="#文字与背景颜色" class="headerlink" title="文字与背景颜色"></a>文字与背景颜色</h4></li>
</ol>
</li>
<li><p>文字颜色 支持十六进制颜色表示</p>
</li>
</ol>
</li>
<li><p>举个例子  &lt;font color &#x3D; Blue&gt;Text&lt;&#x2F;font&gt;<br> <font color = gree>hiiii</font><br> <font color = #f0f000>hiii</font><br> &#x2F;十六进制颜色是#开头 然后六位十六进制的数字 然后 顺序是RGB 255 是最多<br> <font color = #f0005>让我们看看这个颜色</font><br> 但是其实内置了很多 颜色 举个例子 seagreen seablue<br> <font color= seagreen>let me check it </font><br>     <font color= seablue>let me check it </font>  </p>
<ol start="3">
<li><em>背景颜色</em></li>
</ol>
<p>&lt;font style&#x3D;background:颜色&gt; </font>       </p>
<p> 举个例子<br>     <font style =background:seagreen>hello world  你好 世界</font></p>
</li>
</ol>
<p>​<br>​<br>2. ## 工具推荐与使用<br>    1. ### Vscode &amp; 相关 的插件<br>        很方便的一点就是可以瞬时查看自己的样式 并且标准与github一致<br>    2. ### Typora<br>        确实就很好了 可以通过选项 而不用在意源码 了 相当于提供了一个GUI</p>
<ol start="3">
<li><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2></li>
</ol>
<blockquote>
<p>目前所需的Markdown语法大概如此至于与Latex和HTML相关的由于使用较少，暂未提及，以后遇到再作更新学习</p>
</blockquote>
]]></content>
      <tags>
        <tag>MARKDOWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd</title>
    <url>/2023/03/27/Floyd/</url>
    <content><![CDATA[<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><ul>
<li><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><h4 id="一次解决全图"><a href="#一次解决全图" class="headerlink" title="一次解决全图"></a>一次解决全图</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> vexnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="插点的循环"><a href="#插点的循环" class="headerlink" title="插点的循环"></a>插点的循环</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; k++)	<span class="comment">// 第一个</span></span><br><span class="line">		<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">			<span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (C[v][w] &gt;C[v][k] +C[k][w])</span><br><span class="line">				&#123;</span><br><span class="line">					C[v][w] = C[v][k] +C[k][w];</span><br><span class="line">					P[v][w] = P[v][k];		<span class="comment">//相当于就是在里面加点 最后一个我们读取矩阵</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   Floyd.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  3/27/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// Floyd</span></span><br><span class="line"><span class="comment">//关键思想就是不断的插入点来分析 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Path = <span class="type">int</span>[MVNum][MVNum];		</span><br><span class="line"><span class="keyword">using</span> ShortPathTable = <span class="type">int</span>[MVNum][MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最精妙的思想 一次求完所有的点 所以这是一个n^3复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样使用邻接矩阵</span></span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> AMGraph = <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> vexnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">const</span> AMGraph&amp; G,Path P,ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> v, w, k;</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			C[v][w] = G.arcs[v][w];</span><br><span class="line">			P[v][w] = w;	<span class="comment">// 注意这个初始化</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 非常巧妙的循环也是关键</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; k++)	<span class="comment">// 第一个</span></span><br><span class="line">		<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">			<span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (C[v][w] &gt;C[v][k] +C[k][w])</span><br><span class="line">				&#123;</span><br><span class="line">					C[v][w] = C[v][k] +C[k][w];</span><br><span class="line">					P[v][w] = P[v][k];		<span class="comment">//相当于就是在里面加点 最后一个我们读取矩阵</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意我们的这个路径矩阵 与迪杰斯特拉一样 然后是列来读取</span></span><br><span class="line"><span class="comment">// 数值 横着读取</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispath</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, Path P, ShortPathTable C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;各点的最短路径如下\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum<span class="number">-1</span>; v++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = v + <span class="number">1</span>; w &lt; G.vexnum; w++)		<span class="comment">// 只读取一般矩阵 也很好哦</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;v&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;-v&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot; weight: &quot;</span> &lt;&lt; C[v][w];</span><br><span class="line">			k = P[v][w];</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; Path: &quot;</span> &lt;&lt; v;</span><br><span class="line">			<span class="keyword">while</span> (k != w)</span><br><span class="line">			&#123;</span><br><span class="line">				k = P[k][w];</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; k;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>最后其实就是这种插点的思想</p>
</blockquote>
<p><img src="/../images/ly.jpg" alt="hh"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/03/23/DNS/</url>
    <content><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul>
<li><h3 id="DNS-Domain-name-system"><a href="#DNS-Domain-name-system" class="headerlink" title="DNS(Domain name system)"></a>DNS(Domain name system)</h3><ul>
<li><p>是DNS服务器实现的一个分布式数据库，同时也算是一个应用层协议运行在unix机器之上，端口号为53</p>
</li>
<li><p>http、smtp、ftp都是用了DNS将主机名转化为IP地址</p>
</li>
<li><p>原理如下</p>
<p>1） 同一台用户主机上运行着DNS应用的客户端。</p>
<p>2） 浏览器从上述URL中抽取岀主机名<a class="link"   href="http://www.baidu.com,并将这台主机名传给dns应用的客户端./" >www.baidu.com,并将这台主机名传给DNS应用的客户端。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>3） DNS客户向DNS服务器发送一个包含主机名的请求。</p>
<p>4） DNS客户最终会收到一份回答报文，其中含有对应于该主机名的IP地址。</p>
<p>5） 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。		</p>
</li>
<li><p>规范主机名与主机别名，邮件系统别名联想自己的学校邮箱</p>
</li>
</ul>
</li>
<li><h3 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h3><ul>
<li><p>主机例如web应用需要将主机名转换为IP地址时，调用DNS客户端，指明主机名，底层的unix实现是调用一个函数gethostbtname（）</p>
</li>
<li><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li><h5 id="分布式，层次"><a href="#分布式，层次" class="headerlink" title="分布式，层次"></a>分布式，层次</h5><p>根，顶级域(TLD，top-level domain),权威，三层。举个例子</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/DNS%E5%B1%82%E6%AC%A1.png"
                      alt="DNS层次"
                ></p>
<p>国家，fr,jp,ca,也是自己国家维护的顶级域 权威顶级域就是因特网上能够被公共访问的服务器主机需要提供的一个可公共访问的DNS记录，例如大学，自己维护的DNS服务器</p>
</li>
<li><h5 id="本地DNS服务器与缓存"><a href="#本地DNS服务器与缓存" class="headerlink" title="本地DNS服务器与缓存"></a>本地DNS服务器与缓存</h5><p>通过本地公用来减少流量，缓存可以减少路径，尽量绕过根DNS</p>
</li>
</ul>
</li>
<li><h4 id="DNS记录与报文"><a href="#DNS记录与报文" class="headerlink" title="DNS记录与报文"></a>DNS记录与报文</h4><ul>
<li><h5 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h5></li>
</ul>
<p>DNS服务器中提供了资源记录，包含四元组(Name, Value，Type，TTL) </p>
<p>如果Type &#x3D; A,则Name是主机名，Value是该主机名对应的IP地址。因此，一条类型为A的资源记录提供了标准的主机名到IP地址的映射。例如(Tayl.bar. foo. com, 145. 37.93. 126, A)就是一条类型 A 记录。</p>
<p>如果Type &#x3D; NS,则Name是个域(如foo. com),而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。例如(fgcom, cins.foo.com, NS)就是一条类型为NS的记录。</p>
<p>如果Type&#x3D;CNAME，则 Value是别名为Name的主机对应的规范主机名。该记录能够向査询的主机提供一个主机名对应的规范主机名，例如(foo.com, relay1.bar. foo. com, CNAME)就是一条 CNAME 类型的记录。</p>
<p>如果Type &#x3D; MX,则Value是个别名为Name的邮件服务器的规范主机名。举例来说，(foo.com, mail. bar. fo&lt;). com, MX)就是一条MX记录。MX记录允许邮件服务器主机名具有简单的别名。值得注意的是，通过使用MX记录，一个公司的邮件服务器和其他服务器(如它的Web服务器)可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录</p>
<ul>
<li><h5 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/DNS%E6%8A%A5%E6%96%87.png"
                      alt="DNS报文" title="DNS报文"
                ></li>
</ul>
<p>控制台键入nslookup 即可看权威DNS服务器与地址 dns.hust.edu.cn</p>
</li>
</ul>
</li>
</ul>
<h2 id="P2P与BitTorrent"><a href="#P2P与BitTorrent" class="headerlink" title="P2P与BitTorrent"></a>P2P与BitTorrent</h2><p>​	之前都是采用客户-服务器体系结构，依赖于服务器，P2P则是最小或是没有依赖。成对间歇连接的主机直接相连，对等方。最广泛的是BitTorrent协议</p>
<ul>
<li><h3 id="P2P体系结构的拓展性"><a href="#P2P体系结构的拓展性" class="headerlink" title="P2P体系结构的拓展性"></a>P2P体系结构的拓展性</h3><p>在用户接受到后能够使用自己的能力进行一个上传。</p>
</li>
<li><h3 id="BitTorrent-协议"><a href="#BitTorrent-协议" class="headerlink" title="BitTorrent 协议"></a>BitTorrent 协议</h3><p>洪流，主机集合，可以一起向其他主机传输，用追踪器实现。传送时，遵循一定的最有算法。</p>
</li>
</ul>
<h2 id="视频流"><a href="#视频流" class="headerlink" title="视频流"></a>视频流</h2><ul>
<li><h3 id="http流与DASH"><a href="#http流与DASH" class="headerlink" title="http流与DASH"></a>http流与DASH</h3><p>http流中的视频就是一个普通的http下的文件具有一个url。初期，由于具有统一格式，提供单一视频的性质，现在，为经HTTP的动态适应性流(Dynamic AdaptiveStreaming over HTTP, DASH) ，编码不同版本，不同画质。</p>
<ul>
<li><h4 id="内容发布网"><a href="#内容发布网" class="headerlink" title="内容发布网"></a>内容发布网</h4>CDN，在传统的DNS访问中，最后得到的是一个CDN内容服务器IP地址，然后再CDN中处理</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Prim</title>
    <url>/2023/03/24/Prim/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><font color=Aqua>加入你遇到这样一个问题，在一个表示了很多村庄的交通图中，其中有每两个村庄之间的交通开销。我们怎么才能够将所有的村庄都相连，并且没有回路，即离散数学里的极小连通图。我们的Prim算法给出了一种经典的解决方法。</font></p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="数学抽象"><a href="#数学抽象" class="headerlink" title="数学抽象"></a>数学抽象</h3><p>我们运用离散数学中的图来简化模型，将村庄视作点，边视作连线，然后赋予对应的一个权值。</p>
<h3 id="关键思路分析"><a href="#关键思路分析" class="headerlink" title="关键思路分析"></a>关键思路分析</h3><ul>
<li><h4 id="以点为中心"><a href="#以点为中心" class="headerlink" title="以点为中心"></a>以点为中心</h4><p>因为最终生成的路径一定要包含所有的顶点，所以我们可以从点的角度考虑。任取一个点，找到与其邻接的所有顶点，然后找到最小的权值对应的顶点，把该点放入我们的点集合里，然后然后重复上面的步骤就可以了。</p>
</li>
<li><h4 id="更新权值"><a href="#更新权值" class="headerlink" title="更新权值"></a>更新权值</h4><p>一个比较关键的地方就是要不断检查权值，然后对应进行更新。</p>
<blockquote>
<p>其实思路总体还是比较清晰，简单，不过在代码里面有很多巧妙的地方</p>
</blockquote>
</li>
</ul>
<h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><ul>
<li><h4 id="如何存储点的信息"><a href="#如何存储点的信息" class="headerlink" title="如何存储点的信息"></a>如何存储点的信息</h4><p>我们定义一个Prim特有的数据结构来进行存储</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个就是Prim算法的特殊数据结构，就是你使用这个算法就必须要想起的一个结构</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// ADT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">closeedge</span> &#123;</span><br><span class="line">	<span class="type">int</span> adjvex;</span><br><span class="line">	<span class="type">int</span> lowcast;	<span class="comment">//?  low cast </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路很妙，lowcast记录该点的最小开销，而adjvex对应最小开销的对应的边。不过我们还有一个问题，那就是我们会发现，怎么检查一个点是否已经在我们的已经考虑过的集合里，然后又怎么决定两条边是否相连，我们分别对下面 的问题进行解决。   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	100</span></span><br><span class="line"><span class="comment">// ? love favorite </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">	<span class="type">int</span> vertexnum&#123;MVNum&#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;		<span class="comment">//? Low cost</span></span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure>

<p>我们使用边集数组的数据结构来表示，（这就是数据结构的魅力），然后我们在初始化的时候将对角线初始化为0，以lowcast&#x3D;0来代表不能建路径，以INF一个极大值来检查是否连通。这就是算法中的关键思路</p>
</li>
<li><h4 id="判断条件（如上）"><a href="#判断条件（如上）" class="headerlink" title="判断条件（如上）"></a>判断条件（如上）</h4></li>
</ul>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   MTS.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  3/24/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// Now we come to the MTS</span></span><br><span class="line"><span class="comment">//? Most Cost Spannig Tree </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	100</span></span><br><span class="line"><span class="comment">// ? love favorite </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> VerTexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> ArcType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VerTexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">	<span class="type">int</span> vertexnum&#123;MVNum&#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;		<span class="comment">//? Low cost</span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">locate</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">		<span class="keyword">if</span> (v == G.vertices[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(G.arcs, INF, <span class="built_in">sizeof</span>(G.arcs));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">		G.arcs[i][i] = <span class="number">0</span>;		<span class="comment">// It must been done !</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;first please input the arcnum and vernum of the graph&quot;</span>;</span><br><span class="line">	cin &gt;&gt; G.vertexnum &gt;&gt; G.arcnum;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now please enter the vertices first&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">		cin &gt;&gt; G.vertices[i];</span><br><span class="line">	VerTexType v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">	ArcType weight&#123; <span class="number">-1</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i&#123; <span class="number">0</span> &#125;, j&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now please enter all the arcs and weight&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.arcnum; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;</span><br><span class="line">		i = <span class="built_in">locate</span>(G, v1);</span><br><span class="line">		j = <span class="built_in">locate</span>(G, v2);</span><br><span class="line">		G.arcs[i][j] = weight;			<span class="comment">// UDN</span></span><br><span class="line">		G.arcs[j][i] = weight;			<span class="comment">// UDN</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是Prim算法的特殊数据结构，就是你使用这个算法就必须要想起的一个结构</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// ADT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">closeedge</span> &#123;</span><br><span class="line">	<span class="type">int</span> adjvex;</span><br><span class="line">	<span class="type">int</span> lowcast;	<span class="comment">//?  low cast </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键思路的分析 ，就是把点作为一个集合，从所有与这个集合相连的点中挑选</span></span><br><span class="line"><span class="comment">// 运用一个数组存储对应的顶点的最小开销，与此同时，再使用一个数组来记录对应的边的</span></span><br><span class="line"><span class="comment">// 另一个顶点 然后 为了判定一个点是否已经在集合内，我们将其cast 设置为0</span></span><br><span class="line"><span class="comment">// 并且最开始的时候我们的矩阵里使用的是一个INF 数据设计很巧妙</span></span><br><span class="line"><span class="comment">// The prim from a blogger </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(AMGraph&amp; G, <span class="type">int</span> v)</span>	<span class="comment">//? We choose a start point v0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// First we use the closeedge</span></span><br><span class="line">	closeedge C[MVNum];		<span class="comment">// Special data struct</span></span><br><span class="line">	<span class="comment">// Init it with the v point</span></span><br><span class="line">	<span class="type">int</span> min_casts = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		C[i].adjvex = v;</span><br><span class="line">		C[i].lowcast = G.arcs[v][i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;对应的边是&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G.vertexnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> min_cast = INF;	<span class="comment">// Just the case</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vertexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (C[j].lowcast != <span class="number">0</span> &amp;&amp; C[j].lowcast &lt; min_cast)</span><br><span class="line">			&#123;</span><br><span class="line">				temp = j;</span><br><span class="line">				min_cast = C[j].lowcast;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; ( &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; C[temp].adjvex &lt;&lt; <span class="string">&quot; )&quot;</span>;</span><br><span class="line">		min_casts += min_cast;</span><br><span class="line">		C[temp].lowcast = <span class="number">0</span>;	<span class="comment">// You&#x27;ve seen what the use just to see if used!!!</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.vertexnum; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (C[k].lowcast != <span class="number">0</span> &amp;&amp; G.arcs[temp][k] &lt; C[k].lowcast)</span><br><span class="line">			&#123;</span><br><span class="line">				C[k].lowcast = G.arcs[temp][k];</span><br><span class="line">				C[k].adjvex = k;		<span class="comment">// Now you see what the adjvex mean</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;All casts are &quot;</span> &lt;&lt; min_casts &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we could see the o(n^2)</span></span><br><span class="line"><span class="comment">// We could also use the KrustalAL other method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//? Krustal 算法的实现</span></span><br><span class="line"><span class="comment">// 对应的我们KRUSTAL 算法也有对应的特有的数据结构 就是我们的边集数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> begin, end;</span><br><span class="line">	ArcType weight;		<span class="comment">// ? the begin mean the point of the arcs</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且我们也要用到并查集的知识 感觉非常巧妙</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><font color=coral>之前很少细想算法设计的思路，自己的思维没有得到锻炼，其中的数学简化思想与代码设计很巧妙与优美，完</font></p>
<p><img src="/../images/Rei.jpg" alt="hh" title="绫波"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS&amp;DFS</title>
    <url>/2023/03/23/BFS-DFS/</url>
    <content><![CDATA[<h2 id="简单总结一下BFS与DFS在图中的实现"><a href="#简单总结一下BFS与DFS在图中的实现" class="headerlink" title="简单总结一下BFS与DFS在图中的实现"></a>简单总结一下BFS与DFS在图中的实现</h2><ul>
<li><h3 id="BFS-amp-DFS-in-C"><a href="#BFS-amp-DFS-in-C" class="headerlink" title="BFS&amp;DFS in C++"></a><strong>BFS&amp;DFS in C++</strong></h3>  <font color=aqua><em><strong>由于对class不熟，没有写成类，但是单独写了头文件，作为一个标准例子吧</strong></em></font><h4 id="这是头文件"><a href="#这是头文件" class="headerlink" title="这是头文件"></a>这是头文件</h4>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   BFS.hpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter </span></span><br><span class="line"><span class="comment"> *  To demonstrate the BFS and DFS in graph </span></span><br><span class="line"><span class="comment"> * as well as wellas review the queue and graph</span></span><br><span class="line"><span class="comment"> * \author Winter</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once		<span class="comment">/* Two lines just in case */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BFS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Macro </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAD	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW	-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE	-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum	50	<span class="comment">// Maximum number of vertices</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE	100</span></span><br><span class="line"><span class="comment">//ADT</span></span><br><span class="line"><span class="keyword">using</span> Status = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> Len = <span class="type">int</span>;		<span class="comment">//C++ version</span></span><br><span class="line"><span class="comment">// ALGraph</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> OtherInfo;	<span class="comment">//Maybe the weight</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">anode</span> &#123;</span><br><span class="line">	<span class="type">int</span> adjvex;		<span class="comment">//the index of this node</span></span><br><span class="line">	OtherInfo info;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">anode</span>* next;</span><br><span class="line">&#125;Arcnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vnode</span> &#123;</span><br><span class="line">	VertexType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Arcnode</span>* firstarc;</span><br><span class="line">	<span class="comment">// struct Arcnode*antifirst;	the out degree</span></span><br><span class="line">&#125;Vnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vnode AdjList[MVNum];	</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="type">int</span> vernum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AMGraph</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VertexType vertices[MVNum];</span><br><span class="line">	ArcType arcs[MVNum][MVNum];</span><br><span class="line">	<span class="type">int</span> vernum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> arcnum&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue the Squeue and list queue</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType* data;</span><br><span class="line">	<span class="type">int</span> front;</span><br><span class="line">	<span class="type">int</span> rear;</span><br><span class="line">&#125;SQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">qnode</span> &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">qnode</span>* next;</span><br><span class="line">&#125;Qnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	Qnode* front;</span><br><span class="line">	Qnode* rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the external value we will use in the main.cpp</span></span><br><span class="line">Arcnode* static_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">bool</span> visited[MVNum];		<span class="comment">//BFS</span></span><br><span class="line"><span class="type">bool</span> Visited[MAXSIZE];		<span class="comment">//DFS</span></span><br><span class="line"><span class="comment">//static funcion </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span>	<span class="title">FirstAdjVex</span><span class="params">(<span class="type">const</span> ALGraph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_)</span><br><span class="line">		static_ = G.vertices[v].firstarc;</span><br><span class="line">	<span class="keyword">return</span> G.vertices[v].firstarc-&gt;adjvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">NextAdjVex</span><span class="params">(<span class="type">const</span> ALGraph G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	static_ = static_-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (static_)</span><br><span class="line">		<span class="keyword">return</span> static_-&gt;adjvex;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Func</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_S</span><span class="params">(SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty_S</span><span class="params">(<span class="type">const</span> SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue_S</span><span class="params">(SQueue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue_S</span><span class="params">(SQueue&amp; Q, ElemType add)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue_S</span><span class="params">(SQueue&amp; Q, ElemType&amp; del)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty</span><span class="params">(<span class="type">const</span> Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue&amp; Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElemType add)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElemType&amp;del)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> ALGraph&amp; G, <span class="type">int</span> v)</span></span>;	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="这是cpp文件"><a href="#这是cpp文件" class="headerlink" title="这是cpp文件"></a>这是cpp文件</h4>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \file   BFS.cpp</span></span><br><span class="line"><span class="comment"> * \brief  For Ms.Winter</span></span><br><span class="line"><span class="comment"> *  21/3/2023</span></span><br><span class="line"><span class="comment"> * \author 86158</span></span><br><span class="line"><span class="comment"> * \date   March 2023</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="comment">// ?Here we come the BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BFS.hpp&quot;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_S</span><span class="params">(SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * MVNum);</span><br><span class="line">	<span class="keyword">if</span> (!Q.data)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue_S</span><span class="params">(SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(Q.data);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty_S</span><span class="params">(<span class="type">const</span> SQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue_S</span><span class="params">(SQueue&amp;Q,ElemType add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MVNum == Q.front)</span><br><span class="line">		<span class="keyword">return</span> BAD;</span><br><span class="line">	Q.data[Q.rear] = add;</span><br><span class="line">	Q.rear = (Q.rear + <span class="number">1</span>) % MVNum;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue_S</span><span class="params">(SQueue&amp; Q, <span class="type">int</span>&amp; del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> BAD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Qnode*pnew = (Qnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Qnode));</span><br><span class="line">	<span class="keyword">if</span> (!pnew)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	Q.front = Q.rear = pnew;</span><br><span class="line">	Q.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueIsEmpty</span><span class="params">(<span class="type">const</span> Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.rear = Q.front;</span><br><span class="line">	<span class="keyword">while</span> (Q.front)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.rear = Q.front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(Q.front);</span><br><span class="line">		Q.front = Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElemType add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Qnode* pnew = (Qnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Qnode));</span><br><span class="line">	pnew-&gt;data = add;</span><br><span class="line">	pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	Q.rear-&gt;next = pnew;</span><br><span class="line">	Q.rear = pnew;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElemType&amp; del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> BAD;</span><br><span class="line">	Qnode* psave = Q.front-&gt;next;</span><br><span class="line">	del = psave-&gt;data;</span><br><span class="line">	Q.front-&gt;next = psave-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == psave)</span><br><span class="line">		Q.rear = Q.front;</span><br><span class="line">	<span class="built_in">free</span>(psave);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> ALGraph&amp; G, <span class="type">int</span> v)</span>	<span class="comment">//? v the start of the BFS</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue vessel;</span><br><span class="line">	<span class="built_in">InitQueue</span>(vessel);</span><br><span class="line">	cout &lt;&lt; G.vertices[v].data;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">EnQueue</span>(vessel, v);</span><br><span class="line">	<span class="type">int</span> u&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">QueueIsEmpty</span>(vessel))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeQueue</span>(vessel, u);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstAdjVex</span>(G, u); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextAdjVex</span>(G, u, w))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[w])</span><br><span class="line">			&#123;</span><br><span class="line">				visited[w] = <span class="literal">true</span>;</span><br><span class="line">				cout &lt;&lt; G.vertices[w].data;</span><br><span class="line">				<span class="built_in">EnQueue</span>(vessel, w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> AMGraph&amp; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= G.vernum)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	cout &lt;&lt; G.vertices[v];</span><br><span class="line">	Visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vernum; ++w)</span><br><span class="line">		<span class="keyword">if</span> (G.arcs[v][w] &amp;&amp; !Visited[w])</span><br><span class="line">			<span class="built_in">DFS</span>(G, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inline int FirstAdjvex(const ALGraph&amp; G, int v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	if (!static_)</span></span><br><span class="line"><span class="comment">//		static_ = G.vertices[v].firstarc;</span></span><br><span class="line"><span class="comment">//	return G.vertices[v].firstarc-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//inline int NextAdjvex(const ALGraph&amp; G, int v, int u)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	ArcNode* scan;</span></span><br><span class="line"><span class="comment">//	for (scan = G.vertices[v].firstarc; scan-&gt;adjvex != u &amp;&amp; !scan-&gt;next; scan = scan-&gt;next)</span></span><br><span class="line"><span class="comment">//		continue;</span></span><br><span class="line"><span class="comment">//	if (u == scan-&gt;adjvex &amp;&amp; !scan-&gt;next)</span></span><br><span class="line"><span class="comment">//		return scan-&gt;next-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//	return -1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//// ?May I create the new writing</span></span><br><span class="line"><span class="comment">//inline int NextNeighbor(const ALGraph&amp; G,int v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	if (!static_||!static_-&gt;next)</span></span><br><span class="line"><span class="comment">//		return -1;</span></span><br><span class="line"><span class="comment">//	static_=static_-&gt;next;</span></span><br><span class="line"><span class="comment">//	return static_-&gt;adjvex;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Macro</span></span><br><span class="line"><span class="comment">//#define MVNum	50</span></span><br><span class="line"><span class="comment">//#define OK	1</span></span><br><span class="line"><span class="comment">//#define BAD	0</span></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="comment">//using Status = int;</span></span><br><span class="line"><span class="comment">//using VertexType = char;</span></span><br><span class="line"><span class="comment">//using ArcType = int;</span></span><br><span class="line"><span class="comment">//using Len = int;</span></span><br><span class="line"><span class="comment">//// the adjency list</span></span><br><span class="line"><span class="comment">//typedef struct anode&#123;</span></span><br><span class="line"><span class="comment">//	int adjvex;</span></span><br><span class="line"><span class="comment">//	ArcType info;</span></span><br><span class="line"><span class="comment">//	struct anode* next;</span></span><br><span class="line"><span class="comment">//&#125;ArcNode;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//typedef struct vnode &#123;</span></span><br><span class="line"><span class="comment">//	VertexType data&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//	ArcNode* firstarc;	//?there we don&#x27;t care the out degree</span></span><br><span class="line"><span class="comment">//&#125;Vnode;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//typedef Vnode AdjList[MVNum];	// ? Very special !!!</span></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//	AdjList vertices;</span></span><br><span class="line"><span class="comment">//	int vertexnum&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//	int arcnum&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//&#125;ALGraph;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////? we just can handle the adjlist like list and insert </span></span><br><span class="line"><span class="comment">//// ? from the head of the list!!!</span></span><br><span class="line"><span class="comment">////we will use the queue</span></span><br><span class="line"><span class="comment">//typedef int ElemType;		// just to store the index of the vex</span></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//	ElemType* data;</span></span><br><span class="line"><span class="comment">//	int front&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//	int rear&#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//&#125;SQueue;</span></span><br><span class="line"><span class="comment">//// the loop queue</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="BFS-in-Python"><a href="#BFS-in-Python" class="headerlink" title="BFS in Python"></a>BFS in Python</h3></li>
</ul>
<p>		<br> 然后写了一个在python中BFS实现 主要用python可以省略一些细节而着重于思想理解</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#BFS in python</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment"># double queue</span></span><br><span class="line">graph=&#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;you&quot;</span>] = [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;claire&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;bob&quot;</span>] = [<span class="string">&quot;anuj&quot;</span>, <span class="string">&quot;peggy&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;alice&quot;</span>] = [<span class="string">&quot;peggy&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;claire&quot;</span>] = [<span class="string">&quot;thom&quot;</span>, <span class="string">&quot;jonny&quot;</span>] </span><br><span class="line">graph[<span class="string">&quot;anuj&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;peggy&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;thom&quot;</span>] = [] </span><br><span class="line">graph[<span class="string">&quot;jonny&quot;</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_is_seller</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name[-<span class="number">1</span>]==<span class="string">&#x27;m&#x27;</span>        <span class="comment">#just give an example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">graph,name</span>):       <span class="comment">#we start from this guy</span></span><br><span class="line">    search_queue=deque()</span><br><span class="line">    search_queue+=graph[name]</span><br><span class="line">    searched=[]</span><br><span class="line">    <span class="keyword">while</span> search_queue:     <span class="comment">#not null</span></span><br><span class="line">        person=search_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">                <span class="built_in">print</span>(person+<span class="string">&#x27; is a wolfman&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                search_queue+=graph[person]</span><br><span class="line">                search.append(person)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h2></li>
</ul>
<p><strong><font color=seagreen>BFS主要应用了队列的思想 DFS主要运用了递归的思想 最终图的表示使用了离散数学的邻接矩阵于邻接表  Done!</font></strong></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Winter&#39;s blog</title>
    <url>/2023/03/16/Winter-s-blog/</url>
    <content><![CDATA[<h2 id="For-Ms-Winter"><a href="#For-Ms-Winter" class="headerlink" title="For Ms.Winter"></a>For Ms.Winter</h2><h3 id="先记录一下一个找图片地址的好地方-进入NASA官网直接copy-image-address-也可以在google里面使用-但是可能无法成功"><a href="#先记录一下一个找图片地址的好地方-进入NASA官网直接copy-image-address-也可以在google里面使用-但是可能无法成功" class="headerlink" title="先记录一下一个找图片地址的好地方 进入NASA官网直接copy image address 也可以在google里面使用 但是可能无法成功"></a>先记录一下一个找图片地址的好地方 进入NASA官网直接copy image address 也可以在google里面使用 但是可能无法成功</h3><ul>
<li><strong><font color=pink>emoji kitchen use ps to scale down and save in png and then port to QQ</font></strong></li>
</ul>
]]></content>
      <tags>
        <tag>Elements</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建指南</title>
    <url>/2023/03/25/hexo%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="零基础搭建静态网页（基于hexo与github-page"><a href="#零基础搭建静态网页（基于hexo与github-page" class="headerlink" title="零基础搭建静态网页（基于hexo与github page)"></a>零基础搭建静态网页（基于hexo与github page)</h2><h3 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h3><p>在网络发达的时代，如果吗想要拥有你自己的空间，同时又烦恼于腾讯qq空间的多种限制，何不自己动手，搭建属于自己的网页，这里，我将简单提供几个博客，和网站就hexo搭建网页（静态网页）作一个介绍</p>
<h3 id="你所要会的"><a href="#你所要会的" class="headerlink" title="你所要会的"></a>你所要会的</h3><p><font color=red>几乎是零基础，唯一需要的就是一个代理，如果你没有，实在找不到，我可以分享给你，虽然需要十元钱，但是它有个bug</font></p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p>我这里就先后顺序给出网址，并作简要说明；</p>
<blockquote>
<p>可以同时看一下我下面的问题解决，如果你在操作中出现问题的话，如果实在无法解决，可以评论。</p>
</blockquote>
<ul>
<li><h4 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a><a href="https://zhuanlan.zhihu.com/p/370635512"><font color= seablue>总体流程</font></a></h4></li>
</ul>
<p>其实这一个基本就可以完成搭建了，不过这里补充几个可能用到 的</p>
<ul>
<li><h4 id="模板来源"><a href="#模板来源" class="headerlink" title="模板来源"></a><a href="https://hexo.io/"><font color=seablue>模板来源</font></a></h4></li>
<li><h4 id="博客中的TAG使用"><a href="#博客中的TAG使用" class="headerlink" title="博客中的TAG使用"></a><a href="https://zhuanlan.zhihu.com/p/348131730"><font color= seablue>博客中的TAG使用</font></a></h4></li>
</ul>
<p>对于有tag和categories的网页的用法介绍</p>
<ul>
<li><h4 id="在线音乐获取"><a href="#在线音乐获取" class="headerlink" title="在线音乐获取"></a>在线音乐获取</h4><p>——<strong>暂时等待</strong> <font color=gold>我正打算写一个可以直接下载英语的web，由于要用django，可能比较久，如果不成功，我尽量提供一个源代码，到时候，大家只要可以运行应该就可以输入获取。</font></p>
</li>
<li><h4 id="一个找高清图片的网站"><a href="#一个找高清图片的网站" class="headerlink" title="一个找高清图片的网站"></a><a href="https://wallhaven.cc/"><font color= seablue>一个找高清图片的网站</font></a></h4></li>
<li><h4 id="CSS资源网站"><a href="#CSS资源网站" class="headerlink" title="CSS资源网站"></a><a href="https://www.w3cschool.cn/css3/css3-animation.html"><font color= seablue>CSS资源网站</font></a></h4><p>这个网站属于大家如果有自己改写代码的需要，可以参考，当然我自己不甚了解CSS和js</p>
</li>
<li><h4 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a><font color= seablue>markdown</font></h4><p>至于mark逗我呢使用方法可以参考我列举的一些关于markdown的用法。更完整的就是<a href="https://www.markdownguide.org/"><font color=seablue>Markdown官方文档</font></a></p>
</li>
</ul>
<p>推荐几个颜色 <font color=aqua>Aqua</font>  <font color=seablue>seablue</font>  <font color=chocolate>Chocolate</font>  <font color=azure>Azure</font></p>
<ul>
<li><h4 id="如果真的很感兴趣可以考虑学习JS"><a href="#如果真的很感兴趣可以考虑学习JS" class="headerlink" title="如果真的很感兴趣可以考虑学习JS"></a>如果真的很感兴趣可以考虑学习JS</h4></li>
</ul>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>列举一些我在操作中遇到的问题</p>
<ul>
<li><h4 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h4><p>注意命名时，必须是自己的用户名.io 这是github的要求</p>
</li>
<li><h4 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h4><p>尽量直接hexo new “标题”</p>
</li>
<li><h4 id="具体搭建指南"><a href="#具体搭建指南" class="headerlink" title="具体搭建指南"></a>具体搭建指南</h4><p>基本每一个框架都有说明，一般在对应的github仓库的README.md文件中</p>
</li>
<li><h4 id="获取网络图片"><a href="#获取网络图片" class="headerlink" title="获取网络图片"></a>获取网络图片</h4><p>先记录一下一个找图片地址的好地方 进入NASA官网直接copy image address 也可以在google里面使用 但是可能无法成功</p>
</li>
</ul>
<h2 id="Continuing"><a href="#Continuing" class="headerlink" title="Continuing"></a>Continuing</h2><p>暂时就写到这吧，欢迎交流，多请批评指教！</p>
<p><img src="/../images/lic.jpg"></p>
]]></content>
      <tags>
        <tag>Elements</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2023/03/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li><p><font color =chocolate>从前我们学习了KMP算法文本匹配，但是现在我们的这个正则表达式，提供一种单独的语法解决，但是KMP算法仍有很多局限且消耗算力，为了解决网络中的大量匹配问题，引入伟大的正则表达式，用于匹配与替换。</font></p>
</li>
<li><p><font color=blue violet>编程语言中我们使用的转义字符等有一定出处，正则表达式最初来自我们的unix机器</font> </p>
</li>
<li><h3 id="简单的语法"><a href="#简单的语法" class="headerlink" title="简单的语法"></a>简单的语法</h3><ul>
<li><h4 id="纯文本匹配"><a href="#纯文本匹配" class="headerlink" title="纯文本匹配"></a>纯文本匹配</h4><p>直接匹配文本，区分大小写，通常只返回第一个，可以编程语言中选择返回所有的数组。 </p>
</li>
<li><h4 id="号-匹配"><a href="#号-匹配" class="headerlink" title="**.号**匹配"></a>**<font color=red>.号</font>**匹配</h4><p>. 可以指代包括.在内的所有符号  匹配本身时引入了伟大的<em><strong>转义符号 \</strong></em>  </p>
</li>
<li><h4 id="匹配想要中的字符"><a href="#匹配想要中的字符" class="headerlink" title="匹配想要中的字符"></a>匹配想要中的字符</h4><p><font color = coral>使用[]，[]中的只要满足一个就算是匹配</font> 常常用在不区分大小写的表示  [Cc][Aa][Tt].eg	事实上我们的markdown都有转义字符</p>
<ul>
<li><h5 id="集合表示"><a href="#集合表示" class="headerlink" title="集合表示"></a>集合表示</h5><blockquote>
<p>一个自然的过渡，如果，集合中元素很多时，且连续，使用[A-Z] 遵循阿斯克码</p>
</blockquote>
</li>
<li><p><font color=seagreen>\ 与-都是元字符 -不需转义</font></p>
</li>
<li><h5 id="多个集合匹配"><a href="#多个集合匹配" class="headerlink" title="多个集合匹配"></a>多个集合匹配</h5><blockquote>
<p>举个例子[A-Za-z0-9]就是有三个集合 网页的十六进制颜色表示就是一种应用 [0-9A-Fa-f]</p>
</blockquote>
</li>
</ul>
</li>
<li><h4 id="取非匹配"><a href="#取非匹配" class="headerlink" title="取非匹配"></a>取非匹配</h4><ul>
<li>使用元字符^ 且作用于集合 注意是在集合的内部 求非 代表一个[^]因为具有多义性</li>
</ul>
</li>
<li><h4 id="元字符匹配"><a href="#元字符匹配" class="headerlink" title="元字符匹配"></a>元字符匹配</h4><ul>
<li><p>使用转义字符匹配 </p>
</li>
<li><p>[] - ^ \ . +</p>
</li>
<li><h6 id="特殊的元字符"><a href="#特殊的元字符" class="headerlink" title="特殊的元字符"></a>特殊的元字符</h6><ul>
<li>\f 换页符 \n换行符 \r回车符 \t制表符 \v垂直制表符 [\b]backspace</li>
<li>举个例子 处理 CSV文件 , 变成空格</li>
<li>windows 中 \r\n 表示换行 linux  \r可选 \n 必选</li>
</ul>
</li>
<li><h6 id="对集合的简化"><a href="#对集合的简化" class="headerlink" title="对集合的简化"></a>对集合的简化</h6><ul>
<li>\d 所有的数字&#x3D;[0-9] \D&#x3D;[^0-9]</li>
<li>\w 所有字母大小写与数字 \W 所有的非</li>
<li>\s 任何一个空字符 \f\n\r\v\t  \S </li>
<li>十六进制与八进制 \0x \0  \c 控制字符</li>
<li>POSIX字符的支持 格式[: 英文描述:]</li>
</ul>
</li>
<li><h6 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h6><ul>
<li>元字符 [0-9]+ 0-9中的数字的一个以上 不能0个</li>
<li>举个例子 关于邮箱地址的匹配 <ul>
<li>\w@\w\.\w 升级</li>
<li>\w+@\w+\.\w+</li>
<li>升级\[\w.]+@\[\w\.]+\.[\w.]+ 注意这个例子可以看出我们的在[]里所有的元字符都可以看作是普通字符 但是转义了也没有错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="元字符"><a href="#元字符" class="headerlink" title="*元字符"></a>*元字符</h4><ul>
<li>可以匹配0次与任意次 相当于 + 的升级版</li>
<li>\w+[\w.]*@[\w.]+\.\w+  可以把* 看作可选项  实质理解</li>
</ul>
</li>
<li><h4 id="？元字符"><a href="#？元字符" class="headerlink" title="？元字符"></a>？元字符</h4><ul>
<li>匹配一次或零次 http:&#x2F;&#x2F; 与 https:&#x2F;&#x2F; 不能用s*  httpsss 所以使用？</li>
<li>[\r]? 与我们的\r? 本质是一样的 但是为了清晰直观 我们通常直接[\r]</li>
</ul>
</li>
<li><h4 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h4><ul>
<li>{}也是元字符 举个例子就是之前的RGB #[0-9A-Fa-f]写六遍可以使用{6}</li>
<li>也可以设置一个区间{2.4}</li>
<li>[]中间是的元字符都是为普通字符，最好写一个\</li>
<li>匹配至少多少次 {3,}类似python</li>
</ul>
</li>
<li><h4 id="防止过度匹配"><a href="#防止过度匹配" class="headerlink" title="防止过度匹配"></a>防止过度匹配</h4><ul>
<li><p>使用懒惰版本，进行匹配，前面的匹配都是一个贪婪匹配，例如 * + {n，}   对应的懒惰版本就是加上一个? 例如 * 与 *？ 还有 + +? {n,} {n,}?</p>
<p>这里的懒惰可以理解成就是 尽量的再匹配到第一个的时候就停下来 ，而贪婪就是匹配到最后一个再停下来</p>
</li>
</ul>
</li>
<li><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><ul>
<li>指定匹配发生的位置</li>
<li>\b  一个标记，用来标记一个单词的开头或者是结尾  理解\b 的实质，实质就是匹配一个可以\w 与一个非字母或者是数字的位置\W 之间的一个位置  b代表boundary 注意我们的这个 \b 只是匹配一个位置 ，而不是匹配一个字符  所以 \bcat\b 得到的字符 还是 3个字符 而非5个</li>
<li>同理 的 \B 来匹配一个你想要的边界 就是 eg night-color  \B-\B 可以匹配 但是我们的 color - color 就是无法匹配</li>
<li>^ 这里来再次出现 用作 标记字符串的开始位置 $ 用于标记字符串的结尾</li>
<li>举个例子 匹配一个 XML 文件  因为必须要求 这个声明位于一个文档的最开始 所以我们需要进行 字符串的一个声明 例如 这个 ^\s*&lt;?xml.*?&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>SCRAPE</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2023/03/16/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h2 id="关于单调栈的一些东西"><a href="#关于单调栈的一些东西" class="headerlink" title="关于单调栈的一些东西"></a>关于单调栈的一些东西</h2><h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;a[s.<span class="built_in">top</span>()]&lt;=a[i])</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        f[i]=s.<span class="built_in">empty</span>()?<span class="number">0</span>:s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrape</title>
    <url>/2023/03/22/Scrape/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>本文使用的颜色较多，开启夜间模式阅读效果更好</p>
</blockquote>
<hr>
<h2 id="本系列主要是对阅读了python网络编程相关的总结与回顾"><a href="#本系列主要是对阅读了python网络编程相关的总结与回顾" class="headerlink" title="本系列主要是对阅读了python网络编程相关的总结与回顾"></a>本系列主要是对阅读了python网络编程相关的总结与回顾</h2><ol>
<li><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol>
<li><h4 id="http简介"><a href="#http简介" class="headerlink" title="http简介"></a><strong>http简介</strong></h4>  <em><strong>url</strong></em> : 统一资源定位符  格式如下 []代表可省略<br> <font color=seablue>protocol :&#x2F;&#x2F;[username:password@] hostname[:port] &#x2F; path &#x2F; [;parameters][?query]#fragment  </font><br> <font color=yellow>protocol</font>  : 协议 主要有 http,https,ftp,sms,<br> <font color =red>username,password</font> : 主要ftp<br> <font color =green>hostname</font> ： 主机名也就是域名 也可以用DNS映射得到IP地址，有一级二级域名之分<br> <font color =brown>port</font> : 端口号 http默认是80 类似还有https 443 属于套接口<br> <font color='cayon'>path</font> : 路径 就是位于主机中的地址<br> <font color='purple'>parameters</font> : 附加信息 现在用的少了<br> <font color=gold>query</font>  : 查询，多个查询就用&amp;分开，GET请求参数里也有<br> <font color=#a34929>fragment</font> : 片段 资源的补充 似乎很少使用<br> <font style =background:seagreen>http基本转向https 基于SSL socket相关也是爬取的主要内容</font>  </li>
<li><h4 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a><strong>http请求过程</strong></h4> <u>使用F12 Network 监听 Ctrl+R </u><br> <font color=seaf>Status</font>    : 状态码就是404 403 200 类似的<br> <font color=gold>Initiator</font> : 请求源 标记请求是由哪个进程或对象发起的<br> <font color=chocolate>Request</font>请求方法 请求头 请求体<br> <font color = aqua>Request Method</font> ： 请求方法GET POST居多 还有PUT DELETE 很多<br> <font color=azure></font><br> <font color=darkblue></font><br> <font color=coroflowerblue></font><br> <font color=blueviolet></font><br> <font color=coral></font><br> <font color=darkBlue></font></li>
</ol>
</li>
</ol>
<p>​        </p>
]]></content>
      <tags>
        <tag>SCRAPE</tag>
      </tags>
  </entry>
  <entry>
    <title>基础汇编指令</title>
    <url>/2023/03/23/%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h3><ul>
<li><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>一个标准的c语言程序在编译过程中，首先是经过翻译，成汇编语言，也就是Linux命令行中的-s选项，然后转为二进制的机器代码，然后通过连接器，与库相连，并且附上一些地址与起始终止信息。</p>
</li>
<li><h4 id="汇编语言与机器代码"><a href="#汇编语言与机器代码" class="headerlink" title="汇编语言与机器代码"></a>汇编语言与机器代码</h4><p>机器是二进制字节，电脑可读的指令，汇编语言就是助记符。可以编写</p>
</li>
<li><h4 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h4><p>不同机器，处理器的指令集架构不一样，但是高级抽象语言却能够通用，只要选用适合机器的编译器即可。</p>
</li>
<li><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4><p>因为英特尔前期处理器都是某某86所以简称x86，x86-64即64位拓展</p>
</li>
<li><h4 id="O优化"><a href="#O优化" class="headerlink" title="O优化"></a>O优化</h4><p>其实就是命令行的一个选型，高度优化可能使代码的汇编代码逻辑改变较大。</p>
</li>
<li><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul>
<li><h5 id="程序寄存器"><a href="#程序寄存器" class="headerlink" title="程序寄存器"></a>程序寄存器</h5><p>用于专门存储指令的地址 %rip</p>
</li>
<li><h5 id="一组十六个整数寄存器"><a href="#一组十六个整数寄存器" class="headerlink" title="一组十六个整数寄存器"></a>一组十六个整数寄存器</h5><p>用于系列操作</p>
</li>
<li><h5 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h5><p>存储维护条件码实现逻辑控制</p>
</li>
<li><h5 id="向量寄存器"><a href="#向量寄存器" class="headerlink" title="向量寄存器"></a>向量寄存器</h5><p>实现浮点数操作</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>“CSAPP”</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<blockquote>
<p>本来想要有条理一点，但是实在太多，所以就列举名词，作为条理了</p>
</blockquote>
<hr>
<h2 id="计算机网络常识"><a href="#计算机网络常识" class="headerlink" title="计算机网络常识"></a>计算机网络常识</h2><ul>
<li>名字解释  <ul>
<li>通信链路：指的就是些通信的物理媒介 同轴电缆 铜线 无线电频谱 光纤</li>
<li>分组交换机 packet switch 就是路由器 与链路层交换机</li>
<li>ISP 因特网服务提供商</li>
<li>TCP&#x2F;IP 主要协议</li>
<li>RFC 请求评论</li>
<li>网络边缘 高速宽带 数字用户线 电缆基础上使用的</li>
<li>上行下行速度</li>
<li>光纤到户</li>
<li>LAN局域网 无线局域网 基于IEEE 802. 11技术的无<br>线LAN接入,更通俗地称为WiFi</li>
<li>蜂窝移动网络</li>
<li>报文message</li>
</ul>
</li>
</ul>
<h4 id="再次温习-这次遵从前后学习的逻辑进行名词整理"><a href="#再次温习-这次遵从前后学习的逻辑进行名词整理" class="headerlink" title="再次温习 这次遵从前后学习的逻辑进行名词整理"></a><font color=pink>再次温习 这次遵从前后学习的逻辑进行名词整理</font></h4><ul>
<li><p><strong>Q引入</strong></p>
<ul>
<li>网络的物理结构是什么样的——物理定义互联网</li>
<li>两个电脑怎么传送信息——实现原理定义互联网</li>
</ul>
</li>
<li><p>端系统——即主机(host)，新兴事物（物联网），在网络末梢所以加端</p>
</li>
<li><p>主机——一个是客户(client)如PC（linux mac）另一个是服务器(server)存储web 文件 可以理解为更强大专一的</p>
</li>
<li><p>网络有点 ——主机，还有分租交换机主要有两个——路由器 与链路层交换机</p>
</li>
<li><p>网络有线——通信链路 具体有不同物理实现的媒介有不同bps速度</p>
</li>
<li><p>传送的信息叫分组(packet)——名字暗示着打包一样 </p>
</li>
<li><p>为了统一信息传递的各种流程我们需要遵循一定协议(protocol)</p>
</li>
<li><p>ISP 网络提供商 本质就是写交换机组成的网络</p>
</li>
<li><p>链路层交换机主要在接入网 而路由器主要在核心</p>
</li>
<li><p>接入网——将端系统物理连接到边缘路由器的网络</p>
</li>
<li><h3 id="各种物理媒介本质上是模电-数字信号的问题-设计的都是些调解器问题-上行下行-共享-共有的一些特征就是仍然是网络-各种各样的网络"><a href="#各种物理媒介本质上是模电-数字信号的问题-设计的都是些调解器问题-上行下行-共享-共有的一些特征就是仍然是网络-各种各样的网络" class="headerlink" title="各种物理媒介本质上是模电 数字信号的问题 设计的都是些调解器问题 上行下行 共享 共有的一些特征就是仍然是网络 各种各样的网络"></a>各种物理媒介本质上是模电 数字信号的问题 设计的都是些调解器问题 上行下行 共享 共有的一些特征就是仍然是网络 各种各样的网络</h3><ul>
<li>目前家庭多是宽带（电话线复用或者是电缆实现媒介是双绞铜线）光纤是新兴的还有两者混合的使用 企业多是LAN 和 WLAN  其中以太网是最流行的局域网技术 而wifi是无线接入技术</li>
<li>现在再底层一点看看物理原因双绞铜线的制作材料费用很低</li>
</ul>
</li>
<li><p><font color=pink>上次又没有保存 全部都没有了┭┮﹏┭┮</font></p>
</li>
<li><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>套接字是一种协议软 ，</li>
<li>主机ip地址以及端口号 port number</li>
<li>SSL安全套接字层 加密属性</li>
</ul>
</li>
<li><h3 id="Web-与-HTTP-协议"><a href="#Web-与-HTTP-协议" class="headerlink" title="Web 与 HTTP 协议"></a>Web 与 HTTP 协议</h3><ul>
<li><p>web的应用层协议就是http协议web是应用</p>
</li>
<li><p>通信严格上讲是进程间的通信</p>
</li>
<li><p>web browser就是客户端 服务器就是服务器端 存放web对象即web页面，通过url引用。url主要两个部分主机名和文件存储路径</p>
</li>
<li><p>http使用tcp运算协议</p>
</li>
<li><p>http无状态协议 不会保存客户端的状态，同时服务器总是打开的 ，固有的ip地址</p>
</li>
<li><p>RRT round-trip time 往返时间</p>
</li>
<li><p>请求报文格式</p>
<ul>
<li>GET POST HEAD PUT DELETE方法 GET最常见</li>
<li>格式  请求行 方法名+url+版本收不行就是主机 连接种类 代理 接受语言等视情况 一些额外的字段信息可能存在与 url中间</li>
</ul>
</li>
<li><p>what we can do with telnet </p>
<ul>
<li><em><strong><font color=pink>telnet 是一个协议 我们可以用telnet命令来模拟请求报文</font></strong></em></li>
</ul>
</li>
<li><p><em><strong>cookie</strong></em></p>
<ul>
<li>基本原理就是四个组件的协调 首先请求报文中有一个cookie首部行 然后相应报文也有 然后服务求后端数据库管理cookie条目 然后浏览器维护一组cookie文件</li>
<li>服务求端set cookie并将其唯一关联用户之后的行为与信息 每次交互时都附加一个cookie首部行</li>
</ul>
</li>
<li><h3 id="web-cache-也就是代理服务器"><a href="#web-cache-也就是代理服务器" class="headerlink" title="web cache 也就是代理服务器"></a>web cache 也就是代理服务器</h3><ul>
<li>作为缓存 既面向用户浏览器作为服务端 也向原始服务器请求作为客户端</li>
<li>大大减低相应时间 的一种方案</li>
<li>not modified 报文段 解决更新问题</li>
</ul>
</li>
<li><h3 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS 域名解析系统"></a><font color=pink>DNS 域名解析系统</font></h3><ul>
<li>应用层协议 也是一个分布式数据库 53 端口号</li>
<li>大致工作情景就是当我使用浏览器请求文件时 浏览器从请求报文中url抽取主机名传送给我们的主机上运行的dns客户端 最后经过服务端传来一个回答报文</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong><font color=pink>之前困扰我的一个问题 为什么有时候有www 有时候域名又没有www <a class="link"   href="https://www.nexcess.net/blog/is-there-any-reason-to-use-www-in-your-domain/" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></strong></em></p>
</li>
<li><p><em><strong>还有就是域名和主机名是不一样的</strong></em></p>
<ul>
<li>一般来说域名就是一个裸的</li>
<li>而主机名会在域名加一些前缀 能够唯一标识一台对应功能的机器</li>
</ul>
</li>
</ul>
<blockquote>
<p>目前所需差不多就是这样 现在暂时结束 10.10</p>
</blockquote>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TLCL</title>
    <url>/2023/05/06/TLCL/</url>
    <content><![CDATA[<h1 id="TLCL"><a href="#TLCL" class="headerlink" title="TLCL"></a>TLCL</h1><ul>
<li><h2 id="Why-Linux？"><a href="#Why-Linux？" class="headerlink" title="Why Linux？"></a><strong>Why Linux？</strong></h2><ul>
<li><h3 id="linux-人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！"><a href="#linux-人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！" class="headerlink" title="linux 人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！"></a>linux 人们会发现只有键盘才是计算机的一个灵魂，使用命令行不是为了看起来高深莫测，而是为解决复杂问题提供一个简化的可能！</h3></li>
<li><h3 id="shell-解释-是kernel-outermost-layer-os向用户提供的一个interface有两种类型的，一种是CLS-cmdline形式的-而对应的有相关的scriped-language-例如bash-还有就是xwindows-驱动的GUI"><a href="#shell-解释-是kernel-outermost-layer-os向用户提供的一个interface有两种类型的，一种是CLS-cmdline形式的-而对应的有相关的scriped-language-例如bash-还有就是xwindows-驱动的GUI" class="headerlink" title="shell 解释 是kernel outermost layer os向用户提供的一个interface有两种类型的，一种是CLS cmdline形式的 而对应的有相关的scriped language 例如bash 还有就是xwindows 驱动的GUI"></a>shell 解释 是kernel outermost layer os向用户提供的一个interface有两种类型的，一种是CLS cmdline形式的 而对应的有相关的scriped language 例如bash 还有就是xwindows 驱动的GUI</h3></li>
</ul>
</li>
<li><p>贴个网址 <a class="link"   href="http://billie66.github.io/TLCL/book/index.html" >TLCL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><a class="link"   href="http://www.gnu.org/software/bash/manual/bashref.html" >bash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li></li>
<li><h2 id="alt-left-arrow-is-black-to-last-page-return-and-ctrl-1-2-3-is-switch-between-different-tabs-good-final-got-some-more-ctrl-T-new-tab-and-ctrl-n-new-windows-ctrl-shift-n-new-inrecognized-windows-AND-TYPE-THE-ALT-YOU-CAN-GO-THE-UPPERRIGHT-CORNER-AND-USE-YOUR-UP-DOWN-RIGHT-LEFT-KEY-TO-CHOOSE-右上防三个原点-点一次-alt就够了-another-smooth-command-use-the-x2F-to-goto-the-search-box"><a href="#alt-left-arrow-is-black-to-last-page-return-and-ctrl-1-2-3-is-switch-between-different-tabs-good-final-got-some-more-ctrl-T-new-tab-and-ctrl-n-new-windows-ctrl-shift-n-new-inrecognized-windows-AND-TYPE-THE-ALT-YOU-CAN-GO-THE-UPPERRIGHT-CORNER-AND-USE-YOUR-UP-DOWN-RIGHT-LEFT-KEY-TO-CHOOSE-右上防三个原点-点一次-alt就够了-another-smooth-command-use-the-x2F-to-goto-the-search-box" class="headerlink" title="alt + left arrow is black to last page return  and ctrl + 1  2  3 is switch between different tabs  good final got some more ctrl + T new tab and ctrl + n new windows ctrl +shift +n new inrecognized windows AND TYPE THE ALT YOU CAN GO THE UPPERRIGHT CORNER AND USE YOUR UP DOWN RIGHT LEFT KEY TO CHOOSE 右上防三个原点 点一次 alt就够了    another smooth command  use the &#x2F; to goto the search box!!!!!"></a><em><strong><font color = pink>alt + left arrow is black to last page return  and ctrl + 1  2  3 is switch between different tabs  good final got some more ctrl + T new tab and ctrl + n new windows ctrl +shift +n new inrecognized windows AND TYPE THE ALT YOU CAN GO THE UPPERRIGHT CORNER AND USE YOUR UP DOWN RIGHT LEFT KEY TO CHOOSE 右上防三个原点 点一次 alt就够了    another smooth command  use the &#x2F; to goto the search box!!!!!</font></strong></em></h2></li>
<li><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><ul>
<li><h4 id="shift-ctrl-6-切出wsl"><a href="#shift-ctrl-6-切出wsl" class="headerlink" title="shift+ctrl+6 切出wsl"></a>shift+ctrl+6 切出wsl</h4></li>
<li><h4 id="winter——主机名，SPIKE——用户名"><a href="#winter——主机名，SPIKE——用户名" class="headerlink" title="winter——主机名，SPIKE——用户名"></a>winter——主机名，SPIKE——用户名</h4></li>
<li><h4 id="date-时间-calendar-日历"><a href="#date-时间-calendar-日历" class="headerlink" title="date 时间 calendar 日历"></a>date 时间 calendar 日历</h4></li>
<li><h4 id="ls-symbolized-stand-for-the-user-directory-ls-could-specify-the-dr-you-wanna-check"><a href="#ls-symbolized-stand-for-the-user-directory-ls-could-specify-the-dr-you-wanna-check" class="headerlink" title="ls ~ ~ symbolized stand for the user directory ls could specify the dr you wanna check."></a>ls ~ ~ symbolized stand for the user directory ls could specify the dr you wanna check.</h4></li>
<li><h4 id="we-could-add-some-format-cmd-to-reveal-more-details-ls-l"><a href="#we-could-add-some-format-cmd-to-reveal-more-details-ls-l" class="headerlink" title="we could add some format cmd to reveal more details ls -l"></a>we could add some format cmd to reveal more details ls -l</h4></li>
<li><h4 id="the-meaning-of-the-long-format-indicate-the-file-type-and-then-the-next-three-letters-indicates-the-access-rights-and-then"><a href="#the-meaning-of-the-long-format-indicate-the-file-type-and-then-the-next-three-letters-indicates-the-access-rights-and-then" class="headerlink" title="the meaning of the long format - indicate the file type and  then the next three letters indicates the access rights and then"></a>the meaning of the long format - indicate the file type and  then the next three letters indicates the access rights and then</h4></li>
<li><h4 id="f11-keystroke-could-full-screenize-the-console"><a href="#f11-keystroke-could-full-screenize-the-console" class="headerlink" title="f11 keystroke could full-screenize the console"></a>f11 keystroke could full-screenize the console</h4></li>
<li><h4 id="file-check-the-brief-info-of-a-file"><a href="#file-check-the-brief-info-of-a-file" class="headerlink" title="file check the brief info of a file"></a>file check the brief info of a file</h4></li>
<li><h4 id="everything-is-file-and-mostly-the-text-file-only-contain-ascii-code"><a href="#everything-is-file-and-mostly-the-text-file-only-contain-ascii-code" class="headerlink" title="everything is file and mostly the text file only contain ascii code"></a>everything is file and mostly the text file only contain ascii code</h4></li>
<li><h4 id="configuration-file-or-the-actually-source-file-most-stored-in-text-file-format"><a href="#configuration-file-or-the-actually-source-file-most-stored-in-text-file-format" class="headerlink" title="configuration file or the actually source file most stored in text file format"></a>configuration file or the actually source file most stored in text file format</h4></li>
<li><h4 id="less-less-is-more-and-the-up-down-arrow-q-h-n-some-key-cmd-you-should-know"><a href="#less-less-is-more-and-the-up-down-arrow-q-h-n-some-key-cmd-you-should-know" class="headerlink" title="less less is more and the up down arrow q h n some key cmd you should know"></a>less less is more and the up down arrow q h n some key cmd you should know</h4></li>
<li><h4 id="there-are-some-standard-pathname-in-unix-like-system-just-feel-free-to-explore-and-dont-mind-we-could-hardly-mess-up-for-the-administrator-keep-everything-in-order"><a href="#there-are-some-standard-pathname-in-unix-like-system-just-feel-free-to-explore-and-dont-mind-we-could-hardly-mess-up-for-the-administrator-keep-everything-in-order" class="headerlink" title="there are some standard pathname in unix-like system just feel free to explore , and dont mind ,we could hardly mess up for the administrator keep everything in order"></a>there are some standard pathname in unix-like system just feel free to explore , and dont mind ,we could hardly mess up for the administrator keep everything in order</h4></li>
<li><h4 id="wildcard-just-the-regular-expression-also-grep"><a href="#wildcard-just-the-regular-expression-also-grep" class="headerlink" title="wildcard just the regular expression also grep"></a>wildcard just the regular expression also grep</h4><ul>
<li>* mean the any chars ? one single char [set] [!set] [[:key:word​]]</li>
</ul>
</li>
<li><h4 id="mkdir-dirc-and-…-eg-mkdir-dir1-dir2-dir3"><a href="#mkdir-dirc-and-…-eg-mkdir-dir1-dir2-dir3" class="headerlink" title="mkdir dirc and … eg mkdir dir1 dir2 dir3"></a>mkdir dirc and … eg mkdir dir1 dir2 dir3</h4></li>
<li><h4 id="cp-mv-rm-like-the-copy-paste-and-cut-delete-in-windows"><a href="#cp-mv-rm-like-the-copy-paste-and-cut-delete-in-windows" class="headerlink" title="cp mv rm like the copy paste and cut delete in windows"></a>cp mv rm like the copy paste and cut delete in windows</h4><ul>
<li>when you want to handle a directory you need to use option -r recrusive</li>
<li><font color=aqua>Be careful with the combo of wildcard and rm so just invoke the ls first to check if the files listed are u really wanna remove no more change to restore the files</font></li>
<li><font color=gold>use the . to indicate the workplace </font></li>
<li><em>if you wanna some warning remeber to use op -i</em></li>
<li><strong>mv is rename also the same time if the file2 exists then is act like move ifnot then like the rename</strong></li>
</ul>
</li>
<li><h4 id="the-x2F-etc-is-text-configured-file-and-the-bin-is-usually-executable-and-x2F-usr-x2F-is-the-largest-folder-in-linux"><a href="#the-x2F-etc-is-text-configured-file-and-the-bin-is-usually-executable-and-x2F-usr-x2F-is-the-largest-folder-in-linux" class="headerlink" title="the &#x2F;etc is text configured file and the bin is usually executable and &#x2F;usr&#x2F; is the largest folder in linux"></a><font color=seagreen>the &#x2F;etc is text configured file and the bin is usually executable and &#x2F;usr&#x2F; is the largest folder in linux</font></h4></li>
<li><p><strong>这个ln 指令 ln -s 创建符号连接 有一点像windows的快捷方式 ln创建的是硬的链接 早期 智能文件 不能目录</strong></p>
</li>
<li><p><em><strong><font color =purple>What is cmd a new set of useful cmds</font></strong></em></p>
<ul>
<li><em><strong>所以命令的本质 有 一个可执行的二进制c函数  2shell python ruby脚本程序 3 shell内置 builtins 4 shell小函数 5 别名</strong></em></li>
<li><em><strong>use the type cmd to check the type of one cmd type [cmd]</strong></em></li>
<li><em><strong>which to check which is the cmd only used for the binary cmd</strong></em></li>
<li><em><strong>help cmd  used for the buildins cmd –help the same</strong></em></li>
<li><em><strong>man ls  use the manual very simple but difficult to read</strong></em></li>
<li><em><strong>apropos + cmd check the tips 挺有用的 apropos vim</strong></em></li>
<li><em><strong>info 一个更友好的 提示 有超链接</strong></em><ul>
<li>n 下一个超链接结点 p 上一个 u当前结点菜单 enter进入</li>
</ul>
</li>
<li><em><strong>zless 可以查看 .gz文件</strong></em></li>
<li><em><strong>whatis 一个简单的描述</strong></em></li>
</ul>
</li>
<li><p><em><strong><font color = pink>可以一行多个命令 用；隔开</font></strong></em></p>
</li>
<li><p><em><strong><font color=pink>alias 在自己命名之前先使用 type查看一下是否已经是已存在的命令 unalias 取消别名</font></strong></em></p>
</li>
<li><p><em><strong><font color =yellow>Evrything is a  file</font></strong></em></p>
</li>
<li><p><em><strong>&gt; 重定向 标准输入输出 错误  &gt; 改变标准输出 注意因此 每一次使用时都会使文件重写</strong></em></p>
</li>
<li><p><strong><font color=red>&gt; 从头开始 &gt;&gt; append  file discripitor 文件描述符 0 1 2 2&gt; 表示方法</font></strong></p>
</li>
<li><p><em><strong><font color=pink>新的方法来同时重定向我们的标准输入与输出&amp;&gt;     dev&#x2F;null 一个没用的数据桶 可以用作丢弃一些不用的显示信息</font></strong></em></p>
</li>
<li><p><em><strong><font color =pink> cat 与standard input 有关 cat 单独就是echo ctrl+z强制退出运行 ctrl+d EOF</font></strong></em></p>
</li>
<li><p><em><strong><font color=blue>ctrl+d 是 EOF</font></strong></em></p>
</li>
<li><p><em><strong><font color=red>| pipeline cmd1|cmd2 将1中的标准输出作为二中的标准输入    cat No?.txt &gt; poem.txt 连续连接文件的例子</font></strong></em></p>
</li>
<li><p>***filter 过滤器 ls -l &#x2F;usr&#x2F;bin &#x2F;bin | sort |uniq [-d看见重复内容]| less ***</p>
</li>
<li><p><em><strong><font color=pink>注意上面几个指令在无参数情况下都是默认接受标准输入 所以 可以使用管道符 很方便  wc 计数</font></strong></em></p>
</li>
<li><p><font color=pink>快乐的echo cmd  is special when use the echo it will do some process called expansion   obviously  when you see the echo it just mean use the regular expression </font></p>
<ul>
<li>***~ echo ~ 显示当前的目录 echo $((expr)) 进行幂展开 ***</li>
<li><em><strong>花括号展开 可以展开字符串表达式</strong></em></li>
<li><em><strong><font color=red>Parameter expansion 参数展开 very important echo $USER 就像这样  一个查看变量的命令 printenv | less</font></strong></em></li>
<li><em><strong><font color=red>command substitution use $(cmd) eg ls -l $(which cp)     file $(ls &#x2F;usr&#x2F;bin&#x2F;* | grep zip) 旧标准中有一个<code>which cp</code>可以代替 $()</font></strong></em></li>
<li><em><strong><font color=red>“”  sleep 单引号 echo -e $转义字符</font></strong></em></li>
<li><em><strong><font color=red>ctrl l     ctrl d   ctrl t  alt u alt l alt t alt f alt b</font></strong></em></li>
<li><em><strong><font color=red>tab alt ？ alt * ctrl k ctrl y set | less TLDR</font></strong></em></li>
</ul>
</li>
<li><h4 id="代表的是父文件-代表当前的工作文件"><a href="#代表的是父文件-代表当前的工作文件" class="headerlink" title=".. 代表的是父文件 . 代表当前的工作文件"></a>.. 代表的是父文件 . 代表当前的工作文件</h4></li>
<li><h4 id="dr-磁盘空间情况-free-内存空间情况"><a href="#dr-磁盘空间情况-free-内存空间情况" class="headerlink" title="dr 磁盘空间情况 free 内存空间情况"></a>dr 磁盘空间情况 free 内存空间情况</h4></li>
<li><h4 id="exit-退出程序"><a href="#exit-退出程序" class="headerlink" title="exit 退出程序"></a>exit 退出程序</h4></li>
<li><h4 id="ls-most-used-cmd-in-shell"><a href="#ls-most-used-cmd-in-shell" class="headerlink" title="ls most used cmd in shell"></a>ls most used cmd in shell</h4></li>
<li><h4 id="用户-superuser-rootuser"><a href="#用户-superuser-rootuser" class="headerlink" title="$ 用户     # superuser rootuser"></a>$ 用户     # superuser rootuser</h4></li>
<li><h4 id="file-navigation·"><a href="#file-navigation·" class="headerlink" title="file navigation·"></a>file navigation·</h4><ul>
<li><h5 id="pwd-print-name-of-workplace-directory"><a href="#pwd-print-name-of-workplace-directory" class="headerlink" title="pwd print name of workplace directory"></a>pwd print name of workplace directory</h5></li>
<li><h5 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd  change directory"></a>cd  change directory</h5></li>
<li><h5 id="ls-list-contents"><a href="#ls-list-contents" class="headerlink" title="ls list contents"></a>ls list contents</h5></li>
<li><h5 id="我们都处于-文件中间-home-通常初始-时-文件树-只有一棵-对于普通用户只有-user里具有写权限-其余需要-root"><a href="#我们都处于-文件中间-home-通常初始-时-文件树-只有一棵-对于普通用户只有-user里具有写权限-其余需要-root" class="headerlink" title="我们都处于 文件中间 home 通常初始 时 文件树 只有一棵 对于普通用户只有 user里具有写权限 其余需要 root"></a>我们都处于 文件中间 home 通常初始 时 文件树 只有一棵 对于普通用户只有 user里具有写权限 其余需要 root</h5></li>
<li><h5 id="absolute-pathname-relative-pathname"><a href="#absolute-pathname-relative-pathname" class="headerlink" title="absolute pathname relative pathname"></a>absolute pathname relative pathname</h5><ul>
<li>&#x2F; 根目录     .. &#x2F; 父目录 	.&#x2F;	当前工作目录 通常默认有这</li>
</ul>
<p>	</p>
</li>
<li><h4 id="cd-pathname"><a href="#cd-pathname" class="headerlink" title="cd + pathname"></a>cd + pathname</h4><ul>
<li>cd   或者是 cd ~默认进入用户文件夹</li>
</ul>
</li>
<li><p>cd ~user_name 进入对应名字 的用户文件夹</p>
<ul>
<li>cd - 回到先前 的文件夹</li>
</ul>
</li>
<li><p>cd .. 回到父文件</p>
</li>
</ul>
</li>
<li><h4 id="开头的文件夹-通常是不显示的-隐藏的-注入configuration-类的文件"><a href="#开头的文件夹-通常是不显示的-隐藏的-注入configuration-类的文件" class="headerlink" title=". 开头的文件夹 通常是不显示的 隐藏的 注入configuration 类的文件"></a>. 开头的文件夹 通常是不显示的 隐藏的 注入configuration 类的文件</h4></li>
</ul>
</li>
<li><h4 id="用-代替文件名-中的空格"><a href="#用-代替文件名-中的空格" class="headerlink" title="用 . _ - 代替文件名 中的空格"></a>用 . _ - 代替文件名 中的空格</h4></li>
<li><h4 id="支持-鼠标中间-paste-双击-copy-或者-选择-copy"><a href="#支持-鼠标中间-paste-双击-copy-或者-选择-copy" class="headerlink" title="支持 鼠标中间 paste 双击 copy 或者 选择 copy"></a>支持 鼠标中间 paste 双击 copy 或者 选择 copy</h4><ul>
<li><h4 id="上下键-寻找历史命令最大500个"><a href="#上下键-寻找历史命令最大500个" class="headerlink" title="上下键 寻找历史命令最大500个"></a>上下键 寻找历史命令最大500个</h4></li>
<li><h4 id="ls指令再探dd"><a href="#ls指令再探dd" class="headerlink" title="ls指令再探dd"></a>ls指令再探dd</h4><ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/lin.png"
                     
                ></p>
</li>
<li><h5 id="short-option-l-一个字母-可以组合-lt"><a href="#short-option-l-一个字母-可以组合-lt" class="headerlink" title="short option  -l 一个字母 可以组合 -lt"></a>short option  -l 一个字母 可以组合 -lt</h5></li>
</ul>
</li>
<li><h5 id="long-option-–reverse-全称"><a href="#long-option-–reverse-全称" class="headerlink" title="long option –reverse  全称"></a>long option –reverse  全称</h5></li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/_1.png"
                     
                ></p>
</li>
</ul>
</li>
<li><h3 id="其实无论怎样都可以-command-–help-查看更多"><a href="#其实无论怎样都可以-command-–help-查看更多" class="headerlink" title="其实无论怎样都可以 command –help 查看更多"></a><font color=gold>其实无论怎样都可以 command –help 查看更多</font></h3></li>
<li><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><ul>
<li>查询文件 类型 file + filename</li>
</ul>
</li>
<li><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><ul>
<li><h4 id="less-查看文本文件-everything-is-file"><a href="#less-查看文本文件-everything-is-file" class="headerlink" title="less 查看文本文件 everything is file"></a>less 查看文本文件 everything is file</h4></li>
<li><h4 id="ascII-as-key"><a href="#ascII-as-key" class="headerlink" title="ascII as-key"></a>ascII as-key</h4><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/less.png"
                     
                ></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="键盘高级操作"><a href="#键盘高级操作" class="headerlink" title="键盘高级操作"></a>键盘高级操作</h4><ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cl.png"
                     
                ></p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cl1.png"
                     
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cl2.png"
                     
                ></li>
</ul>
</li>
<li><h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><ul>
<li>tab  单击</li>
<li>Alt + ? 显示可能的补全列表</li>
<li>Alt + * 插入所有可能的补全操作</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/his.png"
                     
                ></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake</title>
    <url>/2023/09/12/Cmake/</url>
    <content><![CDATA[<h2 id="可以开始了解CMake"><a href="#可以开始了解CMake" class="headerlink" title="可以开始了解CMake"></a>可以开始了解CMake</h2><p><em><strong>只是简单得贴一个网址</strong></em></p>
<p><em><strong>[CMAKE](<a class="link"   href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html" >CMake Tutorial — CMake 3.27.4 Documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</strong></em></p>
<p><em><strong><a class="link"   href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/" >CPPformal <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></p>
<p><a class="link"   href="https://github.com/nlohmann/json" >json <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>[redfiredoc](<a class="link"   href="https://redefine-docs.ohevan.com/getting-started" >快速开始 - Redefine Docs (ohevan.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>
]]></content>
      <tags>
        <tag>Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP</title>
    <url>/2023/09/16/CSAPP/</url>
    <content><![CDATA[<ul>
<li><h2 id="CSAPP"><a href="#CSAPP" class="headerlink" title="CSAPP"></a>CSAPP</h2><ul>
<li><h3 id="terms-colletion"><a href="#terms-colletion" class="headerlink" title="terms colletion"></a>terms colletion</h3><ul>
<li>snippet re-useble code part maybe name the directory</li>
</ul>
</li>
<li><h3 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h3><ul>
<li>to long didn’t read and a linux simplified manual cm</li>
</ul>
</li>
<li><p><a href="/doc/normal.pdf">Try</a></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>TGA_CXX</title>
    <url>/2023/09/22/TGA-CXX/</url>
    <content><![CDATA[<h3 id="TGA关于c"><a href="#TGA关于c" class="headerlink" title="TGA关于c++"></a><font color=seablue>TGA关于c++</font></h3><ul>
<li><h4 id="C-操作文件-这里记录一些相关要用的知识点-便于统一看"><a href="#C-操作文件-这里记录一些相关要用的知识点-便于统一看" class="headerlink" title="C++操作文件 这里记录一些相关要用的知识点 便于统一看"></a>C++操作文件 这里记录一些相关要用的知识点 便于统一看</h4><ul>
<li>**流访问，有open std::ios::binary ,.good(),.get(),.read()的一些参数 **</li>
<li><strong>重载函数规范有点忘记。</strong></li>
<li><strong>copy (stored data) to a different location, especially so as to protect against loss.  <font color=gold>dump in computer mean</font></strong></li>
<li><strong>ESCAPE SYMBOL 溢出符号</strong></li>
<li><strong><font color=seagreen>Run-length encode a lossless encode method  just to replace the runS(many values occurs consecutivelt) w12b2cd13e32 .eg</font></strong></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/const.png"
                      alt="const只是语法检查 所以地址转换是一个编程漏洞"
                ></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>CXX</tag>
      </tags>
  </entry>
  <entry>
    <title>TLCL@2</title>
    <url>/2023/09/30/TLCL-2/</url>
    <content><![CDATA[<h2 id="TLCL"><a href="#TLCL" class="headerlink" title="TLCL"></a>TLCL</h2><blockquote>
<p>新的开始 </p>
</blockquote>
<h4 id="今天怒创了两个用户-密码都是老密码alt-t-google-translate-x2F-the-search-box-alt-left-ctrl-shift-aalt-左右键是返回上一个页面-ctrl-tab-下一个标签-ctrl-shift-tab-上一个"><a href="#今天怒创了两个用户-密码都是老密码alt-t-google-translate-x2F-the-search-box-alt-left-ctrl-shift-aalt-左右键是返回上一个页面-ctrl-tab-下一个标签-ctrl-shift-tab-上一个" class="headerlink" title="今天怒创了两个用户 密码都是老密码alt t google translate &#x2F; the search box alt left   ctrl shift aalt 左右键是返回上一个页面 ctrl tab 下一个标签 ctrl shift tab 上一个 "></a><font color=aqua>今天怒创了两个用户 密码都是老密码<br>alt t google translate &#x2F; the search box alt left   ctrl shift a<br>alt 左右键是返回上一个页面 ctrl tab 下一个标签 ctrl shift tab 上一个 </font></h4><h3 id="发现两个有用的东西-google搜索栏使用小数字键盘的上下键可以查看推荐搜索-然后就是cmd中打开md-x2F-example-md-键入就可以-原来要运行可运行文件要在前面加上一个-x2F"><a href="#发现两个有用的东西-google搜索栏使用小数字键盘的上下键可以查看推荐搜索-然后就是cmd中打开md-x2F-example-md-键入就可以-原来要运行可运行文件要在前面加上一个-x2F" class="headerlink" title="发现两个有用的东西 google搜索栏使用小数字键盘的上下键可以查看推荐搜索 然后就是cmd中打开md .&#x2F;example.md 键入就可以 原来要运行可运行文件要在前面加上一个.&#x2F;"></a><font color=pink>发现两个有用的东西 google搜索栏使用小数字键盘的上下键可以查看推荐搜索 然后就是cmd中打开md .&#x2F;example.md 键入就可以 原来要运行可运行文件要在前面加上一个.&#x2F;</font></h3><h4 id="command-syntaxsyntax2syntax3q-amp-a"><a href="#command-syntaxsyntax2syntax3q-amp-a" class="headerlink" title="command syntaxsyntax2syntax3q&amp;a"></a><font color=seagreen><a class="link"   href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key" >command syntax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="http://docopt.org/" >syntax2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_01" >syntax3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://stackoverflow.com/questions/9725675/is-there-a-standard-format-for-command-line-shell-help-text" >q&amp;a <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></h4><h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/history.png"
                      title="历史的操作"
                ></p>
<ul>
<li><h3 id="历史操作"><a href="#历史操作" class="headerlink" title="历史操作"></a>历史操作</h3><ul>
<li><em><strong>history 操作，history | less |grep tldr</strong></em></li>
</ul>
</li>
<li><h3 id="权限security"><a href="#权限security" class="headerlink" title="权限security"></a>权限security</h3><ul>
<li><em><strong>change the mode chmod cmd 改变rwx属性可以使用八进制数字来表示也可以用字符 <font color=red><a class="link"   href="http://billie66.github.io/TLCL/book/chap10.html" >chmod <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></font></strong></em></li>
<li><em><strong>su and sudo su 就是以另一个身份运行shell 而sudo是以另一个身份执行命令 最大的区别是su会重建一个设立了环境 而sudo不会</strong></em></li>
<li><em><strong>chown 改变用户权限 目前使用不是很多</strong></em></li>
<li><em><strong>passwd 命令用作更改i密码</strong></em></li>
<li><em><strong><font color=pink>good in wsl2 额可以touch 创建文件 同时可以code 编辑code似乎有许多有趣的指令</font></strong></em></li>
<li><em><strong><font color=red>想要切换用户 也就是一个全新的bash的话 用 su -l doudou .eg 退出的时候使用 exit就可以了</font></strong></em></li>
<li><em><strong><font color=blue>至于使用创建用户的命令就是adduser name 注意名字不能以大写字母开头 doudou</font></strong></em></li>
</ul>
</li>
<li><h3 id="核心概念-Process-进程link"><a href="#核心概念-Process-进程link" class="headerlink" title="核心概念 Process 进程link"></a>核心概念 Process 进程<a class="link"   href="http://billie66.github.io/TLCL/book/chap11.html" >link <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul>
<li><em><strong>init kernel进行run&#x2F;etc里的script所以为什么可以更改的原因</strong></em></li>
<li><strong>ctrl + c 强制返回的一种方法</strong></li>
<li><em><strong><font color=pink>&#x2F;proc    &#x2F;sys 文件系统 可以查看相关硬件划分信息</font><br>备份文件的名字无关紧要，只要选择一个容易理解的文件名。扩展名 “.bak”、”.sav”、 “.old”和 “.orig” 都是用来指示备份文件的流行方法。哦，记住 cp 命令会默默地覆盖已经存在的同名文件。  bak stand for backup file</strong></em></li>
</ul>
</li>
<li><h3 id="Nano与其他文本编辑器"><a href="#Nano与其他文本编辑器" class="headerlink" title="Nano与其他文本编辑器"></a>Nano与其他<a class="link"   href="http://billie66.github.io/TLCL/book/chap12.html" >文本编辑器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul>
<li><em><strong><font color=pink>之前学的很多bash的指令到很多编辑器里都是一样的</font></strong></em></li>
<li><em><strong><font color=pink>source .bashrc 生效指令</font></strong></em></li>
<li><em><strong><font color=pink>ctrl o in nano 保存</font></strong></em></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>signature</title>
    <url>/2023/10/02/signature/</url>
    <content><![CDATA[<h2 id="ps了一个签名方便以后用"><a href="#ps了一个签名方便以后用" class="headerlink" title="ps了一个签名方便以后用"></a><font color=pink>ps了一个签名方便以后用</font></h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%AD%BE%E5%90%8D.png"
                      alt="我的签名"
                ></p>
<blockquote>
<p>你别说有点书法的感觉 哈哈哈哈哈！</p>
</blockquote>
<h3 id="还是应该记录下方法-ps-魔棒选择-每次扣几笔然后ctrl-c-ctrlv-复制一个图层-最后合并可见图层"><a href="#还是应该记录下方法-ps-魔棒选择-每次扣几笔然后ctrl-c-ctrlv-复制一个图层-最后合并可见图层" class="headerlink" title="还是应该记录下方法 ps 魔棒选择 每次扣几笔然后ctrl c ctrlv 复制一个图层 最后合并可见图层"></a><font color=pink>还是应该记录下方法 ps 魔棒选择 每次扣几笔然后ctrl c ctrlv 复制一个图层 最后合并可见图层</font></h3>]]></content>
      <tags>
        <tag>signature</tag>
      </tags>
  </entry>
  <entry>
    <title>TLCL@3</title>
    <url>/2023/10/04/TLCL-3/</url>
    <content><![CDATA[<h2 id="TLCL-chapter-3"><a href="#TLCL-chapter-3" class="headerlink" title="TLCL chapter 3"></a>TLCL chapter 3</h2><h3 id="GOOOOOOOOOOOOOOD-解决了上传静态文件的-问题-在markdown里面变成-download-images-file-normal-pdf"><a href="#GOOOOOOOOOOOOOOD-解决了上传静态文件的-问题-在markdown里面变成-download-images-file-normal-pdf" class="headerlink" title="GOOOOOOOOOOOOOOD 解决了上传静态文件的 问题 在markdown里面变成 [download](\..\images\file\normal.pdf)"></a><font color=pink>GOOOOOOOOOOOOOOD 解决了上传静态文件的 问题 在markdown里面变成 [download](\..\images\file\normal.pdf)</font></h3><ul>
<li><h3 id="发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记"><a href="#发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记" class="headerlink" title="发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记"></a><font color=aqua>发现一个很妙的事就是分屏可以将鼠标与键盘控制分开很适合边看边写笔记</font></h3></li>
<li><h3 id="文件操作here"><a href="#文件操作here" class="headerlink" title="文件操作here"></a>文件操作<a class="link"   href="http://billie66.github.io/TLCL/book/chap16.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ul>
<li>设计很多底层硬件，由于wsl与虚拟机文件差别较大暂时skip read</li>
</ul>
</li>
<li><h3 id="网络葵花宝典下载"><a href="#网络葵花宝典下载" class="headerlink" title="网络葵花宝典下载"></a>网络<a href="/doc/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.pdf">葵花宝典下载</a></h3><ul>
<li>netstat 指令</li>
<li>ftp指令</li>
<li>telnet指令 都是可以直接使用相关协议</li>
<li>ftp lftp都可以下载文件</li>
<li><em><strong><font color=pink>wget指令直接下载界面 可行男泵</font></strong></em></li>
</ul>
</li>
<li><h3 id="SSH-secure-shell"><a href="#SSH-secure-shell" class="headerlink" title="SSH secure shell"></a>SSH secure shell</h3><ul>
<li><strong>这是一个协议 port number22</strong></li>
<li><strong><a class="link"   href="https://phoenixnap.com/kb/ssh-to-connect-to-remote-server-linux-or-windows#:~:text=Open%20the%20terminal%20on%20the,ssh%20localhost%20and%20hit%20enter." >一个sshlocalhost教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></li>
<li><strong>最近ssh遇到很多问题这里集中总结一下</strong><ul>
<li><strong>关于启动服务器<a class="link"   href="https://askubuntu.com/questions/1379425/system-has-not-been-booted-with-systemd-as-init-system-pid-1-cant-operate" > <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <br><font color=red> sudo service ssh restart 这个命令有作用 类似的还有 sudo service ssh status 关键就是 service 操作具体可见tldr service</font></strong></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="locate-amp-find"><a href="#locate-amp-find" class="headerlink" title="locate &amp; find"></a>locate &amp; find</h3><ul>
<li><em><strong><font color=pink>我是真的有病，又一次忘记保存全部没了</font></strong></em></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\github.1.0\My_blog_hexo\source\images\tests.png"
                     
                ></li>
</ul>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\github.1.0\My_blog_hexo\source\images\lo.png"
                     
                ></p>
<ul>
<li><p><strong>注意可以进行执行自己的操作 -exec cmd ‘{}’ ‘;’ 注意 {} ； 必不可少 {} 代表的是当前路径 ； 代表命令的结束 要引用起来 因为都是特殊涵义的字符 可以用+ 这样就是全部执行 而不是每次都执行一次 同时可以用-ok 指令代替我们的-exec 这样每次都会进行一下询问 ！！！！</strong></p>
</li>
<li><p><strong><font color=green>压缩文件</font></strong></p>
<ul>
<li><em><strong>gzip and gunzip</strong></em></li>
<li><em><strong>gzip + file 注意没有中间选项 此时是原始文件 但是可以对一压缩的文件进行选项查看</strong></em></li>
<li><em><strong>gunzip -c file.gz 查看压缩文件的内容</strong></em></li>
<li><em><strong>bzip2 也是一个类似于 gzip的命令 压缩程度更高 gzip -d 就相当于解压缩了</strong></em></li>
</ul>
</li>
<li><p><strong><font color=blue>归档文件 archiving !!!!</font></strong></p>
<ul>
<li><strong>tar tape archive 备份归档 一组独立的文件或者几个目录 或者两者兼有 通常后缀 为.tar h或者 .tgz 表示 gzip压缩过的归档包</strong></li>
<li><strong>四个模式 注意先写模式 再写选项</strong></li>
<li><strong>cf czf 都是创建 tvf 列举查看 xf xvf 就是复原 注意路径名格式</strong></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/tar.png"
                     
                ></li>
<li><em><strong>zip unzip 与tar和gzip的结合  类似 但是更多用于 与windows交互</strong></em></li>
</ul>
</li>
<li><p><em><strong>同步<a class="link"   href="http://billie66.github.io/TLCL/book/chap19.html" >可以看看但是似乎目前用的不多 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></p>
</li>
<li><p><em><strong><font color=pink>中间暂时跳过了文本处理和正则来个比较重要的make</font></strong></em></p>
<ul>
<li>脚本语言不需要编译 而是直接执行 例如 shell脚本 python PHP perl ruby</li>
<li>tar tzvf tarfile | head — 检查指令</li>
<li>通过这个可以看到一些标准版本源代码的组织形式 其中有一些大写的如README INSTALL 等介绍文件 同时 还有configure文件用于 配置的 同时就是各种头文件和源文件</li>
<li><em><strong><font color=red>系统的源码通常维护再&#x2F;usr&#x2F;src 中 供多个用户试用的源码通常再&#x2F;usr&#x2F;local&#x2F;src 中</font></strong></em></li>
<li>构建通常两步 .&#x2F;configure make</li>
<li>.&#x2F;configure 主要配置相关的需要的环境和依赖项同时创建makefile</li>
<li>sudo make install 对于一些包装良好的库 可以直接执行此命令安装成功</li>
</ul>
</li>
<li><p><em><strong><font color=pink>LINUX小子第二步——Shell脚本</font></strong></em></p>
<ul>
<li>编写脚本三步</li>
<li><em><strong>写一个脚本</strong></em></li>
<li><em><strong>让其可执行 chomod 755 file 对所有人都可执行 700只有拥有者可以执行</strong></em></li>
<li><em><strong>放在一个shell能找到的位置 配置PATH 这个原理就是对于可执行文件 如果直接输入名字 shell会在环境变量的path路径中寻找 因此对于通常自己的没有位于相关路径的脚本是找不到的所以需要文件路径通常我们使用相对路径 .&#x2F;prog</strong></em></li>
</ul>
</li>
<li><p><em><strong><font color=green>安装chrome成功 还得是微软教程但是有乱码的问题同时除了搜索以为ia其他时候都很慢</font></strong></em></p>
</li>
<li><p><em><strong><font color=green>Good 现在查看html文件就直接google-chrome + 文件路径</font></strong></em></p>
</li>
<li><h3 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a><font color=blue>脚本编写</font></h3><ul>
<li><em><strong>注意通常而言在脚本里面 全大写代表常量 小写代表变量</strong></em></li>
<li><em><strong>一定要正确的书写变量名 在命令行内也可以直接进行变量使用 不需要提前声明 declare -r TITLE 强制命令常量</strong></em></li>
<li><em><strong>变量名展开的几种形式</strong></em></li>
<li><img src="/../images/vara.png" alt="../images/vara.png"></li>
<li><em><strong><font color =red>还有一种高级的操作叫作 here document <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/here.png"
                     
                ></font></strong></em></li>
<li><em><strong>shell函数</strong></em><ul>
<li>function name{} &#x2F; name(){}两种</li>
<li>先定义在使用 return语句控制权</li>
<li>局部变量在内部</li>
<li>定义方式 local var eg local foo foo&#x3D;0 外部不存在</li>
<li>完全可以用脚本函数 直接写道 .bashrc中 来代替别名</li>
</ul>
</li>
<li><strong>分支控制</strong><ul>
<li>$? 检测最近的一个指令执行退出情况 0为成功</li>
<li>上述的这个正是if控制实现的底层原理</li>
<li>格式就是if cmd;the cmd; fi 可以借[elif]<ul>
<li>还有各种文件比较操作<a class="link"   href="http://billie66.github.io/TLCL/book/chap28.html" >逆天 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>通常是if [expression]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color=MediumSpringGreen>Df -h 指令 查看所有磁盘情况 不错的指令</font></p>
</li>
<li></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>BombLab</title>
    <url>/2023/10/07/BombLab/</url>
    <content><![CDATA[<h3 id="血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫"><a href="#血淋淋的教训啊-关bash的时候一起关了-直接没保存-全部没了-😫" class="headerlink" title="血淋淋的教训啊 关bash的时候一起关了 直接没保存 全部没了 😫"></a><font color=pink>血淋淋的教训啊 关bash的时候一起关了 直接没保存 全部没了 😫</font></h3>]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑电路</title>
    <url>/2023/10/11/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="大爱逻辑电路，简洁是美的灵魂"><a href="#大爱逻辑电路，简洁是美的灵魂" class="headerlink" title="大爱逻辑电路，简洁是美的灵魂"></a><font color=pink>大爱逻辑电路，简洁是美的灵魂</font></h3>]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Parallel-Programming</title>
    <url>/2023/10/12/Parallel-Programming/</url>
    <content><![CDATA[<h3 id="HPC-Parallel-Programming、"><a href="#HPC-Parallel-Programming、" class="headerlink" title="HPC - Parallel-Programming、"></a>HPC - Parallel-Programming、</h3><h3 id="重大发现就是我们的这个触摸板-可以做到切换-多个手指同时下滑-就可以显示桌面-左右滑动就可以实现-alt-的切换功能-然后还有就是-f11-对于我们的网页-也可以进行全屏显示-f12-进行监测-同时-还可以触摸屏左右两指滑动进行返回前进历史返回-发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退-使用三个手指是alt功能-使用四个手指是windows桌面切换-还有一个就是-ctrl-e-时搜索url框"><a href="#重大发现就是我们的这个触摸板-可以做到切换-多个手指同时下滑-就可以显示桌面-左右滑动就可以实现-alt-的切换功能-然后还有就是-f11-对于我们的网页-也可以进行全屏显示-f12-进行监测-同时-还可以触摸屏左右两指滑动进行返回前进历史返回-发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退-使用三个手指是alt功能-使用四个手指是windows桌面切换-还有一个就是-ctrl-e-时搜索url框" class="headerlink" title="重大发现就是我们的这个触摸板 可以做到切换 多个手指同时下滑 就可以显示桌面 左右滑动就可以实现 alt 的切换功能 然后还有就是 f11 对于我们的网页 也可以进行全屏显示 f12 进行监测 同时 还可以触摸屏左右两指滑动进行返回前进历史返回 发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退 使用三个手指是alt功能 使用四个手指是windows桌面切换 还有一个就是 ctrl + e 时搜索url框"></a><font color=pink>重大发现就是我们的这个触摸板 可以做到切换 多个手指同时下滑 就可以显示桌面 左右滑动就可以实现 alt 的切换功能 然后还有就是 f11 对于我们的网页 也可以进行全屏显示 f12 进行监测 同时 还可以触摸屏左右两指滑动进行返回前进历史返回 发现一个巨大的新东西就是我们使用两个手指左右滑动是历史前进后退 使用三个手指是alt功能 使用四个手指是windows桌面切换 <br>还有一个就是 ctrl + e 时搜索url框</font></h3><ol>
<li><h3 id="并行程序设计入门开始"><a href="#并行程序设计入门开始" class="headerlink" title="并行程序设计入门开始"></a><font color=seablue>并行程序设计入门开始</font></h3><ol>
<li><strong><a class="link"   href="https://heptagonhust.github.io/HPC-roadmap/" >RoadMap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>来自七边形</strong></li>
<li><em><strong>这里文件<a href="/doc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA.pdf">并行设计</a></strong></em></li>
<li><strong><a class="link"   href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html" >Nvidia cuda guidance <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></li>
<li><em><strong>MPI<a class="link"   href="https://www.netlib.org/utk/papers/mpi-book/mpi-book.html" >tutorial <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em></li>
<li>MPI<a class="link"   href="https://mpitutorial.com/tutorials/mpi-introduction/" >manual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#optimizing-cuda-applications" >nvidia <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><font color=violet>下载了几个nvidia的的samples在happyplace&#x2F;0a 里面 可以make一下</font></li>
<li></li>
<li><em><strong>这里保存几个markdown的颜色</strong></em></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee1.png"
                     
                ></p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee2.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee3.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee4.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ee5.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>HPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Begin_Again</title>
    <url>/2023/10/15/Begin-Again/</url>
    <content><![CDATA[<h3 id="计算机科学中的自然原理"><a href="#计算机科学中的自然原理" class="headerlink" title="计算机科学中的自然原理"></a>计算机科学中的自然原理</h3><ul>
<li><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><font color =green>感谢过去一年中给予我启发的诸多事物，无论是一本书如CSAPP，一堂课如数字电路，或者一个人如Prof.Strang，所有这些人事都是促使我更加严肃地审视计算机科学与其背后丰富而美丽的思想。所以，我希望继承那些前辈，那群充满热情与想象力的先驱的工作，在这里对CSAPP中的美妙理论进行简答而又深刻的阐释（有点自大哈哈哈哈），希望在有限的时间与文字中，探寻科学与自然的美。</font></strong></p>
</li>
<li><h2 id="你好！世界"><a href="#你好！世界" class="headerlink" title="你好！世界"></a><font color=pink>你好！世界</font></h2><blockquote>
<p>萨冈和她的你好忧愁，我和我的你好世界。Hello World,梦开始的地方，我们就从一个hello world.c 程序的生命开始进行一场快速的计算机世界漫游。</p>
</blockquote>
<ul>
<li><font color=aqua>程序是怎么编写的呢，首先我们会需要一个文本编辑器，也就是我们常用的devc++或者是vscode，vim，emacs。文本编辑器就是编辑文本文件的，我们缩写的源文件也属于文本文件。文本文件就是只含有阿斯克码的文件，其余的文件都是二进制文件。编写后，我们就可以通过一系列指令来使程序运行。对于一个.c文件而言。我们可以用gcc 命令来生成可执行文件。gcc就似乎编译驱动程序 这是nux终端的命令。当启用后，首先运行的是预处理器，对于含#的指令，如#include预处理器会将头文件全部插入到源文件中，同时完成宏的拓展。这是纯粹的文本替换，其他什么都没有发生。然后就是编译器，编译器将.c文件转换为汇编语言格式，可以理解为机械码的助记符，这是程序员可以阅读和编写的。然用汇编器汇编为二进制，此时是一个可重定位的可执行文件，此时通过ld将引用的库一起链接形成一个可执行文件保存在内存中。调用时，通过加载器加载到cpu进行执行。</font></li>
<li><font color=pink>几个关键概念。首先，计算机的硬件组成。CPU，内存空间极其缓存结构和虚拟地址，网络与I&#x2F;O 进程与线程。这里我们能慢慢接触到抽象与设计的感觉。</font></li>
<li><font color=blue><em><strong>一切皆文件 ，linux将设备文件都以同一种方式进行处理，让建立一种广泛而统一的接口成为可能</strong></em></font></li>
</ul>
</li>
<li><h2 id="从理论到实践"><a href="#从理论到实践" class="headerlink" title="从理论到实践"></a><font color=MediumAquamarine>从理论到实践</font></h2><p><strong><font color=ForestGreen>在学习每一个章节的过程中，我们会逐渐感觉到与一些相似的内容串联了起来。这种知识路径形成环，环闭合的感觉非常类似于我在高中看科幻小说时形成的想法。哈哈哈哈哈。这里就列举所有对应的知识群，然后随着不断学习深入，持续补充~~（突然想到也许我得去补充几个emoji和颜文字）</font></strong></p>
<ul>
<li><strong><font color=Lavender>二进制族群——数字电路的设计非常优美简洁;CPU流水线；</font></strong></li>
<li><strong><font color=lavender>程序机器级表示——优化技巧</font></strong></li>
<li><strong><font color=lavender>链接——Makefile脚本和Cmake 的使用 以及Vscode 相关json文件的配置</font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
<li><strong><font color=lavender></font></strong></li>
</ul>
</li>
<li><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><ul>
<li><font color=brown>浮点数与整数两种格式，拥有不同的表示方法，所以进行类型转换时要注意。整型通过补码表示。公式是唯一的-2^n + 源码的二进制。浮点数是一中近似的表示，对于太多小数位，进行加减时可能出现差。还有就是有符号与无符号的区别以及对应的溢出问题，截断问题。最后就是其实很多函数%d 并不关心真正的类型也不会检查，这只是告诉函数将以一个整型的方式进行内存寻找。</font></li>
<li><font color=cyan>big-end &amp;&amp; small -end 大小端 注意只存在于多个字节的数据的问题 例如0x12345678 小端机就是 78 56 34 12 就是地位在小地址，注意在网络编程获取主机名于端口时可能有影响，需要调用相应修改转换函数。</font></li>
<li><font color =Orchid>计算机处理加法乘法都远远快于除法。同时可以尽量写位运算，当然编译器可能也帮你优化。数字的表示与实现都很精妙 前辈的只会佩服。</font></li>
</ul>
</li>
<li><h2 id="汇编简介"><a href="#汇编简介" class="headerlink" title="汇编简介"></a><font color=PowderBlue>汇编简介</font></h2><ul>
<li><font color=Orchid>首先我们要知道，计算机只认识01，01 构成了整个世界，在数字电路的学习中我们也能有这样的体会。事实上，我们所写的程序最终会转换成01的机器代码，所有的文件不论是文本视频图片文件最终都是01串。而汇编代码就是位于机器代码的一种助记符</font></li>
</ul>
</li>
<li><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><font color=Tan>链接</font></h2></li>
<li><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><font color=Maroon>进程</font></h2><ul>
<li><h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a><strong><font color=Teal>MPI</font></strong></h3><p><strong><font color=DarkCyan>这里就把mpi的使用在这里写了。先补充一点前置知识。冯诺依曼体系。cpu主存分离。导致大多时钟时间去访存。进程就是一个程序的实例可以看成一个综合体包括I&#x2F;o设备即一组文件描述符表，然后主存，前两者共同由虚拟地址实现。此为被处理器表现为独享。多任务即并发。每一个执行时间片。上下文切换。因此硬件计算的优化集中在对冯诺依曼体系的优化大致有如下几个。<br>Cache 在主存与寄存器之间设置三层高速缓存，SRAM，利用局部性原理<br>虚拟地址，可以看作讲主存作为磁盘文件的Cache.同时还有很多好处，如简化加载链接，提供更安全的地址守护等。<br>指令级并行<br>线程级并行TLP 细粒度多线程就是一个线程每执行他的一条指令就切换。粗粒度就是在遇到需要较长时间的指令才切换<br>SMT 同步多线程<br>SISD 单指令流 单数据流 SIMD 单数据多指令流 处理向量运算 大型简单计算GPU就是 处理图像 大量线程 具体可以在学习CUDA后补充<br>MIMD 两种常见类型 注意有多个处理单元即多个处理器 是异步的没有全局时钟 一个是共享内存系统，多个核共享一个内存系统，分布式内存系统，多个核——内存对。第一类具体有两个<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/UMA.png"
                     
                ><br>分布式 最常见的就是cluster集群 以太网连接的一组PC就是 而每一台本身可能是共享内存所以称为混合系统<br>互联网络，可以理解为连接结点的结构。性能依赖于信息读取传输，而这有由硬件的互联网络决定。<br>共享内存系统中有两个 总线bus和交叉开关矩阵crossbar容易理解总线结构简单固定 ，小规模时高效，当结点增多可能出现阻塞，抢夺，因为大小是固定的，无法调整。<br>CrossBar <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Switch.png"
                     
                ><br>上图结构保证了不会出现信息覆盖<br>分布式网络互联结构 其实就是互联网本身的一些结构了<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/net.png"
                     
                ><br>带宽是衡量网络传输速度的，宽度就是讲网络划分为两部分最少的同时通信数量<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/net2.png"
                     
                ><br>延迟和带宽 两个指标<br>共享一致性问题以及解决方案 首先由于Cache 当一个x的内存值改变时，另一个核中cache里缓存的值可能没变。两种方法解决，监听总线和用目录记录。伪共享问题与cache 命中有关 尤其与cache大小有关 当一个核的工作区恰好覆盖一个缓存时，那么就会发生进程间跳跃地对缓存覆盖，最终其实没有共享，反而增加不命中率。<br>对于共享内存系统我们通常派生多线程，分布式我们派生多进程<br>SPMD 单程序多数据流 if(thread0&#x2F;process 0){}elif(1&#x2F;1){}的结构<br>共享内存中的问题：线程不确定性 通过 mutex 和 信号量来互斥实现 同时对于可重入函数的使用 对应的许多拥有static变量的函数就是线程不安全函数当多个线程调用时可能发生问题，解决方法可以是自己上锁或者调用对应库中的线程安全函数<br>分布式中的问题：最多的API就是解决消息传递的。而且其也可以在共享内存中使用，原理就是逻辑上讲共享空间分割为多个独立空间有点像虚拟空间的操作 通常这样的API包含一个send 一个recv函数 然后rank来唯一表示进程 然后缓冲区区分 然后0对应stdout 以及一些广播和归约函数，最常见API MPI message passing interface <br>输入输出问题 输入输出问题常常因为异步而具有不确定性这里有一些规范convention</font></strong></p>
<p><strong><font color=pink>习惯<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/convention.png"
                     
                >总结而言就是没有任何两个文件标识符在实际输入输出时交叉，各自分组线程独自管理<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/speedup.png"
                     
                >可扩展性 增加规模与同时增加核数线程数。效率不变<br>计时通常指程序开始到结束的时间</font></strong></p>
<p><strong><font color=Teal>并行程序设计步骤Foster方法<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/fosterm.png"
                     
                >注意就是平均分配 同时要注意凝聚如果下一个依赖于上一个就可以凝聚为一个任务</font></strong></p>
</li>
<li><p><strong><font color=lightyellow>MPI详解</font></strong></p>
<ul>
<li><font color=yellow>通信子，通信子可以看作一组可以互相通信的进程，初始时有MPI创建了一组WORLD,可以创建多组。可以调用函数得知对应大小以及每一个的rank。</font></li>
<li><font color=yellow>Recv 与 Send函数的语义。各自有自己的缓冲区其实就是指定的存储区。tag用于互相匹配。有status结构来实际获取。匹配包括：同一个communicator，rank匹配。tag匹配。传输信息type匹配。接受去内存大于发送区。对于接受函数有两个宏量。MPI_ANY_SOURCE MPI_ANY_TAG 字面意思就是可以任意接受。发送没有 且一定要指定好comm</font></li>
<li><font color=yellow>MPI_Status参数获取实际传送的字节数。MPI_STATUS_IGNORE</font></li>
<li><font color=yellow>Send语义，可以阻塞，此时不返回。可以缓冲，放入内部存储器，然后返回。返回时并不知道是否成功发送。实际是如果发送信息小于默认的截止大小就缓存，否则就阻塞。Recv一定阻塞。可能出现悬挂</font></li>
<li><font color=yellow></font></li>
</ul>
</li>
</ul>
</li>
<li><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a><font color=slateblue>CUDA</font></h2><ul>
<li><font color=slategrey>CPU 芯片，其实L3缓存占占据了最大的位置 <br>重要的任务就是判断是任务间是否独立 如果独立可能才可以分离task 就是指的一些指令和数据的集合<br>task parallelism 关注多核上的函数并行 data parallelism 关注多核上的数据并行 cuda、主要解决data parallelism <br>核利用率的问题</font></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>自然</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/20/CS224N/</url>
    <content><![CDATA[<h1 id="CS224N"><a href="#CS224N" class="headerlink" title="CS224N"></a><font color=velvet>CS224N</font></h1><ul>
<li><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a><font color=MediumSpringGreen>前置知识</font></h2><ul>
<li><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a><font color=chocolate>什么是机器学习</font></h3><ul>
<li>机器学习我的理解就是在一定条件下完成一定任务，其中任务的完成由程序本身实现。</li>
<li>监督学习 类似回归问题和分类问题</li>
<li>无监督学习类似聚类算法，没有提前的正确规则，让机器找规律</li>
</ul>
</li>
<li><h3 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a><font color=pink>梯度下降算法</font></h3><ul>
<li>同步更新所有变量 </li>
<li>出发点是想要拟合一段数据 然后我们想让整个数据组的误差最小。因此我们求导。可以理解为山坡上寻找下降路线。由于公式会随着接近局部最小点而自己缩小前进距离这是一个学习。</li>
</ul>
</li>
<li><p><font color=seagreen>输入是一个特征向量 的函数求偏导本质就是我们在微积分里面学习的矢量函数求导链式法则 θ的每个分量看作一个维度 然后是复合函数求导</font></p>
</li>
</ul>
</li>
<li><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a><font color =violet>极大似然估计</font></h3><ul>
<li>就是我们依照描述的事件写出这个事件发生的概率表达式，这个表达式由一个变量（涉及概率密度）决定。我们想求这个变量使得改概率函数取一个最大值。</li>
</ul>
</li>
<li><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a><font color=Maroon>代价函数</font></h3><ul>
<li>感觉与目标函数类似，一般与误差函数具有相同或者相反的单调性，然后通过一些数学技巧进行改写，以简化计算。</li>
</ul>
</li>
<li><h3 id="Batch-Gradient-Descent"><a href="#Batch-Gradient-Descent" class="headerlink" title="Batch Gradient Descent"></a><font color=Teal>Batch Gradient Descent</font></h3><ul>
<li>这个就是传统的梯度下降，每一次前进时都要求遍历整个数据集来更新计算代价函数然后求偏导，计算量是非常巨大与难以实现的。具体原因我们会发现，偏导数求得的公式与每一个样本都有联系，例如差平方求和之类的。</li>
</ul>
</li>
<li><h3 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a><font color=Aqua>Linear Algebra</font></h3><ul>
<li>在此再次向Pro.Strang致以最崇高的敬意。</li>
</ul>
</li>
<li><h3 id="注意点——向量拓展的梯度下降以及向量函数"><a href="#注意点——向量拓展的梯度下降以及向量函数" class="headerlink" title="注意点——向量拓展的梯度下降以及向量函数"></a><font color=gold>注意点——向量拓展的梯度下降以及向量函数</font></h3><ul>
<li><p>注意函数变量的两个层面，一个是输入样本的维度，即样本向量的每一个维度，另一个是拟合函数中的变量即θ。h(x)(假设函数)&#x3D;θ0<em>1+θ1</em>x1 + θ2*x2+…… .eg 最后写成矩阵点积 多元线性回归</p>
</li>
<li><p>通常向量n+1 个 第0个是1为了简化表达 其余都是一个特征维度</p>
</li>
<li><p>根据上述结论重写表达式就是将θ化成对应n+1维向量然后求偏导时乘以一个xj^(i)的值。</p>
</li>
<li><p>比列失调的等高线梯度下降可能出现震荡，使用特征缩放相当于变量代换更高效将值约束在-1，1之间大约 还有归一化处理 使得平均值在0 x1-u1 代换 本质就是线性组合 u1 就是平均值 x1-u1&#x2F;s u1 就是平均值 s就是标准差 就是概率论</p>
</li>
<li><p>关于学习率α 过大可能会波动或者发散 国小很慢 总之尝试不同的一系列值</p>
</li>
<li><p>多项式回归 但是我还是有问题 函数都是人提出来 没有机器自己去寻找</p>
</li>
<li><h3 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a><font color=cyan>Normal Equation</font></h3><ul>
<li>线性代数永远的神，但是我已经忘记了~~~~~ 其实就是线代中的回归方程 男泵投影！！！！！</li>
<li>似乎用于线性回归，缺点：当n增大时会很慢 复杂度为3次方 而梯度下降可以正常的 大概10000为界限 例如 Word2vec 使用梯度下降法 而且只使用与线性 梯度是通法</li>
<li>pinv inv pinv 进阶求逆 可以是伪逆 可是当时没看</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="Deep-learning"><a href="#Deep-learning" class="headerlink" title="Deep learning"></a><font color=tan>Deep learning</font></h2><ul>
<li><p><font color=red>简介。机器学习就是找函数function.在台大的课中只会有梯度下降 梯度下降开始的值朴素的是随机的，但是可能存在更好的 初始值	全面的回归求解其实就是训练<br>模型就是我们提出的拟合方程 课程采用的是绝对值衡量</font></p>
</li>
<li><h2 id="piecewise-linear-curve所有线性的折线都可以用一组z来拟合-同理对于光滑的-我们可以无线细分-由piecewise-linear-curve-来逼近-进一步又由蓝色来逼近-！！！！！！！！！！！"><a href="#piecewise-linear-curve所有线性的折线都可以用一组z来拟合-同理对于光滑的-我们可以无线细分-由piecewise-linear-curve-来逼近-进一步又由蓝色来逼近-！！！！！！！！！！！" class="headerlink" title="piecewise linear curve所有线性的折线都可以用一组z来拟合 同理对于光滑的 我们可以无线细分 由piecewise linear curve 来逼近 进一步又由蓝色来逼近 ！！！！！！！！！！！"></a><font color=lavender>piecewise linear curve所有线性的折线都可以用一组z来拟合 同理对于光滑的 我们可以无线细分 由piecewise linear curve 来逼近 进一步又由蓝色来逼近 ！！！！！！！！！！！</font></h2></li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/efunc.png"
                     
                ></p>
</li>
<li><p>y&#x3D;csigmoid(b+wx);  hard sigmoid w slopes b shift  </p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/bff.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/beauti.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/ddd.png"
                     
                ></p>
</li>
<li><p>sigmoid 的个数自己决定</p>
</li>
<li><p>实际的y帽 叫做 label</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/theta1.png"
                     
                ></p>
</li>
<li><p>batch 将N划分作batch随机的来求梯度</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/epoch.png"
                     
                ></p>
</li>
<li><p>epoch 是所有包都看了一遍 update就是一次更新 不一样</p>
</li>
<li><p>batch size learning rate 都是hyper parameter</p>
</li>
<li><p>ReLU rectified linear unit cmax(0,b+wx)就是hard sigmoid</p>
</li>
<li><p>就可以在所有sigmoid 使用的地方用ReLU</p>
</li>
<li><p>统称为activation function 老师都用的ReLU </p>
</li>
<li><p>可以多层进行变换 layers 就是得到a后再带入进去</p>
</li>
<li><p>多次ReLU 意思就是</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/network.png"
                     
                ></p>
</li>
</ul>
</li>
<li><p>为什么更深 乐 老师太好玩了！！！！</p>
</li>
<li><p>overfitting 过拟合问题 worse on unknown data</p>
</li>
<li><p>backpropagation </p>
</li>
<li><h3 id="anoconda-创建指令是全局的conda-create-然后可以在里面下载包-用vscode-启动可以-注意激活的时候要把代理关了"><a href="#anoconda-创建指令是全局的conda-create-然后可以在里面下载包-用vscode-启动可以-注意激活的时候要把代理关了" class="headerlink" title="anoconda 创建指令是全局的conda create 然后可以在里面下载包 用vscode 启动可以 注意激活的时候要把代理关了"></a><font color=pink>anoconda 创建指令是全局的conda create 然后可以在里面下载包 用vscode 启动可以 注意激活的时候要把代理关了</font></h3></li>
<li><h2 id="jupyter-notebook-guide"><a href="#jupyter-notebook-guide" class="headerlink" title="jupyter notebook guide"></a><a class="link"   href="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/install.html" >jupyter notebook guide <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2></li>
<li><p>jupyter 可以使用命令行调用 </p>
</li>
<li><pre><code class="python">jupyter notebook 然后就进入了browser
</code></pre>
</li>
<li><h2 id="Colab-使用"><a href="#Colab-使用" class="headerlink" title="Colab 使用"></a><strong><font color=slategray>Colab 使用</font></strong></h2><ul>
<li><p>python code 和 shell code 其中！接shell cmd cd除外 %cd</p>
</li>
<li><p>可以选择执行的硬件 GPU runtime type 里面</p>
</li>
<li><p>ctrl+ enter 执行一个代码cell</p>
</li>
<li><p>总体而言其实就是jupyter 只不过是个互联的jupyter.</p>
</li>
<li><p>左侧的文件图标查看结构 注意下载邮寄 可以上传到google硬盘</p>
</li>
<li><p>注意自己使用的时候是在google的GPU上 所以程序结束就会消失  注意自己保存</p>
</li>
<li><p><strong><font color=lightcyan>打开新的需要在file 里面upload notebook!!!! 可以的 注意一次只能有一个session 所以需要关掉前面的 notebook maybe<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/save.png"
                     
                >真的很不错一个tesla 真棒 然后我可以试试ssh之类的</font></strong></p>
</li>
<li><p><font color=yellow>然后现在发现了 ctrl+e 普通搜索很快 然后url 对url很快 因为对普通搜索会转换为我们的query 条目 然后会比较慢！！！</font></p>
</li>
<li><p><a class="link"   href="https://github.com/virginiakm1988/ML2022-Spring" >ML github repo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>pytorch tensor 相当于 array 可以GPU 加速</p>
</li>
<li><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a><font color=green>Pytorch</font></h2><ul>
<li>tensor就是高维数组 </li>
<li>还得复习一下基本的python 语法 list dict class func 基本的一些使用 顺便复习写一写爬虫</li>
<li>tensor constructor numpy zero tensor unit tensor</li>
<li>每个batch 的 loss funct 可能存在不同的差别</li>
<li>sigmoid 或者 Relu 叫做 neuron 总体叫做 neural network</li>
</ul>
</li>
<li><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong><font color=cornsilk>工具</font></strong></h2><pre><code>    *  training data 上的loss过大
</code></pre>
<ul>
<li>Model bias 就是 我们的函数太简单 解决方法 一 增加 特征量 二 增加layer deep learning</li>
<li>优化问题 梯度下降的问题</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/optm.png"
                     
                ></li>
<li>怎么解决 优化的问题 next lecgt</li>
<li>一定区分 overfitting 和 优化问题 一个是test data 一个是 training data<ul>
<li>overfitting <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/freestyle.png"
                     
                ></li>
<li>解决方法 增加 training data 二 data augmentation 就是自己创造一些条件 创造一些资料 需要有道理</li>
<li>减小弹性 增加限制</li>
<li>full- connected比较有弹性目前我们讨论的； CNN 比较无弹性<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/stop.png"
                     
                ></li>
</ul>
</li>
<li>区分 overfitting 与 model bias  存在一个complexity 与 bias 关系</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/trade.png"
                     
                ></li>
<li>刚刚好的<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/aaa1.png"
                     
                ></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA</title>
    <url>/2023/10/24/CUDA/</url>
    <content><![CDATA[<h1 id="CUDA-amp-Algorithm"><a href="#CUDA-amp-Algorithm" class="headerlink" title="CUDA&amp;Algorithm"></a><strong><font color=darkturquoise>CUDA&amp;Algorithm</font></strong></h1><ul>
<li><h2 id="Prelace"><a href="#Prelace" class="headerlink" title="Prelace"></a><font color=pink>Prelace</font></h2><p><strong><font color=mediumaquamarine>希望通过CUDA走进计算的前言，并且加深我对计算机体系结构的认知。同时从另一条路走进我们的machine learning 与 deep learning.同时也在这里写下一些算法的学习知识。</font></strong></p>
</li>
<li><h2 id="F-amp-Q"><a href="#F-amp-Q" class="headerlink" title="F&amp;Q"></a><font color=DarkSeagreen>F&amp;Q</font></h2><ul>
<li>内存布局具体硬件实现忘了，忘了栈实际上是在cache还是memory里</li>
</ul>
</li>
<li><h2 id="Heterogeneous-Computing"><a href="#Heterogeneous-Computing" class="headerlink" title="Heterogeneous Computing"></a><strong><font color=tan>Heterogeneous Computing</font></strong></h2><ul>
<li><p><font color=teal>host指cpu，host codes run in CPU ,CPU code is responsible for managing the code and environment and device code running in GPUs.</font></p>
</li>
<li><p><font color=cornsilk>common GPU architectur GeForce Tesla and Fermi in Tesla  Tesla professional hpc. GeForce consumer GPUs</font></p>
</li>
<li><p><font color =cornsilk>two metrics to discribe the GPU compute capability .the core no. and the memory</font></p>
</li>
<li><p><font color =cornsilk>互补的 CPU 逻辑复杂 擅长分支预测控制流切换 GPU 擅长大量数据 简单控制 并行计算 Threads of CPU are heavyweighted 上下文切换开销大。 GPU就是相对轻量级 的</font></p>
</li>
<li><p><font color =cornsilk>CUDA driver API and CUDA runtime API 我们一般使用 runtime API cuda codes 包含两个部分 一个是host code 另一个是device code </font></p>
</li>
<li><p><font color =cornsilk>kernels 就是device code 里的并行函数由 nvcc 编译 nvcc 会区分host code and device code 然后就是完全分开执行 good<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/cucode.png"
                     
                ></font></p>
</li>
<li><p><font color =cornsilk>hello from GPU GPU program structure 5 steps 分配显存 加载数据 invoke kernel 返回数据 销毁显存</font></p>
</li>
<li><p><font color =cornsilk>locality temporal locality and spatial locality 这是编写cpu程序注意的 而GPU 将存储架构和线程结构都展示给程序员</font></p>
</li>
<li><p><font color =cornsilk>three key abstractions 三个关键抽象对于GPU 1. hierarchy of thread groups 2. hierarchy of memory 3. barrier synchronization </font></p>
</li>
<li><p><font color=cornsilk><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/nvcc.png"
                     
                >nvcc 支持的文件后缀 .c 普通的是可以编译的</font></p>
</li>
<li><p><font color=cornsilk>programming model 其实就是 抽象 通过使用compiler and library &amp; OS 对hardware architecture 的抽象   scalability 可拓展性</font></p>
</li>
<li><p><font color=cornsilk>Host CPU and its memory ; Device : GPUs and its memory eg h_ for host m; d_ for device space</font></p>
</li>
<li><p><font color=cornsilk>Kernel 即跑在GPU 的codes我们可以看作是一个普通函数 实际上 GPU将其分配在多个线程上同时运行 ，当kernel运行后控制会立马交还给cpu以开始其他工作 异步工作。serial code 串行码 complemented by parallel code</font></p>
</li>
<li><p>&#96;&#96;&#96;cpp</p>
</li>
</ul>
<p>  &#x2F;* Memory management <em>&#x2F;<br>  malloc(); -&gt; cudaMalloc();<br>  memcpy(); -&gt; cudaMemcpy();<br>  cudaMemset();<br>  cudaFree();	&#x2F;&#x2F; all in device memory which is seperated from host memery!!<br>  &#x2F;&#x2F; the signature of the func<br>  cudaError_t cudaMalloc(void**devPtr,size_t size);&#x2F;&#x2F; the pointer is returned in the devPtr<br>  cudaError_t cudaMemcpy ( void</em> dst, const void* src, size_t count,cudaMemcpyKind kind ) &#x2F;&#x2F; the kind takes one of the following types cudaMemcpyHostToHost –HostToDevice –Dev2Dev D2H this func 是同步的 host 会阻塞知道完成<br>  &#x2F;&#x2F; cudaError_t enumerated type include cudaSuccess .eg<br>      char*cudaGetErrorString(cudaError_t error);</p>
<pre><code>
* 

* &lt;font color=cornsilk&gt;Global memory and shared memory in device just like memory and cache in CPU 前面的分配的函数都是在global memory 里面就像我们的malloc一样 目前我们所知道的由于这样内存分类 对应的指针是不能类型转换的，只能用cudaMemcpy来完成转移 后期由unified memory&lt;/font&gt;

* &lt;font color=cornsilk&gt;![](../images/bg.png)通常而言 grid是二维 block是三维  blockDim gridDim dim3 type 没有初始化的filed自动为1&lt;/font&gt;

* &lt;font color=cornsilk&gt;P88 warp执行模型 32 个thread 硬件层面都会变成 warp 然后分散在SM上执行 之所以可以是主要是内存资源决定的 32 cores是共享的 前面说到多个warp scheduler 调度将warp的一个指令放到16core的一个组合上运行 其中register file 决定了warp 数量 shared memory 决定sm的block数量 然后warp切换上下文没有开销 都是data分割的 ![](../images/limiter.png)&lt;/font&gt;

* &lt;font color=cornsilk&gt;![](../images/warp.png)warp 注意4 这个数字是由架构中每个SM的scheduler决定的 stall warp eligible warp 因此我们要最大化active warps&lt;/font&gt;

* **&lt;font color=mediumseagreen&gt;divergence 会执行所有分支 我们将分支按warp 划分&lt;/font&gt;**

* **&lt;font color=pink&gt;latency hiding ![](../images/latency.png)类似于CPU的调度 latency就是时间 一般用clock cycle 计算大小&lt;/font&gt;**

* &lt;font color=cornsilk&gt;P91 有趣的排队理论 就是需要同时并行的操作数=延迟（cycle）*预期throughput throughput 与 bandwidth used interchangably bandwidth refer to as peak data transfer per time unit throughput refer to as any operations       rate metrics都是throughput单位 ops per cycle per SM 也可以进一步用warps表示也就是/32 so the underlying thing of latency hidding is that you should increase the parallesiem to move like sequential ops without waiting &lt;/font&gt;

* &lt;font color=pink&gt;latency hidding 总体而言需要更多的并行操作也就是需要更多的active warps 但是这个数量又是由memory and register 限制的所以configuration 很重要&lt;/font&gt;

* &lt;font color=cornsilk&gt;有趣的建议 ![](../images/tipss.png)&lt;/font&gt;

* &lt;font color=cornsilk&gt;一些使用CUDA 的建议 ![](../images/bsize.png)太大的block size 会使每个thread硬件资源很少 太小的 block size warp 数量太少&lt;/font&gt;
</code></pre>
</li>
<li><h2 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a><font color=slatecyan>Synchronization</font></h2><ul>
<li><strong><font color=cornsilk>两个层面 host and device 2 thread </font></strong></li>
<li><strong><font color=cornsilk><strong>device</strong> void __syncthreads(void) 一个让同一个block 的线程同步的函数</font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
<li><strong><font color=cornsilk></font></strong></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
</search>
